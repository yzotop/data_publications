---
tags:
  - data
link: https://habr.com/ru/companies/X5Tech/articles/783390/
source: habr
author: X5
data_type:
  - DS
company: X5
---
## Введение

В настоящее время набирают популярность модели Reinforcement Learning для решения прикладных задач бизнеса. В этой статье мы рассмотрим подмножество этих моделей, а именно **_многоруких бандитов (multi-armed bandits)._** Также мы:

- обсудим, какие задачи теоретически могут быть решены с помощью этих моделей;
    
- рассмотрим некоторые популярные реализации моделей многоруких бандитов;
    
- опишем симулятор ценообразования, применим эти алгоритмы в нём и сравним их эффективность.
    

### Многорукие бандиты – практические примеры

Идея методов многоруких бандитов заключается в том, что исследуется множество возможных вариантов (“ручек”) так, чтобы найти ручку с максимальным выигрышем и с минимальными затратами на поиск этой самой ручки. Подход многоруких бандитов может быть полезен в ситуациях, когда у нас есть фиксированный набор действий/вариантов, которые нацелены на увеличение некоторого показателя, но об отклике на это действие заранее мы практически ничего не знаем.

Приведём несколько примеров, где может быть применима такая логика.

**Пример из маркетинга**  
Предположим, что мы начисляем бонусные баллы клиентам с целью решения каких-то маркетинговых задач. Клиенту можно предложить 500, 1000 или 1500 баллов и, очевидно, что эффекты по итоговой выручке/трафику будут разными.  
Ещё схожий пример можно взять из ритейла техники: при покупке смартфона можно предложить скидку в зависимости от минимальной цены аксессуара(ов), соответственно, в такой ситуации многорукий бандит будет искать оптимум по условиям скидки, что проиллюстрировано в таблице:

|   |   |   |   |
|---|---|---|---|
|Условие|Минимальная стоимость аксессуаров|Скидка|Спрос|
|№1|1000|500|?|
|№2|1500|500|?|
|№3|2000|1000|?|

**Пример из ценообразования**  
Довольно часто встречается ситуация, когда история продаж товара содержит только одну цену, например, из-за новизны товара, или из-за специфики модели ценообразования и спроса. В таких случаях, мы ничего не знаем о том, как бы он продавался по другой цене. Потенциально цена может быть неоптимальной с точки зрения выручки или валового дохода, в этом случае для выбора оптимальной цены также могут помочь многорукие бандиты:

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|цена|80|90|100|110|120|
|продажи, шт.|?|?|500|?|?|
|продажи, руб.|?|?|500000|?|?|
|валовый доход, руб.|?|?|100000|?|?|

**Поиск кратчайшего пути**  
Интересный пример применения многоруких бандитов был рассмотрен авторами [статьи](https://arxiv.org/abs/1707.02038), в которой ставится задача поиска оптимального пути в графе из одной вершины в другую. Про граф известно только наличие связей, но не стоимость переходов через промежуточные вершины (такая задача может возникнуть, например, в построении оптимальных маршрутов), так как выбор маршрута является дискретным, то здесь может быть применена стратегия многоруких бандитов.

**Симулятор задачи ценообразования для сети магазинов  
  
**Создадим симулятор, в котором под **_средой_** мы будем понимать множество магазинов с известным случайным распределением спроса на товар, а **_агентом_** будет какая-то математическая модель, использующая данные среды для расчёта цен. В симуляторе также добавим ограничения офлайн магазина:

- Допустимо изменять цену в магазине не чаще одного раза в неделю;
    
- Цена может меняться не более чем на 10%.
    

![Рис 1. Схема симулятора](https://habrastorage.org/r/w1560/getpro/habr/upload_files/df7/dc3/270/df7dc3270ed9b86d2da88004d9cc50c4.jpg "Рис 1. Схема симулятора")

Рис 1. Схема симулятора

Для генерации спроса будем использовать следующую **модель спроса** (которую мы уже применяли в [одной](https://habr.com/ru/companies/X5Tech/articles/685590/) из предыдущих статей):

![\lambda(p) = Q_0 \cdot \exp\bigg(E \cdot \Big(\frac{p}{p_0} - 1\Big)\bigg),](https://habrastorage.org/getpro/habr/upload_files/d86/b5c/443/d86b5c443ac50a4429e56def2d680d18.svg)![Q(p) \sim Poisson(\lambda(p)),](https://habrastorage.org/getpro/habr/upload_files/ac0/bc7/967/ac0bc7967175198b06e410b6e837818c.svg)

где  
![Q_0](https://habrastorage.org/getpro/habr/upload_files/4f6/e64/082/4f6e64082310398093c591be4e75c5a7.svg) - средний спрос в шт/кг,  
![p_0](https://habrastorage.org/getpro/habr/upload_files/a8a/420/8b9/a8a4208b9e1343f143cbf38907e684ef.svg) - текущая цена,  
![p](https://habrastorage.org/getpro/habr/upload_files/c29/ef4/cb1/c29ef4cb1f41f1a7caa675ab524b7df8.svg) - искомая цена, которая берется из заданной сетки цен(ручек), ![p \in \{P_1, P_2, ..., P_m \}](https://habrastorage.org/getpro/habr/upload_files/bac/730/b06/bac730b067613afab4a4a06e883c67b3.svg),  
![E](https://habrastorage.org/getpro/habr/upload_files/b36/025/97e/b3602597ee68bb3ccaa1776822c6e0eb.svg) - эластичность спроса от цены.

Оборот ![S](https://habrastorage.org/getpro/habr/upload_files/835/999/9d6/8359999d6e27e0fc1de47cc2767aba5d.svg) и прибыль ![M](https://habrastorage.org/getpro/habr/upload_files/adb/d3c/4d3/adbd3c4d35e5771f0c54425800ab66eb.svg) определяются следующими выражениями:

![S = p \cdot Q(p),](https://habrastorage.org/getpro/habr/upload_files/305/b2c/7a4/305b2c7a4f1b01ad7709c9127ab61a40.svg)![M = (p - c) \cdot Q(p),](https://habrastorage.org/getpro/habr/upload_files/eb8/6eb/90d/eb86eb90da852513dc26b577aaf2267c.svg)

где ![c](https://habrastorage.org/getpro/habr/upload_files/647/727/f66/647727f66ed76a03b1fcc45ea32d790c.svg) - себестоимость товара.

Оптимальное решение по цене для прибыли в предложенной модели можно найти аналитически: ![p^* = (c \cdot E - p_0) / E](https://habrastorage.org/getpro/habr/upload_files/1cf/205/dc5/1cf205dc5dc222ad63e24b8ba0c6da0f.svg).

Ниже приведены графики спроса и прибыли, на которых видно, что оптимум по прибыли в этой модели сильно зависит от значения эластичности:

![Рис. 2. Графики модельных функций](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d8d/950/312/d8d9503126ebaf253072d843b8be869d.png "Рис. 2. Графики модельных функций")

Рис. 2. Графики модельных функций

**Эластичность**  
Если есть исторические данные спроса при разных ценах, то можно аппроксимировать зависимость продаж от цены, откуда получить параметр эластичности. Для этого будем использовать линейную пуассоновскую модель следующего вида:

![\lambda(p) = \exp(a \cdot p + b),](https://habrastorage.org/getpro/habr/upload_files/54c/6b0/e0a/54c6b0e0af0d4e6bef76f95840a53acb.svg)

учитывая, что

![\lambda(p) = Q_0 \cdot \exp\bigg(E \cdot \Big(\frac{p}{p_0} - 1\Big)\bigg) = \exp\bigg(\frac{E}{p_0}\cdot p + \ln(Q_0) - E\bigg)](https://habrastorage.org/getpro/habr/upload_files/ebb/556/de9/ebb556de9b24fed46cf010d448c84eaa.svg)

можно, сопоставляя, формулы выше выразить параметры модельного спроса через параметры аппроксимации ![a, b](https://habrastorage.org/getpro/habr/upload_files/a0b/46e/dcb/a0b46edcb29218ca6772a32d9cd4a24e.svg) следующим образом: ![E = a\cdot p_0, Q_0 = \exp(b + a\cdot p_0)](https://habrastorage.org/getpro/habr/upload_files/0b5/80f/75e/0b580f75e22199d103265584e65045cf.svg).  
Найденную таким образом зависимость спроса от цены мы можем использовать для поиска лучшего решения на заданной сетке цен, а полученное решение будем далее сравнивать с решениями других моделей.

### Стратегии многоруких бандитов

Сделаем краткое описание алгоритмов, которые будем сравнивать в симуляторе ценообразования, в этом контексте некоторые детали будет проще пояснять.  
Для задачи ценообразования **_ручкой_** является одна из перебираемых цен на товар, **_наградой или откликом_** – прибыль, полученная для конкретной цены, сожаление (**_Regret_**) – недополученная прибыль. Так как мы знаем точное решение, то Regret можно точно рассчитать как разницу откликов между текущей и оптимальной (если точнее, то ближайшая к оптимуму цена исследуемого множества

**Жадные стратегии greedy/epsilon-greedy/epsilon-decay**  
  
Жадная (**greedy**) стратегия заключается в выборе лучшей ручки по собранному за время экспериментов отклику. Если отклик является не случайным и стационарным, то данная стратегия точно скажет, какая ручка лучшая. В реальности отклик является случайной величиной, поэтому после проведения исследования не гарантируется, что ручка с наибольшим средним будет действительно лучшей.  
  
В каком-то смысле жадная стратегия выступает аналогом АБ-тестирования для рассматриваемых ручек, в начале эксперимента цены случайно в одинаковых количествах отправляются в магазины на всю продолжительность эксперимента, далее выбирается лучшая ручка по среднему отклику.  
  
Эпсилон-жадная (**eps-greedy)** стратегия является модификацией **greedy** стратегии.   
В ней с вероятностью![1- \epsilon](https://habrastorage.org/getpro/habr/upload_files/62c/1a6/274/62c1a6274d8ab9ff29ebd16fcb00af2b.svg) мы выбираем лучшую на данный момент эксперимента ручку, а с вероятностью eps – случайную любую другую. Таким образом появляется возможность дополнительно проверять другие ручки, что позволяет повысить шансы на выбор лучшей ручки в ходе итераций. 

В eps-greedy стратегии мы асимптотически![100 \cdot \epsilon \ \%](https://habrastorage.org/getpro/habr/upload_files/f63/827/177/f63827177dcb860d95d6b279f69d11e4.svg) действий тратим на исследование, что может быть затратно. Стратегия **eps-decay** снижает ![\epsilon](https://habrastorage.org/getpro/habr/upload_files/a57/1d6/f5e/a571d6f5e9d25f0b069a2d4b5f9b8ea6.svg) во времени, например, по правилу ![\epsilon_0/(1 + j \cdot d)](https://habrastorage.org/getpro/habr/upload_files/038/ce5/313/038ce53134693e83f471c6ce5ae03a79.svg), где ![j](https://habrastorage.org/getpro/habr/upload_files/e08/9af/4df/e089af4df720ab895c86ab0a93e537f4.svg) – номер итерации, ![d](https://habrastorage.org/getpro/habr/upload_files/1c9/a96/54c/1c9a9654c19120759793dba8a60be495.svg) – параметр скорости затухания ![\epsilon](https://habrastorage.org/getpro/habr/upload_files/5a1/d55/443/5a1d55443b3be0266666993e7b2d08c7.svg). Если ![d=0](https://habrastorage.org/getpro/habr/upload_files/e49/10c/693/e4910c6938b016285b574f5218c5b4c7.svg) , то стратегия совпадает с **eps–greedy** при ![\epsilon = \epsilon_0](https://habrastorage.org/getpro/habr/upload_files/259/64c/10e/25964c10ed75ea7731a7bfbb763e5a92.svg).

Рис 3. Динамика показателей модели EpsGreedy

![Рис 3.1 Динамика показателей модели EpsGreedy при различных Q0](https://habrastorage.org/r/w1560/getpro/habr/upload_files/1e3/ad8/336/1e3ad83367782c49fd6b20d22eeb12e5.png "Рис 3.1 Динамика показателей модели EpsGreedy при различных Q0")

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/3d1/959/9c2/3d19599c220969a65ae14e616e34d733.png)

**Softmax**  
Данная стратегия (её также можно встретить в литературе как Boltzman Exploration) основана на вероятностном выборе ручек согласно значениям вероятностей по формуле:

  
![P_i = \frac{\exp(Q_i / \tau)}{\sum_{i=1}^{m}\exp(Q_i/\tau)}](https://habrastorage.org/getpro/habr/upload_files/1d1/f53/803/1d1f538031fcf97f4d428e1a99bbd56c.svg),

здесь ![P_i](https://habrastorage.org/getpro/habr/upload_files/b7f/405/e0e/b7f405e0e21500fc7f9619dc3f2ceb22.svg) – вероятность выбора ручки ![i](https://habrastorage.org/getpro/habr/upload_files/ef0/439/2cf/ef04392cf7880f50b4b4290a56314fd5.svg), ![Q_i](https://habrastorage.org/getpro/habr/upload_files/7cf/860/8b6/7cf8608b673b083f90c8598e390307de.svg) – текущая оценка средней награды ручки ![i](https://habrastorage.org/getpro/habr/upload_files/1e4/f54/048/1e4f54048c47658a0c7275b0dd747a7f.svg), ![\tau](https://habrastorage.org/getpro/habr/upload_files/f03/ea0/725/f03ea0725fbe773eed93834fd03ac463.svg) – параметр температуры.  
Как видим из формулы, с наибольшей вероятностью стратегия будет выбирать ручку с наибольшим значением текущей оценки среднего вознаграждения, а сама вероятность регулируется параметром температуры . Если ![\tau](https://habrastorage.org/getpro/habr/upload_files/369/fb5/184/369fb51847d61b21fa56ef4ac7f83e8d.svg) стремится к бесконечности, то все ручки становятся равнозначны, то есть бандит производит только исследование всех ручек. В случае если tau стремится к нулю, то вероятность выбора самой лучшей ручки на текущий момент стремится к 1, таким образом бандит производит только использование самой лучшей ручки, по факту превращаясь в жадную стратегию. Данную стратегию можно модифицировать, задавая расписание изменения параметра ![\tau](https://habrastorage.org/getpro/habr/upload_files/76b/12e/1d9/76b12e1d9fd044d1af5917a02543688f.svg) (как в стратегии ![\epsilon](https://habrastorage.org/getpro/habr/upload_files/495/4e1/994/4954e1994f3f0c4945c568588fa8b666.svg)-decay) – как правило, это охлаждение, то есть постепенное снижение температуры ![\tau](https://habrastorage.org/getpro/habr/upload_files/108/e40/b25/108e40b25fc1b27ddb113bff63a04ffa.svg). Здесь мы будем брать ![\tau](https://habrastorage.org/getpro/habr/upload_files/aa6/ed7/e9d/aa6ed7e9d1279d3ca3c027679f2937e5.svg) равным среднему отклику.

Рис 4. Динамика показателей модели SoftMax при различных параметрах

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f92/b5b/dc5/f92b5bdc5b9523285708c167eed384a2.png)

**UCB**  
Стратегия Upper Confidence Bounds или коротко UCB заключается в следующем – на каждой итерации выбираем ту ручку, которая даёт наибольшее значение величины:

![Q_{i} + c \cdot \sqrt{\frac{\ln{n}}{n_i}},](https://habrastorage.org/getpro/habr/upload_files/e33/f23/327/e33f233277ac1eaf66690b4b9fa3f9a8.svg)

где ![i](https://habrastorage.org/getpro/habr/upload_files/021/97c/d00/02197cd00fd6e0f44a555a66256890d1.svg) - номер ручки, ![Q_i](https://habrastorage.org/getpro/habr/upload_files/0bb/ba2/eac/0bbba2eac05735205b32f132680b42a9.svg) – среднее значение отклика для ручки, ![n](https://habrastorage.org/getpro/habr/upload_files/09f/8d1/4e8/09f8d14e89fc56c38215141bb8afbe09.svg) – количество наблюдений (сколько раз была выбрана любая ручка), ![n_i](https://habrastorage.org/getpro/habr/upload_files/3b9/4ac/0c4/3b94ac0c4d39a1361ecd7030fadb81d3.svg) – количество выбора ручки ![i](https://habrastorage.org/getpro/habr/upload_files/c1d/9d5/a2c/c1d9d5a2c5e3664a0b6ab6ad6f3d6736.svg).

Здесь первое слагаемое отвечает за использование лучшей ручки к текущему шагу, а второй – за исследование ручек. Параметр ![c](https://habrastorage.org/getpro/habr/upload_files/402/f6b/0bb/402f6b0bb780944c374548c0147b90c8.svg)отвечает за баланс между использованием/исследованием, если ![c=0](https://habrastorage.org/getpro/habr/upload_files/3c5/6c8/540/3c56c854054b162487145279ad49e73b.svg) – то по факту получаем жадный алгоритм, если ![c \to \infty](https://habrastorage.org/getpro/habr/upload_files/b6b/cf4/378/b6bcf4378c0570e4d5ef37a3b5feac36.svg), то все ручки будут равноправны – то есть получается случай только исследования. Отметим также, что параметр![c](https://habrastorage.org/getpro/habr/upload_files/2df/794/9e3/2df7949e3972dd1b7c073f4b9d6711e0.svg)необходимо подбирать так, чтобы достичь лучшей сходимости алгоритма. Как правило, на выбор оказывает влияние дисперсия отклика и разница между минимальным и максимальным значением отклика на всех ручках.  
  
**UCB+QBC  
**Данная стратегия является развитием стратегии **UCB,** к которой добавляется элемент [активного](https://en.wikipedia.org/wiki/Active_learning_(machine_learning)) обучения. Здесь, если ручки – это дискретный набор из непрерывной переменной, то можно попробовать аппроксимировать функцию отклика от этой переменной, причём сделать это с помощью разных функций (например, параболой, гауссианой и т.п.) и использовать данные о расхождениях моделей для лучшего уточнения аппроксиматоров – такая концепция называется Query by Committee (или коротко **QBC**). В таком случае алгоритм выбора следующей ручки заключается в выборе той, которая даёт максимальное значение выражению:

![\hat{F}(p_i) + c \sqrt{\frac{\ln{n}}{n_i}} + d\sqrt{\frac{1}{M}\sum_{j=1}^M\bigg(F_j(p_i) - \hat{F}(p_i)\bigg)^2},](https://habrastorage.org/getpro/habr/upload_files/251/d29/429/251d29429b1ba145e1594603fefbf754.svg)![\hat{F}(p_i) = \frac{1}{M} \sum_{j=1}^{M}F_j(p_i),](https://habrastorage.org/getpro/habr/upload_files/c6f/236/5c7/c6f2365c72772f94ed5aeb8daea6a98d.svg)

где ![M](https://habrastorage.org/getpro/habr/upload_files/5bb/847/fa7/5bb847fa762397404c611aa1fc163a17.svg) – количество моделей-функций, с помощью которых аппроксимируется зависимость отклика; ![F_j](https://habrastorage.org/getpro/habr/upload_files/2a0/876/cf3/2a0876cf3062a0ff95639401f17f685f.svg)– ![j](https://habrastorage.org/getpro/habr/upload_files/10d/b00/5e3/10db005e34e5de53b82ff9a0d9bfa659.svg) – ая функция из набора ![M](https://habrastorage.org/getpro/habr/upload_files/002/4b0/3e8/0024b03e88121f1f1680f8dc27711bce.svg) разных функций, с помощью которой производится аппроксимация зависимости отклика от цены.

Здесь первые слагаемые играют ту же роль, что и в обычном UCB, описанном выше, только теперь на первом месте стоит среднее от оценок модели ![\hat{F}(p_i)](https://habrastorage.org/getpro/habr/upload_files/c0d/63a/3f5/c0d63a3f5a3671ad33fd02aaa2d0e380.svg), третье слагаемое здесь отвечает за расхождение в комитете моделей для каждой ручки(QBC).  
  
В качестве функций аппроксимации мы выбрали 7 параметрических функций, часть из которых имеют один глобальный максимум. Перечислим их:

Функции для аппроксиматоров

[](https://en.wikipedia.org/wiki/Skew_normal_distribution)  
![\phi(x)](https://habrastorage.org/getpro/habr/upload_files/4c8/83e/606/4c883e6067e27c0c6dc7c3d1a4e3feb2.svg)  
![\Phi(x) = 0.5 \cdot(1 + erf(x))](https://habrastorage.org/getpro/habr/upload_files/e7b/1ec/b98/e7b1ecb985e8f4588f7ac4643efc8c33.svg)![erf(x)](https://habrastorage.org/getpro/habr/upload_files/9a1/9df/afc/9a19dfafc20ad4d67c726b852d235515.svg)

![F(x) = c\cdot2\phi\bigg(\frac{x-x_0}{s}\bigg)\Phi\bigg(a\cdot\frac{(x-x_0)}{s}\bigg),](https://habrastorage.org/getpro/habr/upload_files/d83/21d/c14/d8321dc1456a8568fb9b509f2f3f2038.svg)

![a](https://habrastorage.org/getpro/habr/upload_files/46c/cf4/579/46ccf457911aebdb1a559b05e3a6e2d2.svg)![x_0](https://habrastorage.org/getpro/habr/upload_files/d4f/454/d6b/d4f454d6bcb07e53f5da2ac9efa29c22.svg)![s](https://habrastorage.org/getpro/habr/upload_files/55c/5cb/399/55c5cb3999aa94abd695dc52102805f5.svg)

![F(x) = a \cdot(x-x_0)^2 + b](https://habrastorage.org/getpro/habr/upload_files/fd9/164/090/fd9164090ff4845502e241c9c676e346.svg)

![F(x) = a \cdot x^b \cdot \exp(-c \cdot x)](https://habrastorage.org/getpro/habr/upload_files/055/4ca/774/0554ca77471bc5d8a6bb2a121b4b9ae6.svg)

![F = a \cdot x + b](https://habrastorage.org/getpro/habr/upload_files/330/014/2cc/3300142ccdccecd7a271886ee5deb17d.svg)

![F(x) = a \cdot \exp\bigg(-\Big(\frac{x-b}{c}\Big)^2\bigg)](https://habrastorage.org/getpro/habr/upload_files/734/c3a/7c2/734c3a7c29876081feb508a9da918e9a.svg)

![F(x) = \frac{a}{1+\big(\frac{x-b}{c}\big)^2}](https://habrastorage.org/getpro/habr/upload_files/a52/541/c5e/a52541c5e577645d7db4cf5d2efd9e65.svg)

[](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html)

Иллюстрация аппроксиматоров для модели UCB+QBC

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a20/2bf/be6/a202bfbe63192c4f9b600eb686c4aaf2.png)

**Thompson sampling**  
В данной стратегии каждой ручке ставится в соответствие некоторое случайное распределение отклика (точнее, распределение его математического ожидания) и на каждом шаге производится сэмплирование случайных чисел из этих распределений, далее выбирается ручка с максимальным значением. После получения фактического отклика производится обновление параметров распределения, как правило, с помощью применения методов байесовского вывода.

В экспериментах для данной статьи продажи ![Q_i](https://habrastorage.org/getpro/habr/upload_files/22d/286/bc2/22d286bc22d5f34c63db09b86a215d2b.svg) по цене ![p_i](https://habrastorage.org/getpro/habr/upload_files/968/873/ac5/968873ac564df561e660e8cc2f9102e4.svg) моделируются распределением [Пуассона](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9F%D1%83%D0%B0%D1%81%D1%81%D0%BE%D0%BD%D0%B0), которое описывается одним параметром ![\lambda_i](https://habrastorage.org/getpro/habr/upload_files/2a9/cfe/ee4/2a9cfeee4c70148f27086c56c046c1ac.svg) – математическое ожидание случайной величины ![Q_i](https://habrastorage.org/getpro/habr/upload_files/ad6/54c/3a7/ad654c3a779581360d6428df13651b58.svg) . Сопряжённым для распределения Пуассона является гамма распределение ![\Gamma(\alpha, \beta)](https://habrastorage.org/getpro/habr/upload_files/836/ed1/b5e/836ed1b5ebe06258d6d6b0982f365000.svg), поэтому оно используется для оценки распределения по [Байесу](https://en.wikipedia.org/wiki/Conjugate_prior#:~:text=When%20the%20likelihood%20function%20is%20a%20discrete%20distribution), математическое ожидание оценки ![\alpha/\beta](https://habrastorage.org/getpro/habr/upload_files/e6d/e25/35b/e6de2535b6edfe696766ee4cc6384b13.svg), дисперсия ![\alpha/\beta^2](https://habrastorage.org/getpro/habr/upload_files/629/476/da3/629476da3149491ceb4bdf5465de7788.svg), обновление параметров гамма распределения после получения одного наблюдения производится по формулам ![\alpha \gets \alpha + d](https://habrastorage.org/getpro/habr/upload_files/572/666/4cd/5726664cd45ee498bb1c2f53a58bdf82.svg), ![\beta\gets\beta+1](https://habrastorage.org/getpro/habr/upload_files/0c9/c0e/2f5/0c9c0e2f59afcf0411e4ea428437f624.svg) , где ![d](https://habrastorage.org/getpro/habr/upload_files/236/213/b18/236213b182d4ae4fcb61beaae88de816.svg)– это результат сэмплирования из пуассоновского распределения. Здесь мы исследуем поиск оптимума валовой маржи, то есть величины ![(p_i - c) \cdot Q_i](https://habrastorage.org/getpro/habr/upload_files/a1f/17e/f39/a1f17ef3909c9d2be7136535eb163d2c.svg), она отличается от исходного пуассоновского распределения фиксированным множителем ![(p_i - c)](https://habrastorage.org/getpro/habr/upload_files/7cd/b01/715/7cdb01715a78333aa4970f92ebce0059.svg), и для такой случайной величины, как несложно проверить, гамма распределение будет иметь параметры ![\Gamma((p_i-c)\cdot\alpha, \beta)](https://habrastorage.org/getpro/habr/upload_files/7b4/2b9/ecd/7b42b9ecd410f2cdedeb717e0173591d.svg), и в таком случае формула для обновления параметров будет иметь такой же вид, только теперь d – это результат сэмплирования валовой маржи.

Итого: для каждой ручки (цены) задаём априорное Гамма распределение параметров: ![\rho(\theta) = \Gamma(\alpha_i, \beta_i)](https://habrastorage.org/getpro/habr/upload_files/ece/d35/b7d/eced35b7db9117efa1cee2d65c1e3344.svg). В нашем случае это априорное распределение валовой маржи для каждой ручки-цены. Для первого шага случайно выбираем ручки и отправляем в эксперимент. Далее:

1. Обновляем параметры ![\alpha_i \gets\alpha_i + d_i](https://habrastorage.org/getpro/habr/upload_files/d55/d6b/f3e/d55d6bf3e40ab0221f5f2484401dac5c.svg) значение отклика, ![\beta_i \gets \beta_i + n_i](https://habrastorage.org/getpro/habr/upload_files/a84/49e/b16/a8449eb1669e50624f4cb238ba759eee.svg), которые отвечают за сумму прибыли и количество наблюдений, соответственно, для ручки ![i.](https://habrastorage.org/getpro/habr/upload_files/021/890/119/0218901199aecc7f3934743444af8212.svg)
    
2. Семплируем ручки из обновлённого априора.
    
3. Выбираем ту ручку, которая максимизирует целевую функцию и отправляем её в следующий эксперимент.
    

С более подробным описанием и иллюстрацией работы алгоритма для поиска оптимальной цены можно ознакомиться [тут](https://blog.griddynamics.com/dynamic-pricing-algorithms/).

Рис 6. Динамика показателей модели Thompson Sampling при различных Q

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d32/787/378/d32787378ce366ced940147f570d0069.png)

Разобравшись с описанием сравниваемых алгоритмов, перейдём к описанию параметров экспериментов и результатам моделирования.

### Результаты экспериментов

Зафиксируем параметры ![P_0=500](https://habrastorage.org/getpro/habr/upload_files/7af/202/334/7af2023345aff5749ca353158d4838af.svg) , ![c=400](https://habrastorage.org/getpro/habr/upload_files/3d7/b35/bec/3d7b35bec9c6d41218c8a3a76c33be13.svg), ![E=-5](https://habrastorage.org/getpro/habr/upload_files/fec/6e0/831/fec6e0831d31ebffbe6f34e34c34c583.svg) . Количество недель – 6, длина истории – 60 дней, количество ручек – 7, количество магазинов – 100, количество экспериментов – 500.

По результатам экспериментов мы будем считать **_долю верно угаданных оптимальных цен на последней неделе_** и средний суммарный на эксперименте **Regret**, а также среднее **суммарное число изменений цен**.

Здесь оптимальной ручкой/ручками будем считать те, на которых значение прибыли составляет значение более чем 99% от максимума на рассматриваемой сетке; цены на истории определяются случайно на заданном допустимом интервале цен с шагом в 5 рублей, а цены для поиска – равномерно делят искомый диапазон исследования. Также на первой итерации эксперимента цены не проходят через ограничение на изменение цен, так как было выявлено сильное влияние текущих цен при наличии ограничения на максимальное изменение текущей цены на 10%.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/cf5/e45/82f/cf5e4582f65157e725a77ad87dcb2e1d.png)

![Рис 7 Результаты расчётов при разном количестве цен на истории](https://habrastorage.org/r/w1560/getpro/habr/upload_files/523/079/f7a/523079f7a513f336da162095fa0ddfa6.png "Рис 7 Результаты расчётов при разном количестве цен на истории")

Рис 7 Результаты расчётов при разном количестве цен на истории

При росте количества цен на истории эластичность аппроксимируется точнее, что ожидаемо, так как мы использовали точную формулу для её аппроксимации. На практике так угадать, скорее всего, не получится, поэтому исключим эту модель из графиков далее.  
Лучшей по доле верно найденных ручек оказалась модель TS и Greedy, но по Regret Greedy показывает худший результат, а TS – лучший во всех экспериментах. Худшие результаты получились у EpsGreedy/Decay и SoftMax.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e44/ce1/282/e44ce12822d3acb80e1fae8ebb7c885b.png)

![Рис 8. Результаты расчётов при разном количестве ручек (и с двумя на истории)](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c9a/00f/dea/c9a00fdea0eba6a3440182460eef873b.png "Рис 8. Результаты расчётов при разном количестве ручек (и с двумя на истории)")

Рис 8. Результаты расчётов при разном количестве ручек (и с двумя на истории)

Явного победителя по всем рассмотренным вариантам количества ручек нет. Для 5 и 7 ручек лучшими по доле верно угаданных оказались TS и Greedy, для 11 и 13 ручек – UcbQbc, TS и Greedy. Как и в предыдущих экспериментах Greedy очень дорого обходится по метрике Regret.   
Резкое снижение метрик моделей в случае с 9 ручками связано с тем, что в оптимальный набор попадаем только одна цена, а, например, для 7 ручек – две, соответственно, доля попаданий методов в две ручки намного выше, чем в случае с одной.

**Оптимизация ценников.  
**В офлайн ценообразовании смена ценника стоит определённую сумму (труд на переклейку ценника, расходы на печать – это основные составляющие), поэтому целесообразно сократить количество смен ценников, но при этом сохранить ручки при исследовании. В связи с этим в симулятор добавлена логика перераспределение ценников так, чтобы минимизировать “работу” на изменение ценников в магазинах, что является задачей о [назначениях](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%D1%85) и решается [пакетом](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linear_sum_assignment.html) SciPy.

![Рис 9. Изменение количества ценников с оптимизацией (с оптимизацией / без оптимизации)](https://habrastorage.org/r/w1560/getpro/habr/upload_files/119/e10/fa8/119e10fa8c05e53073517bb97b3d7ea0.png "Рис 9. Изменение количества ценников с оптимизацией (с оптимизацией / без оптимизации)")

Рис 9. Изменение количества ценников с оптимизацией (с оптимизацией / без оптимизации)

Оптимизация назначений ценников сильно снижает количество изменений ценников для Softmax и EpsDecay. Для остальных методов существенного изменения не происходит.

### Заключение

Мы разобрали наиболее популярные на данный момент стратегии многоруких бандитов, сравнили их эффективность на модельной задаче ценообразования. Оценивая результаты расчётов, мы получили вывод, что для рассмотренных экспериментов победителями стали TS, UcbQbc. Greedy по доле верно найденных ручек даёт хороший результат, но сильно уступает по Regret. Надо отметить, что данный вывод может оказаться иным для других моделей спроса, а также при других параметрах моделей и эксперимента.

Над статьёй работали Будылин Михаил и Денисов Антон.