---
source: habr
link: https://habr.com/ru/articles/339342/
tags:
  - data
data_type:
  - DS
---
https://jdlm.info/articles/2017/08/05/markov-chain-2048.html

# Часть 1. Расчёт минимального количества ходов для победы с помощью цепей Маркова

  

![Screenshot of 2048](https://habrastorage.org/r/w1560/getpro/habr/post_images/3c8/6a6/0b4/3c86a60b46f5a08833a0c215a678c306.png)

  
После недавнего обновления экран «You win!» игры [2048](http://gabrielecirulli.github.io/2048) начал показывать количество ходов, потребовавшихся для победы, и я задался вопросом: сколько же нужно ходов, чтобы выиграть?  
  
В первой части статьи мы ответим на этот вопрос, смоделировав игру 2048 в виде цепи Маркова и проанализировав её, чтобы показать, что вне зависимости от мастерства игрока **для победы в среднем нужно не менее 938,8 ходов**. Это даёт нам неплохое мерило отсчёта — если вы можете выигрывать примерно за такое количество ходов, то неплохо играете.  
  
Количество ходов, необходимых для победы, зависит от случайности, потому что игра добавляет тайлы `2` и `4` случайным образом. Анализ также покажет, что распределение минимального количества ходов до победы имеет стандартное отклонение в 8,3 хода, и что его общая форма хорошо аппроксимируется смесью биномиальных распределений.  
  
Чтобы получить эти результаты, мы воспользуемся упрощённой версией 2048: вместо размещения тайлов на поле, мы… будем бросать их в мешок. То есть мы проигнорируем геометрические ограничения, вводимые формой поля, на которой могут объединяться тайлы. Такое упрощение сильно облегчит нашу работу, потому что игроку больше не придётся принимать никаких решений [1](https://habr.com/ru/articles/339342/#fn_mdp), и потому что нам не нужно будет отслеживать положение тайлов на поле.  
  
Ценой избавления от этих геометрических ограничений будет то, что мы сможем вычислить только нижнюю границу ожидаемых ходов до победы; может случиться так, что геометрические ограничения не позволят достичь этой границы. Однако, сыграв множество партий в 2048 (ради науки!), я также покажу вам, что на практике мы часто можем приблизиться к этой границе.  
  
Если вы незнакомы с 2048 или с цепями Маркова, то не волнуйтесь — я буду объяснять необходимые понятия по ходу статьи. Код (исследовательского качества), на основе которого написана статья, имеет [открытые исходники](https://github.com/jdleesmiller/twenty48), на случай, если вы захотите изучить код для генерирования [цепи](https://github.com/jdleesmiller/twenty48/blob/27c30f5e42861c87a2162efed38003a9db9e8b29/bin/markov_chain) и [графиков](https://github.com/jdleesmiller/twenty48/blob/27c30f5e42861c87a2162efed38003a9db9e8b29/data/markov_chain/plot.R).  
  

## 2048 как цепь Маркова

  
Чтобы представить нашу упрощённую игру «2048 в мешке» как цепь Маркова, нам нужно задать _состояния_ и _переходные вероятности_ цепи. Каждое состояние — это что-то вроде «слепка» игры в определённый момент времени, а переходные вероятности задают для каждого состояния вероятность перехода в него.  
  
Здесь мы закодируем каждым состоянием тайлы, находящиеся в данный момент в мешке. Нас не волнует порядок тайлов, поэтому мы можем воспринимать их как множество тайлов. Изначально в мешке нет тайлов, то есть начальное состояние — это просто пустое множество. В виде схемы, которую мы добавим ниже, это начальное состояние выглядит как:  
  

![The initial state for the Markov chain](https://habrastorage.org/getpro/habr/post_images/e33/04e/42b/e3304e42babeb5e08118543a16f8d7d7.svg)

  
  

### Подготовка поля

  

![Montage of a sample of eight setup states.](https://habrastorage.org/r/w1560/getpro/habr/post_images/5fb/b32/10e/5fbb3210e6a48172bd0a1a74a20549dc.png)

  
_Пример дюжины полей для новой игры._  
  
Когда мы начинаем новую игру в 2048, игра располагает на поле два случайных тайла (см. примеры выше). Чтобы представить это в цепи Маркова, нам нужно задать переходные вероятности из начального состояния в каждое из возможных последующих состояний.  
  
К счастью, мы можем посмотреть на [исходный код игры](https://github.com/gabrielecirulli/2048), чтобы понять, как игра это делает. Когда игра размещает на поле случайный тайл, она всегда следует такому сценарию: _выбирает случайным образом клетку, затем добавляет новый тайл, либо со значением `2` (с вероятностью 0,9), либо со значением `4` (с вероятностью 0,1)_.  
  
В случае «2048 в мешке» нас не волнует поиск свободной клетки, потому что мы не ставили никаких ограничений на ёмкость мешка. Нас интересует только добавление тайла `2` или `4` с заданной вероятностью. Это приводит к трём вероятным последующим состояниям из начального состояния:  
  

- ![$\left \{ 2,2 \right \}$](https://habrastorage.org/getpro/habr/formulas/8f2/e04/96f/8f2e0496f4c906c616ea4edc29b3d40b.svg), когда оба новых тайла имеют значение `2`. Это происходит с вероятностью ![$0,9 \times 0,9 = 0,81$](https://habrastorage.org/getpro/habr/formulas/465/aaa/c40/465aaac401c246da157c5e79394c693b.svg).
- ![$\left \{ 4,4 \right \}$](https://habrastorage.org/getpro/habr/formulas/5e2/d21/a8d/5e2d21a8d42b6b4cdf16b67ba0757faf.svg), когда оба новых тайла имеют значение `4`. Это происходит с вероятностью ![$0,1 \times 0,1 = 0,01$](https://habrastorage.org/getpro/habr/formulas/45b/e1a/fd3/45be1afd3851436f1b9e474f74e85fa5.svg), то есть вам довольно сильно повезло, если вы начинаете игру с двумя четвёрками.
- ![$\left \{ 2,4 \right \}$](https://habrastorage.org/getpro/habr/formulas/138/2be/d83/1382bed837d0d7f3c46e4b92491507ba.svg), когда новые тайлы имеют значение `2`, а потом `4`, что происходит с вероятностью ![$0,9 \times 0,1 = 0,09$](https://habrastorage.org/getpro/habr/formulas/546/0d1/bdf/5460d1bdffe0e86c8aae176d30cd99ba.svg), или сначала `4`, а потом `2`, что происходит с вероятностью ![$0,1 \times 0,9 = 0,09$](https://habrastorage.org/getpro/habr/formulas/ed4/173/502/ed41735022647c025e5a7d0f3f634e0f.svg). Нас не волнует порядок, поэтому оба случая приводят к одному состоянию с общей вероятностью ![$0,09 + 0,09 = 0,18$](https://habrastorage.org/getpro/habr/formulas/f1c/ef3/d9f/f1cef3d9fa6721e8b8ab2f8ad736395f.svg).

  
Мы можем добавить эти последующие состояния и их переходные вероятности в схему цепи Маркова следующим образом (переходные вероятности записаны на рёбрах, а новые узлы и рёбра обозначены синим):  
  

![Directed graph showing the initial state and its immediate successors: {2, 2}, {2, 4}, {4, 4}](https://habrastorage.org/getpro/habr/post_images/436/ddf/5b6/436ddf5b62bebeaded04c01092579cc9.svg)

  
  

### Играем в игру

  
Разместив первую пару тайлов, мы готовы начать игру. В реальной игре это бы значило, что игроку нужно провести влево, вправо, вверх или вниз, чтобы соединить пары одинаковых тайлов. Однако в нашей игре с мешком ничего не мешает нам соединить все пары одинаковых тайлов, поэтому так мы и сделаем.  
  
Правило объединения тайлов в игре с мешком будет следующим: _находим в мешке все пары тайлов, имеющие одинаковое значение, и удаляем их; затем заменяем каждую пару тайлов одним тайлом с удвоенным значением_ [2](https://habr.com/ru/articles/339342/#fn_merge).  
  
После объединения пар одинаковых тайлов для перехода к последующему состоянию игра случайным образом добавляет один новый тайл, воспользовавшись уже описанным выше процессом, то есть тайл `2` с вероятностью 0,9 или тайл `4` с вероятностью 0,1.  
  
Например, чтобы найти возможные последующие состояния состояния ![$\left \{ 2,2 \right \}$](https://habrastorage.org/getpro/habr/formulas/8f2/e04/96f/8f2e0496f4c906c616ea4edc29b3d40b.svg), мы сначала объединяем два тайла `2` в один тайл `4`, а затем игра добавляет или тайл `2`, или тайл `4`. Таким образом, возможными последующими состояниями будут ![$\left \{ 2,4 \right \}$](https://habrastorage.org/getpro/habr/formulas/138/2be/d83/1382bed837d0d7f3c46e4b92491507ba.svg) и ![$\left \{ 4,4 \right \}$](https://habrastorage.org/getpro/habr/formulas/5e2/d21/a8d/5e2d21a8d42b6b4cdf16b67ba0757faf.svg), которые, так уж получилось, мы встречали ранее. Тогда схема, содержащая эти два перехода от ![$\left \{ 2,2 \right \}$](https://habrastorage.org/getpro/habr/formulas/8f2/e04/96f/8f2e0496f4c906c616ea4edc29b3d40b.svg), которые имеют вероятность 0,9 и 0,1, соответственно, будет иметь вид:  
  

![Directed graph showing the additional transitions from the {2, 2} state](https://habrastorage.org/getpro/habr/post_images/c94/eba/650/c94eba650f7edc9d837ac38bf1b8723b.svg)

  
  
Если мы продолжим выполнять этот процесс для последующих состояний состояния ![$\left \{ 2,4 \right \}$](https://habrastorage.org/getpro/habr/formulas/138/2be/d83/1382bed837d0d7f3c46e4b92491507ba.svg), то увидим, что пока объединение невозможно, потому что нет пар одинаковых тайлов, и последующее состояние будет или ![$\left \{ 2,2,4 \right \}$](https://habrastorage.org/getpro/habr/formulas/da6/5e3/944/da65e3944e64326212b0059bbfc4b38e.svg) или ![$\left \{ 2,4,4 \right \}$](https://habrastorage.org/getpro/habr/formulas/caf/35d/b13/caf35db139985707201639c0645d5c34.svg), в зависимости от того, будет ли новый тайл иметь значение `2` или `4`. Тогда обновлённая схема будет такой:  
  

![Directed graph showing the additional transitions from the {2, 4} state](https://habrastorage.org/getpro/habr/post_images/f24/3c8/f4e/f243c8f4e40a16e352b5817a113abaad.svg)

  
  

### Слои и «пропуски»

  
Мы можем продолжить добавлять переходы таким образом. Однако при добавлении новых состояний и переходов схемы могут становиться всё более сложными [3](https://habr.com/ru/articles/339342/#fn_dot). Мы можем немного упорядочить схемы, воспользовавшись следующим наблюдением: **сумма тайлов в мешке увеличивается с каждым переходом или на 2, или на 4**. Так получается потому, что объединение пар одинаковых тайлов не меняет сумму значений тайлов в мешке (или на поле — это свойство применимо и к реальной игре), а значит, игра добавляет тайл `2` или тайл `4`.  
  
Если мы сгруппируем состояния по их сумме в «слои», то первые несколько слоёв будут выглядеть примерно так:  

![Directed graph showing states up to sum 12](https://habrastorage.org/getpro/habr/post_images/fdd/361/886/fdd361886379b835839ff819d48dc8ff.svg)

  
  
Чтобы снизить зашумлённость схем, для более поздних слоёв я также не указываю пометки для переходов с вероятностью 0,9 (сплошные линии, если они никак не помечены) и 0,1 (пунктирные линии).  
  
При группировке состояний в слои по суммам становится очевидной ещё одна закономерность: каждый переход (кроме перехода из начального состояния) совершается или в следующий слой с вероятностью 0,9, или в слой после него с вероятностью 0,1. (Это особенно очевидно, если посмотреть на слои с суммами 8, 10 и 12 со схемы выше.) То есть чаще всего игра даёт нам `2`, и мы переходим на следующий слой, но иногда нам везёт, и игра даёт нам `4`, и это означает, что мы можем пропустить слой, что немного приближает нас к цели — достижению тайла 2048.  
  

### Конец игры

  
Мы можем продолжать этот процесс вечно, но поскольку нас интересует только достижение тайла `2048`, мы остановим его в этот момент, сделав любое состояние с тайлом `2048` _поглощающим_. Поглощающее состояние имеет единственный переход, который ведёт к нему самому с вероятностью 1. То есть, достигнув поглощающего состояния, выйти из него уже не удастся.  
  
В этом случае все поглощающие состояния являются «состояниями победы» — мы получили тайл `2048`, а значит, выиграли игру. В «игре с мешком» нет возможности «проиграть», потому что в отличие от реальной игры, мы не можем попасть в ситуацию, когда поле (или мешок) заполнится.  
  
Первое состояние, содержащее тайл `2048` находится в слое с суммой 2066. Примечательно, что невозможно получить на поле единственный тайл `2048` — для объединения тайлов `1024`, тайлов `512`, и так далее, требуется несколько ходов, за которые накапливается больше тайлов `2` и `4`. Поэтому сумма тайлов для первого состояния с тайлом `2048` выше, чем 2048.  
  
Вот как выглядит граф возле этого первого выигрышного состояния ([посмотреть подробнее](http://jdlm.info/assets/2048/markov_chain_end.svg)). Поглощающие состояния выделены красным:  
  

![Screenshot of the end of the Markov chain](https://habrastorage.org/r/w1560/getpro/habr/post_images/5a5/530/d99/5a5530d99a51b497ac679b8cc4283619.png)

  
  
Если мы продолжим добавлять переходы до тех пор, пока не останется непоглощающих состояний, то в результате получим 3487 состояний, 26 из которых являются поглощающими; на этом завершится определение цепи Маркова. Схема полной цепи довольно велика, но если ваш компьютер способен справиться с 5-мегабайтным файлом SVG, [то вот схема полной цепи](http://jdlm.info/assets/2048/markov_chain_big.svg) (возможно, придётся немного прокрутить экран вниз, чтобы увидеть начало). Если уменьшить масштаб, то она будет выглядеть так:  
  

![Zoomed out view of the whole chain](https://habrastorage.org/r/w1560/getpro/habr/post_images/dc5/9b4/324/dc59b432496fed92b9ba948de949b75a.png)

  
  

### Выборки из цепи

  
Теперь, когда мы вложили столько усилий в моделирование игры 2048 (в мешке) в виде цепи Маркова, нужно выяснить, сколько ходов потребуется для достижения всех поглощающих состояний. Простейшим способом для этого будет запуск симуляций. В каждой симуляции мы будем генерировать одну траекторию по цепи, начав с начального состояния, затем выбирая последующее состояние случайным образом, пропорционально переходным вероятностям, а затем повторяя процесс из этого состояния. После выполнения одного миллиона симуляций для количества ходов до победы выявляется следующее распределение:  
  

![Distribution of the number of moves to win, with the mean of 938.8 highlighted](https://habrastorage.org/getpro/habr/post_images/747/0f4/382/7470f438276be9104ce24066a4b969c5.svg)

  
  
Среднее, помеченное вертикальной синей линией, оказывается равным **938,8 ходам**, исключая первый переход из начального состояния, со стандартным отклонением в **8,3 ходов**. Итак, вот наш ответ на вопрос о минимальном ожидаемом количестве ходов до победы в игре!  
  
Теория цепей Маркова также позволяет нам вычислить некоторые из этих свойств напрямую, с помощью хитрой математики. В [Приложении А](https://habr.com/ru/articles/339342/#appendix-a-analysis-of-the-markov-chain) я покажу, как вычислить среднее число и стандартное отклонение для количества ходов, не используя симуляцию. Затем в [Приложении Б](https://habr.com/ru/articles/339342/#appendix-b-the-shape-of-the-distribution) я воспользуюсь некоторыми из свойств цепи, чтобы предложить хотя бы частичное объяснение формы кривой распределения.  
  

## Проверяем теорию практикой

  
Наконец, чтобы проверить эти результаты в реальной жизни, я много раз сыграл в 2048 (ради науки!) и в 28 выигранных играх я записал количество ходов, а также сумму тайлов на поле, когда я достиг тайла 2048 [4](https://habr.com/ru/articles/339342/#fn_changes):  
  

![Montage of 28 winning games of 2048](https://habrastorage.org/r/w1560/getpro/habr/post_images/dfd/c6b/a2f/dfdc6ba2f1b56401068f656aeb42f65f.png)

  
  
Выписав эти числа в электронную таблицу и построив по ним график, я получил следующую диаграмму разброса:  
  

![Moves to Win and Tiles on Board for the 28 games I won](https://habrastorage.org/getpro/habr/post_images/261/94a/e24/26194ae2415b7771fa2b7c09533015db.svg)

  
  
Я пометил синим минимальное ожидаемое количество ходов, плюс-минус одно стандартное отклонение, и красным сумму тайлов 2066, которая, как мы выяснили, является минимальной суммой тайлов, возможной при наличии тайла 2048.  
  
Сумма тайлов на поле важна, потому что если она велика, то это обычно значит, что я совершил ошибку и загнал куда-то большой тайл, откуда не смогу объединить его с другим тайлом. Потом потребовалось гораздо больше ходов для повторного наращивания этого тайла на месте, откуда его можно объединить (или для изменения конфигурации поля для передвижения его в нужное место для объединения) с другим большим тайлом.  
  
Если бы я хорошо играл в 2048, мы могли бы предсказать, что мои результаты сгруппируются в нижнем левом углу графика, и что большинство из них будут лежать между пунктирными синими линиями. На самом деле, как мы видим, хоть иногда я и подбираюсь к идеалу, результат не слишком стабилен — довольно много точек в верхнем правом углу с кучей лишних ходов и тайлов.  
  
Этот график также подчёркивает тот факт, что наш анализ даёт нам только минимальное _ожидаемое_ количество ходов. Было несколько игр, в которых мне везло и я выигрывал менее чем за 938,8 ходов, в том числе была победа с 927 ходами и суммой тайлов 2076. (Это второй слева результат в нижнем ряду подборки.) Так получилось потому, что в той игре мне случайно выпадало много тайлов `4`, а ещё потому, что я не совершал серьёзных ошибок, требовавших лишних ходов.  
  
В принципе, есть ненулевая вероятность того, что мы можем выиграть игру всего за 519 ходов. Мы можем определить это, пройдя по цепи, всегда выбирая переход в сторону `4` и считая количество переходов, необходимых для достижения тайла 2048. Однако вероятность такого исхода равна ![$0,1^{521}$](https://habrastorage.org/getpro/habr/formulas/c58/459/323/c58459323a2b9d8dffe1831d3a39a2f7.svg), или ![$10^{-521}$](https://habrastorage.org/getpro/habr/formulas/e2f/6b5/4d6/e2f6b54d6346e84ed841b117ce5d19b2.svg). В наблюдаемой нами Вселенной всего примерно ![$10^{80}$](https://habrastorage.org/getpro/habr/formulas/337/74c/444/33774c444eeaec2c22de24465f727c19.svg) атомов, так что не стоит, затаив дыхание, ждать, что такая игра выпадет именно вам. Также, если нам очень не повезёт и мы всегда будем получать тайлы `2`, мы всё равно сможем выиграть всего за 1032 ходов. Такая игра гораздо более вероятна, её вероятность равна ![$0,9^{1034}$](https://habrastorage.org/getpro/habr/formulas/736/5da/d6a/7365dad6ae32b50b6a3f157f60f6ce8b.svg), что равно примерно равно ![$10^{-48}$](https://habrastorage.org/getpro/habr/formulas/ee4/bc5/cc6/ee4bc5cc615b0ef8015c4ab052ffffe8.svg), так что, скорее всего, и такой игры не стоит ждать, затаив дыхание. Среднее в 938,8 ходов гораздо ближе к 1032, чем 519, потому что вероятность появления тайлов `2` гораздо выше, чем у тайлов `4`.  
  

## Заключение

  
В этой части мы рассмотрели способ создания цепи Маркова, моделирующей эволюцию игры 2048 в случае, когда всегда возможно объединение одинаковых тайлов. Благодаря этому мы смогли применить техники теории поглощающих цепей Маркова для вычисления интересных свойств игры, и, в частности, выяснили, что в среднем для победы требуется не менее 938,8 ходов.  
  
Основное упрощение, позволившее нам использовать этот подход, заключается в игнорировании структуры поля. То есть мы предположили, что бросаем тайлы в мешок, а не размещаем их на поле. Во второй части я планирую рассмотреть случай, когда мы учитываем структуру поля. Мы узнаем, что количество состояний, которое нужно рассмотреть, становится на много порядков больше (хотя, возможно, и не настолько больше, как можно подумать), и поймём, что нам придётся покинуть мир цепей Маркова, перейдя в мир марковских процессов принятия решений, что позволит нам вернуть в уравнения игрока. В принципе, мы сможем полностью «решить» игру, то есть, найти, возможно, оптимальный способ игры.  
  

## Приложение А: анализ цепи Маркова

  
После задания цепи Маркова, мы можем привлечь мощь математики для выполнения расчётов её свойств без симуляции. Многие из этих вычислений возможны только потому, что наша цепь Маркова принадлежит к особому виду цепей Маркова, называемому [поглощающей цепью Маркова](https://en.wikipedia.org/wiki/Absorbing_Markov_chain).  
  
Чтобы относиться к поглощающим цепям, цепь Маркова должна соответствовать следующим критериям:  
  

1. В ней должно быть хотя бы одно поглощающее состояние. Как мы видели выше, в нашей цепи существует 26 поглощающих состояний, по одному на каждое выигрышное состояние с тайлом `2048`.
2. Любое состояние может достичь поглощающего состояния за конечное число переходов. Один из способов определить это — убедиться, что в цепи нет других циклов, кроме чем для поглощающих состояний: за исключением поглощающих состояний цепь является направленным ациклическим графом.

  

### Переходная матрица

  
Теперь, когда мы определили, что имеем поглощающую цепь Маркова, следующим шагом будет написание её _переходной матрицы_ в _каноническом виде_. Переходная матрица — это матрица, упорядочивающая переходные вероятности, которые для нашей цепи мы определили выше, такая, что элемент ![$(i, j)$](https://habrastorage.org/getpro/habr/formulas/aa1/84d/68d/aa184d68d45155402576665ad494ecc3.svg) является вероятностью перехода из состояния ![$i$](https://habrastorage.org/getpro/habr/formulas/bf8/3b5/32c/bf83b532cd867d34004f8eded8c5c79a.svg) в состояние ![$j$](https://habrastorage.org/getpro/habr/formulas/b82/8e2/475/b828e2475a3a56280b895f35eb250ea2.svg).  
  
Чтобы переходная матрица ![$\mathbf{P}$](https://habrastorage.org/getpro/habr/formulas/744/bc8/ccb/744bc8ccbf37dc324269c19062ca2160.svg) поглощающей цепи с ![$r$](https://habrastorage.org/getpro/habr/formulas/066/939/a33/066939a33475dd671b845469b6526972.svg) поглощающих состояний и ![$t$](https://habrastorage.org/getpro/habr/formulas/9b0/012/4e4/9b00124e411362185d05b841bc32695f.svg) _невозвратных_ (то есть непоглощающих) состояний могла быть в каноническом виде, должна иметься возможность разбить её на четыре меньших матрицы ![$\mathbf{Q}$](https://habrastorage.org/getpro/habr/formulas/c1a/9dd/790/c1a9dd790e1ec37aa7696c0b49139a88.svg), ![$\mathbf{R}$](https://habrastorage.org/getpro/habr/formulas/772/0ad/024/7720ad024dae1c0b40a457efed805895.svg), ![$\mathbf{0}$](https://habrastorage.org/getpro/habr/formulas/22d/721/490/22d721490f88eae369ca0ce370455d73.svg) и ![$\mathbf{I}$](https://habrastorage.org/getpro/habr/formulas/04a/395/a2b/04a395a2b596b26b39ed9569561f7546.svg), таких, что:  
  

![$\mathbf{P} = \left( \begin{array}{cc} \mathbf{Q} & \mathbf{R} \\\
\mathbf{0} & \mathbf{I}_r \end{array} \right)$](https://habrastorage.org/getpro/habr/formulas/965/3fd/4ff/9653fd4ffc5d260836f5b789cfbfb775.svg)

  
где ![$\mathbf{Q}$](https://habrastorage.org/getpro/habr/formulas/c1a/9dd/790/c1a9dd790e1ec37aa7696c0b49139a88.svg) — это матрица ![$t \times t$](https://habrastorage.org/getpro/habr/formulas/4ab/225/2d2/4ab2252d2f00a3d28e2f5ee93f07bc42.svg), описывающая вероятность перехода из одного невозвратного состояния в другое невозвратное состояние, ![$\mathbf{R}$](https://habrastorage.org/getpro/habr/formulas/772/0ad/024/7720ad024dae1c0b40a457efed805895.svg) — это матрица ![$t \times r$](https://habrastorage.org/getpro/habr/formulas/da1/f35/b35/da1f35b3523916cf70c8db7ca1b673d9.svg), описывающая вероятность перехода из невозвратного состояния в поглощающее состояние, ![$\mathbf{0}$](https://habrastorage.org/getpro/habr/formulas/22d/721/490/22d721490f88eae369ca0ce370455d73.svg) обозначает матрицу ![$r \times t$](https://habrastorage.org/getpro/habr/formulas/7a9/bc6/e1d/7a9bc6e1d33128e6fa786f07c8e81f53.svg) нулей, а ![$\mathbf{I}_r$](https://habrastorage.org/getpro/habr/formulas/7c0/0fe/11f/7c00fe11f0c7f12fc7098e956db79c6b.svg) — это переходная матрица для поглощающих состояний, являющаяся единичной матрицей ![$r \times r$](https://habrastorage.org/getpro/habr/formulas/319/8f6/ad8/3198f6ad8d97d63363cf5c402edfc30d.svg).  
  
Чтобы преобразовать переходную матрицу нашей цепи в канонический вид, нам нужно определиться с порядком состояний. Достаточно будет упорядочить состояния (1) по тому, являются ли они поглощающими (поглощающие состояния идут последними), затем (2) по сумме их тайлов (по возрастанию) и, наконец, (3) в лексическом порядке, чтобы избавиться от зависимостей. Если мы сделаем это, то получим следующую матрицу:  
  

![The full transition matrix for the absorbing Markov chain](https://habrastorage.org/getpro/habr/post_images/1e5/a38/667/1e5a38667a67dbc8688a7ddb66e6148b.svg)

  
  
Она довольно большая, а именно, размером ![$3487 \times 3487$](https://habrastorage.org/getpro/habr/formulas/897/1b8/8de/8971b88dee81bc9b286f4cd00264d111.svg), поэтому при уменьшении масштаба выглядит почти диагональной, но если мы приблизим правый нижний угол, то увидим, что у неё есть структура, и, в частности, есть канонический вид, к которому мы стремимся:  
  

![The lower right hand corner of the transition matrix for the absorbing Markov chain, which shows more structure](https://habrastorage.org/getpro/habr/post_images/bd8/0f2/cf3/bd80f2cf309c275a9a50c6ff7df1ac14.svg)

  
  

### Фундаментальная матрица

  
Получив канонический вид переходной матрицы, дальше мы используем её для нахождения того, что называется _фундаментальной матрицей_ цепи. Она позволить нам вычислить ожидаемое количество переходов до поглощения, то есть мы (наконец-то!) найдём ответ на наш исходный вопрос.  
  
Фундаментальная матрица ![$\mathbf{N}$](https://habrastorage.org/getpro/habr/formulas/ec5/7ed/586/ec57ed5861ed47e3fbb7ac078e4d8a93.svg) задаётся относительно ![$\mathbf{Q}$](https://habrastorage.org/getpro/habr/formulas/c1a/9dd/790/c1a9dd790e1ec37aa7696c0b49139a88.svg) тождественным равенством  
  

![$\mathbf{N} = \sum_{k=0}^{\infty} \mathbf{Q}^k\mathbf{N} = \sum_{k=0}^{\infty} \mathbf{Q}^k$](https://habrastorage.org/getpro/habr/formulas/a8e/d8e/416/a8ed8e416c0ae4825cc0c7b2b5f9edf2.svg)

  
где ![$\mathbf{Q}^k$](https://habrastorage.org/getpro/habr/formulas/ae6/23a/362/ae623a362cf6ab27ace223a0e19d258f.svg) обозначает ![$k$](https://habrastorage.org/getpro/habr/formulas/16d/a50/7b2/16da507b2fc389688ef0659939dcc647.svg)-тую степень матрицы ![$\mathbf{Q}$](https://habrastorage.org/getpro/habr/formulas/c1a/9dd/790/c1a9dd790e1ec37aa7696c0b49139a88.svg).  
  
Элемент ![$(i, j)$](https://habrastorage.org/getpro/habr/formulas/aa1/84d/68d/aa184d68d45155402576665ad494ecc3.svg) ![$\mathbf{N}$](https://habrastorage.org/getpro/habr/formulas/ec5/7ed/586/ec57ed5861ed47e3fbb7ac078e4d8a93.svg) имеет определённую интерпретацию: это ожидаемое число раз, которое мы войдём в состояние ![$j$](https://habrastorage.org/getpro/habr/formulas/b82/8e2/475/b828e2475a3a56280b895f35eb250ea2.svg), если будем следовать по цепи, начиная с состояния ![$i$](https://habrastorage.org/getpro/habr/formulas/bf8/3b5/32c/bf83b532cd867d34004f8eded8c5c79a.svg). Чтобы увидеть это, мы можем заметить, что как элемент ![$(i, j)$](https://habrastorage.org/getpro/habr/formulas/aa1/84d/68d/aa184d68d45155402576665ad494ecc3.svg) матрицы ![$\mathbf{Q}$](https://habrastorage.org/getpro/habr/formulas/c1a/9dd/790/c1a9dd790e1ec37aa7696c0b49139a88.svg) является вероятностью перехода из состояния ![$i$](https://habrastorage.org/getpro/habr/formulas/bf8/3b5/32c/bf83b532cd867d34004f8eded8c5c79a.svg) в состояние ![$j$](https://habrastorage.org/getpro/habr/formulas/b82/8e2/475/b828e2475a3a56280b895f35eb250ea2.svg) за один переход, так и элемент ![$(i, j)$](https://habrastorage.org/getpro/habr/formulas/aa1/84d/68d/aa184d68d45155402576665ad494ecc3.svg) матрицы ![$\mathbf{Q}^k$](https://habrastorage.org/getpro/habr/formulas/ae6/23a/362/ae623a362cf6ab27ace223a0e19d258f.svg) является вероятностью входа в состояние ![$j$](https://habrastorage.org/getpro/habr/formulas/b82/8e2/475/b828e2475a3a56280b895f35eb250ea2.svg) ровно за ![$k$](https://habrastorage.org/getpro/habr/formulas/16d/a50/7b2/16da507b2fc389688ef0659939dcc647.svg) переходов после входа в состояние ![$i$](https://habrastorage.org/getpro/habr/formulas/bf8/3b5/32c/bf83b532cd867d34004f8eded8c5c79a.svg). Если для заданной пары состояний ![$i$](https://habrastorage.org/getpro/habr/formulas/bf8/3b5/32c/bf83b532cd867d34004f8eded8c5c79a.svg) и ![$j$](https://habrastorage.org/getpro/habr/formulas/b82/8e2/475/b828e2475a3a56280b895f35eb250ea2.svg) мы суммируем упомянутые вероятности для всех ![$k \geq 0$](https://habrastorage.org/getpro/habr/formulas/414/1ba/d52/4141bad5251f0a814eb73432054c19d3.svg), то сумма будет включать в себя каждый раз, когда мы имеет возможность войти в состояние ![$j$](https://habrastorage.org/getpro/habr/formulas/b82/8e2/475/b828e2475a3a56280b895f35eb250ea2.svg) после состояния ![$i$](https://habrastorage.org/getpro/habr/formulas/bf8/3b5/32c/bf83b532cd867d34004f8eded8c5c79a.svg), взвешенный по соответствующей вероятности, что и даёт нам нужное ожидание.  
  
К счастью, фундаментальную матрицу можно вычислить напрямую, без неприятного бесконечного суммирования, как обратную матрицу ![$\mathbf{I}_t - \mathbf{Q}$](https://habrastorage.org/getpro/habr/formulas/190/c54/ddf/190c54ddfb8526ccd1b17d7fbab139d0.svg), где ![$\mathbf{I}_t$](https://habrastorage.org/getpro/habr/formulas/317/3e5/b12/3173e5b120f2d8dbf77b6c33708794c0.svg) — это единичная матрица ![$t \times t$](https://habrastorage.org/getpro/habr/formulas/4ab/225/2d2/4ab2252d2f00a3d28e2f5ee93f07bc42.svg). То есть, ![$\mathbf{N} = (\mathbf{I}_t - \mathbf{Q})^{-1}$](https://habrastorage.org/getpro/habr/formulas/2f4/b97/a9d/2f4b97a9d80c693ff4410b4a0b4d98f5.svg). (Доказательство этого будет домашним заданием для читателя!)  
  

### Ожидаемое число ходов до победы

  
Получив фундаментальную матрицу, мы можем найти ожидаемое число переходов из любого состояния ![$i$](https://habrastorage.org/getpro/habr/formulas/bf8/3b5/32c/bf83b532cd867d34004f8eded8c5c79a.svg) к поглощающему состоянию с помощью суммирования всех элементов в ряду ![$i$](https://habrastorage.org/getpro/habr/formulas/bf8/3b5/32c/bf83b532cd867d34004f8eded8c5c79a.svg) — иными словами, количество переходов до попадания в поглощающее состояние равно общему числу переходов, которое нам пришлось совершить во всех невозвратных состояниях по пути.  
  
Мы можем получить эти суммы рядов сразу для всех состояний, вычислив произведение матрицы на вектор ![$\mathbf{N} \mathbf{1}$](https://habrastorage.org/getpro/habr/formulas/8e4/816/cc9/8e4816cc9b78dd70c8d911a06917c1e5.svg), где ![$\mathbf{1}$](https://habrastorage.org/getpro/habr/formulas/2cc/094/be1/2cc094be1a835907cfd2d31b930ae185.svg) обозначает вектор-столбец ![$t$](https://habrastorage.org/getpro/habr/formulas/9b0/012/4e4/9b00124e411362185d05b841bc32695f.svg). Поскольку ![$\mathbf{N} = (\mathbf{I}_t - \mathbf{Q})^{-1}$](https://habrastorage.org/getpro/habr/formulas/2f4/b97/a9d/2f4b97a9d80c693ff4410b4a0b4d98f5.svg), мы можем сделать это, решив линейную систему уравнений  
  

![$(\mathbf{I}_t - \mathbf{Q})\mathbf{t} = \mathbf{1}$](https://habrastorage.org/getpro/habr/formulas/716/5ef/93f/7165ef93fa20f1cc11cae5ee3ffebddb.svg)

  
для ![$\mathbf{t}$](https://habrastorage.org/getpro/habr/formulas/c60/e66/15f/c60e6615f7e2c0dd3a5247dd87774077.svg). Элемент в ![$\mathbf{t}$](https://habrastorage.org/getpro/habr/formulas/c60/e66/15f/c60e6615f7e2c0dd3a5247dd87774077.svg), соответствующий начальному состоянию (пустому множеству ![$\left \{ \right \}$](https://habrastorage.org/getpro/habr/formulas/2ca/f61/8d6/2caf618d6f55ee9ba6b0a80abd697dc7.svg)), является числом переходов. В этом случае, получаемое число равно 939,8. Для завершения нам нужно только вычесть ![$1$](https://habrastorage.org/getpro/habr/formulas/3e4/c77/a6e/3e4c77a6e7c579a778fa84a18b6f4be0.svg), потому что переход из начального состояния не считается ходом. Это даёт нам конечный ответ — **938,8 ходов**.  
  
Также мы можем получить дисперсию для минимального числа ходов как  
  

![$2(\mathbf{N} - \mathbf{I}_t) \mathbf{t} - \mathbf{t} \circ \mathbf{t}$](https://habrastorage.org/getpro/habr/formulas/252/5ce/3c3/2525ce3c33f08650671cb9ba9e81d21c.svg)

  
где ![$\circ$](https://habrastorage.org/getpro/habr/formulas/16a/b4b/de6/16ab4bde6ea7ff5e5a45131f5ef78ad3.svg) обозначает [(покомпонентное) произведение Адамара](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%90%D0%B4%D0%B0%D0%BC%D0%B0%D1%80%D0%B0). Для начального состояния получаем дисперсию 69,5, что даёт нам стандартное отклонение в **8,3 шагов**.  
  

## Приложение Б: форма кривой распределения

  
Примечательно, что нам удалось вычислить и среднее, и дисперсию распределения ходов до победы из цепи Маркова с помощью фундаментальной матрицы. Однако неплохо было бы узнать, почему распределение получилось такой формы. Предлагаемый здесь мной подход является только приблизительным. но он достаточно близко соответствует эмпирическим результатам из симуляции и даёт нам кое-какую полезную информацию.  
  
Мы начнём с возврата к сделанному ранее наблюдению: сумма тайлов на поле увеличивается с каждым переходом на 2 или на 4 (кроме первого перехода из начального состояния). Как мы увидим ниже, если мы были бы заинтересованы в получении конкретной суммы на поле, а не получении тайла `2048`, то было бы довольно просто вычислить нужное количество переходов с помощью биномиального распределения.  
  
Итак, следующий вопрос будет заключаться в том, какую сумму мы хотим получить. Из приведённого выше анализа цепи Маркова мы определили, что существует 26 поглощающих (выигрышных) состояний. Мы также увидели, что они находятся на разных «слоях сумм», то есть нет одной суммы, к которой мы стремимся, их несколько. Нам нужно знать, какова вероятность для каждого состояния стать поглощённым. Она называется _вероятностью поглощения_. Затем мы можем суммировать вероятности поглощения для каждого из поглощающих состояний в отдельном слое сумм, чтобы найти вероятность выигрыша с конкретной получившейся суммой.  
  

### Вероятности поглощения

  
К счастью, вероятности поглощения тоже можно найти из фундаментальной матрицы. В частности, мы можем получить их, решив линейные уравнения  
  

![$(\mathbf{I}_t - \mathbf{Q}) \mathbf{B} = \mathbf{R}$](https://habrastorage.org/getpro/habr/formulas/95e/157/f89/95e157f89b43a81720b8b1fd714b2f63.svg)

  
для матрицы ![$\mathbf{B}$](https://habrastorage.org/getpro/habr/formulas/9dc/b2b/28d/9dcb2b28d161ecd994b9ed5a31d765c8.svg) размером ![$t \times r$](https://habrastorage.org/getpro/habr/formulas/da1/f35/b35/da1f35b3523916cf70c8db7ca1b673d9.svg), чей элемент ![$(i, j)$](https://habrastorage.org/getpro/habr/formulas/aa1/84d/68d/aa184d68d45155402576665ad494ecc3.svg) — это вероятность поглощения в состоянии ![$j$](https://habrastorage.org/getpro/habr/formulas/b82/8e2/475/b828e2475a3a56280b895f35eb250ea2.svg), начиная со состояния ![$i$](https://habrastorage.org/getpro/habr/formulas/bf8/3b5/32c/bf83b532cd867d34004f8eded8c5c79a.svg). Как и раньше, нас интересуют вероятности поглощения, при начале из начального состояния. Построив график вероятности поглощения, мы увидим, что существует 15 поглощающих состояний, вероятности которых достаточно велики для отображения на графике (не менее ![$10^{-3}$](https://habrastorage.org/getpro/habr/formulas/e79/e94/c40/e79e94c40215d6a1cfead0c3f1b94818.svg)):  
  

![Absorbing probabilities for the Markov chain](https://habrastorage.org/getpro/habr/post_images/254/818/829/254818829d58847bf96985b131be0d0c.svg)

  
  
В частности, большинство игр завершается или состоянием ![$\left \{ 2,2,8,8,2048 \right \}$](https://habrastorage.org/getpro/habr/formulas/4b0/f57/4d3/4b0f574d3df14c3021f13d2850ebc54e.svg), сумма которого равна 2068, или состоянием ![$\left \{2,4,16,2048\right \}$](https://habrastorage.org/getpro/habr/formulas/421/943/530/421943530db05b76d6c86e83bd94b373.svg), сумма которого 2070. Суммируя все поглощающие состояния по сумме слоёв, мы получаем полные вероятности суммы слоя:  
  

![Total absorbing probabilities by sum of tiles](https://habrastorage.org/getpro/habr/post_images/6b1/a89/3ed/6b1a893edfb8afa58b06fbb966849643.svg)

  
  

### Биномиальные вероятности

  
Теперь, когда у нас есть суммы, на которые можно нацелиться, и мы знаем насколько часто мы нацеливаемся на каждую, следующим будет такой вопрос: сколько ходов нужно сделать, чтобы получить конкретную сумму? Как замечено выше, мы можем воспринимать этот вопрос применительно к [биномиальному распределению](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%BD%D0%BE%D0%BC%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5), которое позволяет нам вычислить вероятность заданного количества «успехов» из заданного количества «попыток».  
  
В этом случае под «попыткой» мы будем подразумевать ход, а под «успехом» — ход, в котором игра даёт нам тайл `4`; как показано выше, это происходит с вероятностью 0,1. «Неудачей» здесь является ход, в котором игра даёт нам тайл `2`, что происходит с вероятностью 0,9.  
  
С учётом такой интерпретации успехов, для того, чтобы получить заданную сумму ![$S$](https://habrastorage.org/getpro/habr/formulas/cb6/d45/cf9/cb6d45cf916546ae1085088c0c5dcd09.svg) за ![$M$](https://habrastorage.org/getpro/habr/formulas/94d/13e/e0a/94d13ee0aadd7f17977e0d279af38d42.svg) ходов, нам потребуется ![$\frac{S}{2} - M$](https://habrastorage.org/getpro/habr/formulas/039/d58/408/039d58408d781174fac5fcc4149f7506.svg) успехов из ![$M$](https://habrastorage.org/getpro/habr/formulas/94d/13e/e0a/94d13ee0aadd7f17977e0d279af38d42.svg) ходов. Так получается, потому что каждый ход прибавляет к сумме как минимум ![$2$](https://habrastorage.org/getpro/habr/formulas/dfd/8a0/d2f/dfd8a0d2fe6ea30b4cde7f570eca349b.svg), что в целом даёт ![$2M$](https://habrastorage.org/getpro/habr/formulas/477/cdd/820/477cdd820eb29b06a191fafdce6b5af0.svg), а каждый успех добавляет к сумме дополнительные ![$2$](https://habrastorage.org/getpro/habr/formulas/dfd/8a0/d2f/dfd8a0d2fe6ea30b4cde7f570eca349b.svg), внося в общем ![$2 \left(\frac{S}{2} - M\right) = S - 2M$](https://habrastorage.org/getpro/habr/formulas/eae/191/831/eae191831da48774a41e9981a99a74da.svg). Складывая эти значения, мы получим нужную сумму ![$S$](https://habrastorage.org/getpro/habr/formulas/cb6/d45/cf9/cb6d45cf916546ae1085088c0c5dcd09.svg).  
  
Тогда совместная вероятность получения суммы ![$S$](https://habrastorage.org/getpro/habr/formulas/cb6/d45/cf9/cb6d45cf916546ae1085088c0c5dcd09.svg) за количество ходов ![$M$](https://habrastorage.org/getpro/habr/formulas/94d/13e/e0a/94d13ee0aadd7f17977e0d279af38d42.svg) является биномиальной, и в частности  
  

![$\mathrm{Pr}(M=m, S=s) = B\left(\frac{s}{2} - m; m, 0.1\right)$](https://habrastorage.org/getpro/habr/formulas/1a2/cdb/955/1a2cdb9556cef15a9073145f5c7cf5ef.svg)

  
где ![$B(k; n, p)$](https://habrastorage.org/getpro/habr/formulas/883/499/f06/883499f06539d4bad4a178cbd989a2a9.svg) — это функция распределения масс для биномиального распределения, которая даёт нам вероятность получения ровно ![$k$](https://habrastorage.org/getpro/habr/formulas/16d/a50/7b2/16da507b2fc389688ef0659939dcc647.svg) успехов за ![$n$](https://habrastorage.org/getpro/habr/formulas/08d/9fa/efb/08d9faefbe272bdf8fbb80773542e343.svg) попыток, где вероятность успеха равна ![$p$](https://habrastorage.org/getpro/habr/formulas/839/f25/c27/839f25c2746382debd4f08ea25ad5ecf.svg), т.е.  
  

![$B(k; n, p) = {n\choose k}p^k(1-p)^{n-k}$](https://habrastorage.org/getpro/habr/formulas/e66/658/151/e666581517c17ef5f6c016376f68d5ac.svg)

  
где ![$n \choose k$](https://habrastorage.org/getpro/habr/formulas/235/a40/5ec/235a405ec1be087349a0d0367f95ec6e.svg) обозначает [биномиальный коэффициент](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%BD%D0%BE%D0%BC%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D1%8D%D1%84%D1%84%D0%B8%D1%86%D0%B8%D0%B5%D0%BD%D1%82).  
  
Теперь, когда мы знаем целевую сумму ![$S$](https://habrastorage.org/getpro/habr/formulas/cb6/d45/cf9/cb6d45cf916546ae1085088c0c5dcd09.svg), к которой стремимся, мы можем вычислить условное распределение ходов с учётом того, что сумма, которая нас интересует — из совместного распределения. То есть мы можем найти ![$\mathrm{Pr}(M | S)$](https://habrastorage.org/getpro/habr/formulas/47a/0e0/5c9/47a0e05c9bcced1127780d4a5aa08020.svg) как  
  

![$\mathrm{Pr}(M | S) = \frac{\mathrm{Pr}(M, S)}{\mathrm{Pr}(S)}$](https://habrastorage.org/getpro/habr/formulas/007/972/9b3/0079729b3c117d573ca391773a036248.svg)

  
где ![$\mathrm{Pr}(S)$](https://habrastorage.org/getpro/habr/formulas/4e7/776/c11/4e7776c11aa73a3faaff22f58cf47e4b.svg) получается из совместного распределения суммированием ![$M$](https://habrastorage.org/getpro/habr/formulas/94d/13e/e0a/94d13ee0aadd7f17977e0d279af38d42.svg) для каждой возможной суммы ![$S$](https://habrastorage.org/getpro/habr/formulas/cb6/d45/cf9/cb6d45cf916546ae1085088c0c5dcd09.svg). Стоит заметить, что ![$\mathrm{P}(S)$](https://habrastorage.org/getpro/habr/formulas/3f2/cd3/8ef/3f2cd38ef6c282d817d0e337bfe40bfd.svg) меньше единицы для каждой возможной суммы, потому что всегда существует вероятность того, что игра «перескочит» сумму, выдав нам тайл `4`.  
  
Получив все эти условные распределения для каждой целевой суммы, мы можем сложить их, взвешенные по общей вероятности поглощения для целевой суммы, чтобы получить общую вероятность. Это даёт нам довольно точное совпадение с распределением из симуляции:  
  

![Simulated and binomial mixture model distributions for minimum moves to win](https://habrastorage.org/getpro/habr/post_images/cab/324/20c/cab32420c4f9373ad775d28125ebbca7.svg)

  
  
Здесь симулированное распределение показано серыми столбцами, а цветными областями показаны каждое из условных распределений. Каждое условное распределение отмасштабировано согласно общей вероятности поглощения для его суммы, а также смещено на несколько ходов, потому что бо́льшие суммы в среднем требуют больше ходов.  
  
Одна из интерпретаций этого результата: при оптимальной игре количество ходов до выигрыша сильно зависит от того, насколько быстро игрок сможет получить сумму достаточно большую, чтобы содержать тайл 2048, что, в свою очередь зависит от числа тайлов `4`, следующего биномиальному распределению.  
  

---

  
Благодарю [Хоуп Томас](https://twitter.com/h0peth0mas) и [Нейта Стемена](https://natestemen.github.io/) за правку черновиков этой статьи.  
  

## Примечания

  

1. Если мы позволим игроку принимать решения, то нужно использовать [марковский процесс принятия решений](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D0%BA%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81_%D0%BF%D1%80%D0%B8%D0%BD%D1%8F%D1%82%D0%B8%D1%8F_%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B9), а не цепь Маркова. Это будет темой следующей части.
2. Такое объединение пар одинаковых тайлов ухватывает важный нюанс логики объединения в реальной игре: например, если у вас есть четыре тайла `2` в ряд, и вы сдвинете их, чтобы объединить, в результате получится два тайла `4`, а не один тайл `8`. То есть нельзя объединять только что объединённые тайлы одним смещением
3. Эти схемы получены с помощью отличного инструмента `dot` из [graphviz](http://www.graphviz.org/). Если вы не подскажете `dot` группировать состояния в слои по сумме, то создание полного графа займёт довольно большое время.
4. Внешний вид экрана «You win!» за месяцы сбора этих данных менялся несколько раз. Для протокола: все эти месяцы я не только играл в 2048.

  

# Часть 2. Подсчёт состояний с помощью комбинаторики

  

![Screenshot of 2048 with an infeasible board configuration](https://habrastorage.org/r/w1560/getpro/habr/post_images/434/d62/830/434d62830d34c7da9ce255074849da1e.png)

  
В предыдущей части я выяснил, что для победы в игре [2048](http://gabrielecirulli.github.io/2048) в среднем потребуется не менее 938,8 ходов. Основным упрощением, позволившим выполнить эти вычисления, было то, что мы игнорировали структуру поля — в сущности, мы бросали тайлы в мешок, а не размещали их на поле. Благодаря этому «мешочному» упрощению мы смогли смоделировать игру в виде цепи Маркова со всего лишь 3486 состояниями.  
  
В этой части мы сделаем первую попытку подсчёта количества состояний без упрощения с «мешком». То есть, в этой части _состояние_ будет содержать полную конфигурацию поля, определяя присутствующие в каждой клетке поля тайлы. Поэтому стоит ожидать, что состояний такого типа будет гораздо больше, потому что в них включены положения тайлов (и клеток без тайлов). Как мы убедимся, именно так и есть.  
  
Для этого мы воспользуемся (простыми) техниками из перечислительной комбинаторики, чтобы исключить некоторые состояния, которые можно записать, но которые не могут возникнуть в игре, например, как приведённое выше. Результаты также будут применимы к всем играм, похожим на 2048, даже к играемым на других полях (а не только 4x4) и до других тайлов (не только до `2048`). Мы увидим, что такие игры на меньших полях и/или до тайлов меньшего значения имеют гораздо меньше состояний, чем полная игра 4x4 в 2048, и что использованные здесь техники относительно гораздо более эффективны в снижении ожидаемого количества состоянии при маленьком размере поля. В качестве бонуса мы также увидим, что поле 4x4 является наименьшим квадратным полем, на котором возможно достичь тайла `2048`.  
  
Код (исследовательского качества), на котором основана эта часть, имеет [открытые исходники](https://github.com/jdleesmiller/twenty48), на случай, если вы захотите оценить [реализацию](https://github.com/jdleesmiller/twenty48/blob/4337c357f2cc14bdc3e14ddaa5207ad2a6a972e6/bin/combinatorics) или [код для графиков](https://github.com/jdleesmiller/twenty48/tree/4337c357f2cc14bdc3e14ddaa5207ad2a6a972e6/data/combinatorics).  
  

# Базовая линия

  
Наиболее очевидный способ оценки количества состояний игры 2048 заключается в следующем наблюдении: существует 16 клеток, каждая клетка может быть пустой или содержать тайл, значение которого является одной из 11 степеней двойки, от 2 до 2048. Это даёт нам 12 возможных значений для каждой из 16 клеток, то есть всего ![$12^{16}$](https://habrastorage.org/getpro/habr/formulas/188/368/d61/188368d61bd771022b6a8a0274b12df4.svg), или 184 квадриллионов (примерно ![$10^{17}$](https://habrastorage.org/getpro/habr/formulas/9ac/09e/ed3/9ac09eed3e23b79eeb3549f5ff955211.svg)) возможных значений, которые можно записать таким образом. Для сравнения: [по некоторым оценкам](https://tromp.github.io/chess/chess.html), количество возможных конфигураций положений на шахматной доске примерно равно ![$10^{45}$](https://habrastorage.org/getpro/habr/formulas/5f8/3e9/aa1/5f83e9aa1a680aeab79928ab97f576bf.svg), а [по последним оценкам](https://en.wikipedia.org/wiki/Go_and_mathematics#Complexity_of_certain_Go_configurations), в игре го примерно ![$10^{170}$](https://habrastorage.org/getpro/habr/formulas/ed2/939/35f/ed293935f03274d6cc4d67c87a135f80.svg) состояний, поэтому хоть ![$10^{17}$](https://habrastorage.org/getpro/habr/formulas/9ac/09e/ed3/9ac09eed3e23b79eeb3549f5ff955211.svg) — это много, но это не рекорд для игр.  
  
В более общем виде подобные 2048 игры можно представить так: пусть ![$B$](https://habrastorage.org/getpro/habr/formulas/20d/8ca/ec6/20d8caec693d8d8eaf70885e408419f6.svg) — размер поля, а ![$K$](https://habrastorage.org/getpro/habr/formulas/8b1/9d8/49a/8b19d849a66473b36d68c78d06462129.svg) — степень выигрышного тайла со значением ![$2^K$](https://habrastorage.org/getpro/habr/formulas/1ec/f52/f1a/1ecf52f1a9d51370f6aec76f7125e3f4.svg). Для удобства пусть ![$C$](https://habrastorage.org/getpro/habr/formulas/47e/792/77d/47e79277dc17c254743475ff05980a53.svg) обозначает количество клеток на поле, то есть ![$C=B^2$](https://habrastorage.org/getpro/habr/formulas/f32/bbe/9dc/f32bbe9dc43c1e4929dea1f4e48f7e64.svg). Для обычной игры 2048 с полем 4x4: ![$B=4$](https://habrastorage.org/getpro/habr/formulas/6f0/4eb/17e/6f04eb17e083e262cd1ea15ebe9aac0a.svg), ![$C=16$](https://habrastorage.org/getpro/habr/formulas/fd1/c43/f51/fd1c43f51ac224240f3e72143b94bb41.svg), и ![$K = 11$](https://habrastorage.org/getpro/habr/formulas/d23/8a1/d0c/d238a1d0c08238b7ee16e9a4dd4763f6.svg), потому что ![$2^{11} = 2048$](https://habrastorage.org/getpro/habr/formulas/a88/7d8/687/a887d86878745bcf6a1d3116c6ac0c86.svg), а возможное количество состояний равно  
  

![$(K + 1)^C$](https://habrastorage.org/getpro/habr/formulas/fe8/c4e/2ae/fe8c4e2aef9bc6d085f8814a38d8ec00.svg)

  
Теперь давайте посмотрим, как мы можем уточнить возможное значение.  
  
Во-первых, поскольку игра завершается, когда мы получаем тайл ![$2^K$](https://habrastorage.org/getpro/habr/formulas/1ec/f52/f1a/1ecf52f1a9d51370f6aec76f7125e3f4.svg), то нас не волнует, где находится этот тайл и что на поле есть кроме него. Поэтому мы можем объединить все состояния с тайлом ![$2^K$](https://habrastorage.org/getpro/habr/formulas/1ec/f52/f1a/1ecf52f1a9d51370f6aec76f7125e3f4.svg) в одном специальное состояние «победы». В остальных состояниях каждая клетка может быть или пустой, или содержать один из тайлов ![$K - 1$](https://habrastorage.org/getpro/habr/formulas/2b5/1ce/379/2b51ce37948062b5d6d28ad1a883ffc3.svg). Это уменьшает количество состояний, которые нас интересуют, до  
  

![$K^C + 1$](https://habrastorage.org/getpro/habr/formulas/710/0e4/af2/7100e4af23a19a858f3e486cf31d6d2f.svg)

  
где ![$1$](https://habrastorage.org/getpro/habr/formulas/3e4/c77/a6e/3e4c77a6e7c579a778fa84a18b6f4be0.svg) — это состояние «победы».  
  
Во-вторых, мы можем заметить, что некоторые из этих состояний ![$K^C$](https://habrastorage.org/getpro/habr/formulas/5a1/879/353/5a18793535dcfff9553962c8e1ff41ef.svg) никогда не могут возникнуть в игре. В частности, правила игры подразумевают два полезных свойства:  
  
**Свойство 1:** на поле всегда есть как минимум два тайла.  
  
**Свойство 2:** на поле всегда есть как минимум один тайл `2` или тайл `4`.  
  
Первое свойство соблюдается, потому что даже если вы начнёте игру с двумя тайлами и объедините их, то всё равно останется один, после чего игра добавит один случайный тайл и их станет два. Второе свойство соблюдается, потому что игра всегда добавляет тайл `2` или тайл `4` после каждого хода.  
  
Таким образом, мы знаем, что в любом верном состоянии на поле должно быть как минимум два тайла, и один из них должен быть тайлом `2` или тайлом `4`. Чтобы учесть это, мы можем вычесть все состояния без тайла `2` или без тайла `4`, которых ![$(K-2)^C$](https://habrastorage.org/getpro/habr/formulas/bb9/ac0/887/bb9ac08878d284b2b48314a0470c190c.svg), а также состояния только с одним тайлом `2` и остальными пустыми клетками, которых ![$C$](https://habrastorage.org/getpro/habr/formulas/47e/792/77d/47e79277dc17c254743475ff05980a53.svg), а также состояния с только одним тайлом `4` и остальными пустыми клетками, которых тоже ![$C$](https://habrastorage.org/getpro/habr/formulas/47e/792/77d/47e79277dc17c254743475ff05980a53.svg). Это даёт нам возможное значение  
  

![$K^C - (K-2)^C - 2C + 1$](https://habrastorage.org/getpro/habr/formulas/fde/2b1/799/fde2b179993dd415f7721174caaf9ee9.svg)

  
состояний. Разумеется, когда ![$K$](https://habrastorage.org/getpro/habr/formulas/8b1/9d8/49a/8b19d849a66473b36d68c78d06462129.svg) или ![$C$](https://habrastorage.org/getpro/habr/formulas/47e/792/77d/47e79277dc17c254743475ff05980a53.svg) велико, это выглядит почти как ![$K^C$](https://habrastorage.org/getpro/habr/formulas/5a1/879/353/5a18793535dcfff9553962c8e1ff41ef.svg), то есть основной член, но для малых значений эта корректировка более значима.  
  
Давайте используем эту формулу для сведения возможного количества состояний для различного полей размера и максимальных тайлов:  
  

|Максимальный тайл|Размер поля|   |   |
|---|---|---|---|
||2x2|3x3|4x4|
|---|--:|--:|--:|
|8|73|19 665|43 046,689|
|16|233|261 615|4 294 901 729|
|32|537|1 933 425|152 544 843 873|
|64|1 033|9 815 535|2 816 814 940 129|
|128|1 769|38 400 465|33 080 342 678 945|
|256|2 793|124 140 015|278 653 866 803 169|
|512|4 153|347 066 865|1 819 787 258 282 209|
|1024|5 897|865 782 255|9 718 525 023 289 313|
|2048|8 073|1 970 527 185|44 096 709 674 720 289|

  
Сразу можно увидеть, что в играх с полями 2x2 и 3x3 на много порядков меньше состояний, чем в игре 4x4. Кроме того, нам удалось ограничить возможное количество тайлов в игре 4x4 до 2048 «всего лишь» 44 квадриллионами, или ~![$10^{16}$](https://habrastorage.org/getpro/habr/formulas/c72/e83/83b/c72e8383bf8ff80884c9416d9be12547.svg).  
  

# Подсчёт в слоях

  
Чтобы немного больше разобраться с этими количествами состояний, мы можем воспользоваться ещё одним важным свойством, которое пригодилось и в предыдущей части:  
  
**Свойство 3:** сумма тайлов на поле увеличивается с каждым ходом на 2 или на 4.  
  
Это правило соблюдается, потому что объединение двух тайлов не изменяет сумму тайлов на поле, и после него игра добавляет `2` или `4`.  
  
Свойство 3 подразумевает, что состояния в течение игры никогда не повторяются. Это значит, что мы можем упорядочить состояния в _слои_ по сумме их тайлов. Если игра находится в состоянии в слое с суммой 10, мы знаем, что следующее состояние будет в слое с суммой или 12, или 14. Получается, что мы также можем посчитать количество состояний в каждом слое.  
  
Пусть ![$S$](https://habrastorage.org/getpro/habr/formulas/cb6/d45/cf9/cb6d45cf916546ae1085088c0c5dcd09.svg) обозначает сумму тайлов на поле. Мы хотим посчитать количество способов, которыми ![$C$](https://habrastorage.org/getpro/habr/formulas/47e/792/77d/47e79277dc17c254743475ff05980a53.svg) чисел, каждое из которых является степенью двойки от 2 до ![$2^{K-1}$](https://habrastorage.org/getpro/habr/formulas/762/012/f99/762012f990d57f0537adbe2294648c31.svg), можно сложить, чтобы получить ![$S$](https://habrastorage.org/getpro/habr/formulas/cb6/d45/cf9/cb6d45cf916546ae1085088c0c5dcd09.svg).  
  
К счастью, это оказывается разновидностью хорошо изученной задачи комбинаторики: подсчёта [композиций целого числа](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F_%D1%87%D0%B8%D1%81%D0%BB%D0%B0). В общем случае композиция целого числа ![$S$](https://habrastorage.org/getpro/habr/formulas/cb6/d45/cf9/cb6d45cf916546ae1085088c0c5dcd09.svg) — это упорядоченная совокупность целых чисел, которые в сумме дают ![$S$](https://habrastorage.org/getpro/habr/formulas/cb6/d45/cf9/cb6d45cf916546ae1085088c0c5dcd09.svg); каждое целое число в совокупности называется _частью_. Например, у целого числа ![$3$](https://habrastorage.org/getpro/habr/formulas/3e3/28e/c65/3e328ec6538d48db0bbd8e0859e6d10a.svg) существует четыре композиции, а именно ![$1 + 1 + 1$](https://habrastorage.org/getpro/habr/formulas/f3e/38d/124/f3e38d12490748c55fadd3a82ace2fe4.svg), ![$1 + 2$](https://habrastorage.org/getpro/habr/formulas/e61/5b7/b9c/e615b7b9ca55e6952074f6240498a2c9.svg), ![$2 + 1$](https://habrastorage.org/getpro/habr/formulas/29f/15e/beb/29f15ebeb3f9c44c2da724e5a8046355.svg) и ![$3$](https://habrastorage.org/getpro/habr/formulas/3e3/28e/c65/3e328ec6538d48db0bbd8e0859e6d10a.svg). Когда для частей существуют ограничения, например, быть степенью двойки и наличие определённого количества частей, то такая композиция называется _ограниченной_.  
  
Ещё более удачно то, что Чинн и Нидерхаузен (2004 год) [1](https://habr.com/ru/articles/339342/#fn_Chinn) уже изучили именно такой тип ограниченной композиции и вывели рекурсию, которая позволит нам посчитать количество композиций, в которых есть определённое количество частей, при этом каждая часть будет являться степенью двойки. Пусть ![$N(s, c)$](https://habrastorage.org/getpro/habr/formulas/3df/d1c/d1c/3dfd1cd1ca929151920e269550bb7246.svg) обозначает количество композиций (положительного) целого ![$s$](https://habrastorage.org/getpro/habr/formulas/f9d/da2/695/f9dda26950cb67bd3ecef956c5341c14.svg) ровно в ![$c$](https://habrastorage.org/getpro/habr/formulas/e1a/229/081/e1a229081e8db6ee98dfb79797b987dd.svg) частях, причём каждая часть является степенью двойки. Тогда  
  

![$N(s, c) = \begin{cases} \sum_{i = 0}^{\lfloor \log_2 s \rfloor} N(s - 2^i, c - 1), & 2 \le c \le s \\\
1, & c = 1 \textrm{, а } s \textrm{ - степень 2} \\\
0, & \textrm{в противном случае} \end{cases}$](https://habrastorage.org/getpro/habr/formulas/1ad/481/7c6/1ad4817c637ef47ef4d59b9c7189c60b.svg)

  
потому что для каждой композиции числа ![$s - 2^i$](https://habrastorage.org/getpro/habr/formulas/304/34d/7bf/30434d7bf89de29070c6a996b6f67fde.svg) в ![$c - 1$](https://habrastorage.org/getpro/habr/formulas/635/995/f0f/635995f0f99666242f1de9308bea60e0.svg) частях мы можем получить композицию ![$s$](https://habrastorage.org/getpro/habr/formulas/f9d/da2/695/f9dda26950cb67bd3ecef956c5341c14.svg) из ![$c$](https://habrastorage.org/getpro/habr/formulas/e1a/229/081/e1a229081e8db6ee98dfb79797b987dd.svg) частей, прибавив одну часть со значением ![$2^i$](https://habrastorage.org/getpro/habr/formulas/d06/05d/276/d0605d27612401aae885d8df41cd938b.svg).  
  
Теперь нам нужно внести небольшие изменения в границы суммирования: надо использовать степени двойки, начиная с 2 и до ![$2^{K-1}$](https://habrastorage.org/getpro/habr/formulas/762/012/f99/762012f990d57f0537adbe2294648c31.svg), потому что если у нас есть тайл ![$2^K$](https://habrastorage.org/getpro/habr/formulas/1ec/f52/f1a/1ecf52f1a9d51370f6aec76f7125e3f4.svg), то игра выиграна. Для этого пусть ![$N_m(s, c)$](https://habrastorage.org/getpro/habr/formulas/339/bc8/91d/339bc891dc645efad1fade94441cef24.svg) обозначает количество композиций числа ![$s$](https://habrastorage.org/getpro/habr/formulas/f9d/da2/695/f9dda26950cb67bd3ecef956c5341c14.svg) ровно в ![$c$](https://habrastorage.org/getpro/habr/formulas/e1a/229/081/e1a229081e8db6ee98dfb79797b987dd.svg) частях, при этом каждая часть является степенью двойки от ![$2^m$](https://habrastorage.org/getpro/habr/formulas/76c/1ec/f9d/76c1ecf9db6b26ac97cce91695b56fa1.svg) до ![$2^{K-1}$](https://habrastorage.org/getpro/habr/formulas/762/012/f99/762012f990d57f0537adbe2294648c31.svg). По представленной выше логике это можно задать уравнением  
  

![$N_m(s, c) = \begin{cases} \sum_{i = m}^{K - 1} N(s - 2^i, c - 1), & 2 \le c \le s \\\
1, & c = 1 \textrm{, а } s = 2^i \textrm{ для } i \in \{ m, \ldots, K-1 \} \\\
0, & \textrm{в противном случае} \end{cases}$](https://habrastorage.org/getpro/habr/formulas/65a/c78/7d3/65ac787d382ca9b3e0b4b47e3a55f1a5.svg)

  
Теперь у нас есть формула ровно для ![$c$](https://habrastorage.org/getpro/habr/formulas/e1a/229/081/e1a229081e8db6ee98dfb79797b987dd.svg) частей, но нам нужна формула, чтобы частей было до ![$c$](https://habrastorage.org/getpro/habr/formulas/e1a/229/081/e1a229081e8db6ee98dfb79797b987dd.svg). Можно воспользоваться теми же рассуждениями, что и в предыдущем разделе: вычесть состояния без тайлов 2 или 4, которых есть ![$N_3(s, c)$](https://habrastorage.org/getpro/habr/formulas/07d/df9/067/07ddf9067ad6fbc94ed899a9800cf50f.svg). Согласно свойству 1, нам нужно не менее двух частей, поэтому мы начинаем суммировать с ![$c=2$](https://habrastorage.org/getpro/habr/formulas/585/6de/932/5856de9322161733c2842a8f2929c074.svg). Это даёт нам в качестве возможного значения для количества состояний с суммой ![$s$](https://habrastorage.org/getpro/habr/formulas/f9d/da2/695/f9dda26950cb67bd3ecef956c5341c14.svg)  
  

![$\sum_{c = 2}^{C} {C \choose c} \left( N_1(s, c) - N_3(s, c) \right)$](https://habrastorage.org/getpro/habr/formulas/fcd/66d/0a9/fcd66d0a921e3200757ffcbf91267655.svg)

  
Здесь ![$C \choose c$](https://habrastorage.org/getpro/habr/formulas/c30/28a/bde/c3028abde7f4fc175db325e4fcdfcf12.svg) — это [биномиальный коэффициент](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%BD%D0%BE%D0%BC%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D1%8D%D1%84%D1%84%D0%B8%D1%86%D0%B8%D0%B5%D0%BD%D1%82), дающий нам количество способов выбора ![$c$](https://habrastorage.org/getpro/habr/formulas/e1a/229/081/e1a229081e8db6ee98dfb79797b987dd.svg) из возможных ![$C$](https://habrastorage.org/getpro/habr/formulas/47e/792/77d/47e79277dc17c254743475ff05980a53.svg) клеток, в которых размещаются тайлы. Давайте отметим их на графике.  
  

![Number of states by sum of tiles (with K=11)](https://habrastorage.org/r/w1560/getpro/habr/post_images/e7a/31c/334/e7a31c334bc2e3d61554c3486b38a7a9.png)

  
В отношении порядка мы можем заметить, что игра 2x2 никогда не имеет более 60 состояний на слой, в игре 3x3 максимум примерно 3 миллиона состояний на слой, а в игре 4x4 максимум примерно 32 триллиона (![$10^{13}$](https://habrastorage.org/getpro/habr/formulas/fc4/2ad/1dc/fc42ad1dc5b3e11b696fbb42f303991b.svg)) состояний на слой. Количество состояний быстро растёт на ранних этапах игры, но потом замедляется и постепенно снижается при заполнении поля. На снижающейся части кривой мы видим разрывы, особенно для больших сумм. Такое может происходить, когда нет тайлов, которые подходят к полю и суммируются с этим значением.  
  
Верхний предел на горизонтальной оси возникает потому, что у нас может быть ![$C$](https://habrastorage.org/getpro/habr/formulas/47e/792/77d/47e79277dc17c254743475ff05980a53.svg) значений, каждое из которых до ![$2^{K-1}$](https://habrastorage.org/getpro/habr/formulas/762/012/f99/762012f990d57f0537adbe2294648c31.svg), то есть максимально достижимая сумма равна ![$C 2^{K-1}$](https://habrastorage.org/getpro/habr/formulas/1d0/3ab/a1f/1d03aba1f1ebe88982ccbec6a32df1a2.svg), или 16 384 для игры 4x4 до 2048.  
  
Наконец, стоит заметить, что если мы суммируем число состояний в каждом слое по всем возможным суммам слоёв от 4 до ![$C 2^{K-1}$](https://habrastorage.org/getpro/habr/formulas/1d0/3ab/a1f/1d03aba1f1ebe88982ccbec6a32df1a2.svg) и добавим единицу для особого состояния выигрыша, то мы получим то же количество состояний, которое ожидалось в предыдущем разделе. Это полезная проверка на правильность наших рассуждений.  
  

### Достижимость слоёв

  
Ещё одно полезное следствие из свойства 3 заключается в том, что если два последовательных слоя не имеют состояний, то более поздних слоёв достичь невозможно. Так получается потому, что сумма может за ход увеличиваться максимум на 4; если есть два соседних слоя без состояний, то сумма должна увеличиться на 6 за один ход, чтобы «перепрыгнуть» к последующему слою, что невозможно. Таким образом, нахождение сумм слоёв, которые не содержат состояний, с помощью представленных выше вычислений позволяет нам сузить возможное значение, исключив состояния в недостижимых слоях после последнего достижимого слоя. Наибольшие достижимые суммы слоёв (без недостижимого тайла `2048`):  
  

|Размер поля|Максимально достижимая сумма слоя|
|---|---|
|2x2|60|
|3x3|2 044|
|4x4|9 212|

  
Эта таблица также показывает нам, что максимальный тайл, которого мы можем достичь на поле 2x2 — это тайл `32`, потому что тайл `64` не может появиться в слое с суммой 60 или меньше. Аналогично, максимально достижимый тайл на поле 3x3 — это тайл `1024`. Это значит, что поле 4x4 является минимальным квадратным полем, на котором можно достичь тайла `2048` [2](https://habr.com/ru/articles/339342/#fn_smallest_board). В случае поля 4x4 максимальной суммой слоя, которую можно достичь, не доходя до тайла `2048` (то есть без победы) является 9 212, но если разрешить тайл `2048`, то можно достичь и бо́льших сумм.  
  
С учётом достижимости слоёв, новыми возможными значениями для количества состояний будут:  
  

|Максимальный тайл|Способ|Размер поля|   |   |
|---|---|---|---|---|
|||2x2|3x3|4x4|
|---|---|--:|--:|--:|
|8|Базовая линия|73|19 665|43 046 689|
|Достижимость слоёв|73|19 665|43 046 689|
|16|Базовая линия|233|261 615|4 294 901 729|
|Достижимость слоёв|233|261 615|4 294 901 729|
|32|Базовая линия|537|1 933 425|152 544 843 873|
|Достижимость слоёв|529|1 933 407|152 544 843 841|
|64|Базовая линия|1 033|9 815 535|2 816 814 940 129|
|Достижимость слоёв|905|9 814 437|2 816 814 934 817|
|128|Базовая линия|1 769|38 400 465|33 080 342 678 945|
|Достижимость слоёв|905|38 369 571|33 080 342 314 753|
|256|Базовая линия|2 793|124 140 015|278 653 866 803 169|
|Достижимость слоёв|905|123 560 373|278 653 849 430 401|
|512|Базовая линия|4 153|347 066 865|1 819 787 258 282 209|
|Достижимость слоёв|905|339 166 485|1 819 786 604 950 209|
|1024|Базовая линия|5 897|865 782 255|9 718 525 023 289 313|
|Достижимость слоёв|905|786 513 819|9 718 504 608 259 073|
|2048|Базовая линия|8 073|1 970 527 185|44 096 709 674 720 289|
|Достижимость слоёв|905|1 400 665 575|44 096 167 159 459 777|

  
Это сильно влияет на поле 2x2, снижая количество состояний с 8 073 до 905 для игры до 2048, и примечательно, что значения для числа достижимых состояний не увеличиваются с 905 для максимальных тайлов после `32`, потому что на поле 2x2 невозможно достичь тайлов, больше чем `32`. Также это немного влияет на поле 3x3, но на 4x4 это оказывает относительно малое влияние — мы избавляемся «всего» от примерно 500 миллиардов состояний от общего количества в случае игры до 2048.  
  
В графической форме эти данные выглядят так:  
  

![Estimated number of states each for board size and maximum tile](https://habrastorage.org/getpro/habr/post_images/094/e00/5d7/094e005d799602ffc35e9af7d7868137.svg)

  

# Заключение

  
Мы получили приблизительные оценки количества состояний в игре 2048 и в похожих играх на досках меньшего размера и меньшими максимальными тайлами. Пока наша наилучшая оценка количества состояний в игре 4x4 до 2048 приблизительно равна 44 квадриллионам (~![$10^{16}$](https://habrastorage.org/getpro/habr/formulas/c72/e83/83b/c72e8383bf8ff80884c9416d9be12547.svg)).  
  
Вероятно, что эта и другие оценки значительно преувеличены, потому что по многим причинам здесь могут учитываться состояния, недостижимые в игре. Например, состояние из иллюстрации к заголовку этой части статьи:  
  

![An infeasible board position with three 2 tiles in the middle with empty cells around](https://habrastorage.org/r/w1560/getpro/habr/post_images/83d/fd9/1a0/83dfd91a07af1f5f4315b30fcfb99cad.png)

  
удовлетворяет всем рассмотренным нами ограничениям, но в игре его всё равно достичь невозможно: чтобы попасть в него, нам пришлось бы перемещать тайлы в каком-нибудь направлении, и мы бы сдвинули два тайла `2` к краю поля. Возможно, существует способ подстроить вышеприведённые аргументы подсчёта с учётом этого (и, скорее всего, к другим ограничениям), но пока я не понял, как это сделать!  
  
В следующем посте мы увидим, что количество действительно достижимых состояний намного ниже, на самом деле перечислив их. Их всё равно будет много для полей 3x3 и 4x4, поэтому нам потребуются знания теории обработки информации, а также математики.  
  

---

  
Если вы дочитали до этого места, возможно, стоит [подписаться на меня в Twitter](https://twitter.com/jdleesmiller), или даже прислать просьбу о найме в [Overleaf](https://www.overleaf.com/jobs).  
  

# Примечания

  

1. Chinn, P. and Niederhausen, H., 2004. Compositions into powers of 2. _Congressus Numerantium_, 168, p.215. [(препринт)](http://math.fau.edu/Niederhausen/HTML/Papers/CompositionsIntoPowersOf2.doc)
2. Мы могли показать это и с помощью анализа цепей Маркова из первой части, убрав все состояния с более чем девятью тайлами, и проверив, возможно ли всё ещё достичь тайла `2048`. Если мы [сделаем это](https://github.com/jdleesmiller/twenty48/blob/4337c357f2cc14bdc3e14ddaa5207ad2a6a972e6/bin/markov_chain#L382-L397), то выясним, что [это невозможно](https://github.com/jdleesmiller/twenty48/blob/4337c357f2cc14bdc3e14ddaa5207ad2a6a972e6/data/markov_chain/minmax_cells.csv). Интересно, что если мы позволим цепи Маркова продолжить увеличивать максимальные значения тайла, то тот же анализ покажет, что на поле 4x4 можно достичь тайла `131072` (то есть ![$2^{17}$](https://habrastorage.org/getpro/habr/formulas/69a/a55/7cb/69aa557cbb29c41e572d3bfda7b38b72.svg)), если при этом игнорировать структуру поля. Будет ли это справедливо для случая со структурными ограничениями — не знаю, но подозреваю, что нет. Однако, как показано [этим ИИ-ботом](https://www.youtube.com/watch?v=96ab_dK6JM0), возможно играть как минимум до тайла `8192`, и существует [видео «доказательства концепции»](https://www.youtube.com/watch?v=MDkZkweB5lM) для тайла `131072`