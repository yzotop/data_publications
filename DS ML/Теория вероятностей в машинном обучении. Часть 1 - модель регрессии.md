---
tags:
  - data
link: https://habr.com/ru/companies/ods/articles/713920/
source: habr
data_type:
  - DS
company: ODS
author: ODS
---
В данной статье мы подробно рассмотрим вероятностную постановку задачи машинного обучения: что такое **распределение данных**, **дискриминативная модель**, **i.i.d.-гипотеза** и **метод максимизации правдоподобия**, что такое **регрессия Пуассона** и **регрессия с оценкой уверенности**, и как нормальное распределение связано с минимизацией среднеквадратичного отклонения.

В [следующей части](https://habr.com/ru/company/ods/blog/714670/) рассмотрим метод максимизации правдоподобия в классификации: в чем роль **кроссэнтропии**, **функций сигмоиды и softmax** и как кроссэнтропия связана с "расстоянием" между распределениями вероятностей и почему модель регрессии тоже обучается через минимизацию кроссэнтропии.

В третьей части (статья планируется) перейдем от метода максимизации правдоподобия к **байесовскому выводу** и его различным приближениям, таким как **метод апостериорного максимума**, **методы Монте-Карло** и **вариационный вывод**. Рассмотрим, как применение этих методов порождает типичные для машинного обучения понятия, такие как стохастический градиентный спуск, регуляризация, ансамблирование, подбор архитектуры и гиперпараметров. Также поговорим о роли априорных гипотез в машинном обучении.

Данная серия статей не является введением в машинное обучение и предполагает знакомство читателя с основными понятиями. Задача статей - рассмотреть машинное обучение с точки зрения теории вероятностей, что позволит по новому взглянуть на проблему, понять связь машинного обучения со статистикой и лучше понимать формулы из научных статей. Также на описанном материале строятся более сложные темы, такие как вариационные автокодировщики ([Kingma and Welling, 2013](https://arxiv.org/abs/1312.6114)), нейробайесовские методы ([Müller et al., 2021](https://arxiv.org/abs/2112.10510)) и даже некоторые теории сознания ([Friston et al., 2022](https://mitpress.mit.edu/9780262045353/active-inference/)).

---

Бывало ли у вас такое, что разбираясь в некой сложной области вам сначала не удается систематизировать в голове всю имеющуюся информацию, а затем вы что-то узнаете или догадываетесь, и пазл внезапно складывается в стройную и непротиворечивую картину? Именно такую роль может сыграть понимание байесовского вывода в машинном обучении.

Как писал Пьер-Симон Лаплас в начале XIX века, "теория вероятностей - это здравый смысл, выраженный в вычислениях". Поэтому разрабатывать алгоритмы машинного обучения можно и не опираясь на теорию вероятностей и байесовский вывод. Но с изучением этих областей то, что раньше казалось просто здравым смыслом, приобретает большую строгость и обоснования.

Впрочем, в машинном обучении любые теории строятся на очень зыбкой почве, поскольку машинное обучение - это не чистая математика, а наука о применении алгоритмов обучения на данных к реальному миру. Любая математическая теория основана на аксиомах и условиях (например, в статистике таким условием часто является "независимость и одинаковая распределенность обучающих примеров"). В реальности эти условия могут не выполняться, и иногда даже не иметь четкого смысла. Об этой теме мы тоже поговорим подробнее.

Возможно, изложение в статье покажется слишком подробным и затянутым, но эти вещи невозможно объяснить в двух словах. Большое количество деталей и пояснений позволяет надеяться, что ничего важного не будет упущено, и в понимании не останется пробелов.

### Содержание текущей части

- **В первом разделе** мы рассмотрим связь между машинным обучением и статистическим выводом.
    
- **Во втором разделе** поговорим о моделях: рассмотрим вероятностную модель регрессии и ее обучение методом максимизации правдоподобия.
    
- **В третьем разделе** поговорим о данных: рассмотрим понятие вероятностного распределения данных, задачу максимизации метрики на распределении и i.i.d.-гипотезу.
    
- **В четвертом разделе** снова вернемся к методу максимизации правдоподобия, используя материал из третьего раздела, и введем понятие статистической модели.
    
- **В пятом разделе** рассмотрим модель регрессии с оценкой уверенности в виде формул и программного кода.
    

Звездочкой* отмечены дополнительные разделы, которые не повлияют на понимание дальнейшего материала.

1. [Машинное обучение и статистический вывод](https://habr.com/ru/companies/ods/articles/713920/#1)  
2. [Вероятностная модель регрессии](https://habr.com/ru/companies/ods/articles/713920/#2)  
        2.1. [Регрессия, классификация и промежуточные варианты](https://habr.com/ru/companies/ods/articles/713920/#2.1)  
        2.2. [Вероятностное моделирование](https://habr.com/ru/companies/ods/articles/713920/#2.2)  
        2.3. [Модель регрессии](https://habr.com/ru/companies/ods/articles/713920/#2.3)  
        2.4. [Обсуждение](https://habr.com/ru/companies/ods/articles/713920/#2.4)  
        2.5. [Функция потерь Хьюбера](https://habr.com/ru/companies/ods/articles/713920/#2.5)*  
3. [Вероятностное распределение данных](https://habr.com/ru/companies/ods/articles/713920/#3)  
        3.1. [Понятие распределения данных](https://habr.com/ru/companies/ods/articles/713920/#3.1)  
        3.2. [Дискриминативные модели](https://habr.com/ru/companies/ods/articles/713920/#3.2)  
        3.3. [Генеративные модели](https://habr.com/ru/companies/ods/articles/713920/#3.3)*  
        3.4. [i.i.d.-гипотеза и качество обобщения](https://habr.com/ru/companies/ods/articles/713920/#3.4)  
        3.5. [Проблемы i.i.d.-гипотезы](https://habr.com/ru/companies/ods/articles/713920/#3.5)*  
4. [Статистические модели](https://habr.com/ru/companies/ods/articles/713920/#4)  
        4.1. [Простые статистические модели](https://habr.com/ru/companies/ods/articles/713920/#4.1)  
        4.2. [Статистические модели в машинном обучении](https://habr.com/ru/companies/ods/articles/713920/#4.2)  
5. [Регрессия с оценкой уверенности](https://habr.com/ru/companies/ods/articles/713920/#5)*  
        5.1. [Моделирование дисперсии в модели регрессии](https://habr.com/ru/companies/ods/articles/713920/#5.1)*  
        5.2. [Регрессия с константной оценкой дисперсии](https://habr.com/ru/companies/ods/articles/713920/#5.2)*

## 1. Машинное обучение и статистический вывод

Статистический вывод (оценка параметров и проверка гипотез) часто включается в курсы машинного обучения. Но многими он воспринимается лишь как досадная заноза, которая только отнимает время и далее нигде не используется. Однако машинное обучение и статистический вывод тесно связаны и решают почти одну и ту же задачу.

- **Машинное обучение** заключается в написании и применении алгоритмов, которые обучаются на данных, автоматически выводя общие закономерности из частных примеров.
    
- **Статистический вывод** заключается в оценке параметров распределений и проверке гипотез на основе наблюдений, то есть опять-таки в получении общих выводов из частных примеров.
    

Процесс выведения общих правил из частных примеров называется обобщением (_generalization_), или [индуктивным выводом](https://plato.stanford.edu/entries/logic-inductive/) (_inductive inference_). Чем же тогда отличаются эти два раздела науки? Граница между ними довольно расплывчата. Вообще говоря, большую часть машинного обучения можно считать статистическим выводом, что мы более формально рассмотрим в дальнейшем.

Иногда говорят, что в статистике целью обычно является вывод (**inference**) о том, верна ли гипотеза или как связаны между собой переменные, а в машинном обучении целью обычно является предсказание (**prediction**) или генерация чего-либо ([Bzdok et al., 2018](https://www.nature.com/articles/nmeth.4642)), хотя эти две цели часто близки. В машинном обучении, как правило, используются более сложные модели, тогда как в традиционной статистике модели обычно проще, но за счет этого они более интерпретируемы и больше внимания уделяется оценке уверенности в сделанных выводах ([Breiman, 2001](https://projecteuclid.org/journals/statistical-science/volume-16/issue-3/Statistical-Modeling--The-Two-Cultures-with-comments-and-a/10.1214/ss/1009213726.full)).

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c7a/3cc/9ed/c7a3cc9ed962493b555e815663adaf69.png)

## 2. Вероятностная модель регрессии

### 2.1. Регрессия, классификация и промежуточные варианты

Задачи классификации и регрессии отличаются типом целевого признака: в регрессии целевой признак количественный (иногда его называют "числовой"), в классификации - категориальный. Отличие категориального от количественного признака заключается не в его типе (_int_ или _float_), а скорее в предполагаемой метрике сходства на множестве его значений:

- В _количественном признаке_ чем больше модуль разности между двумя значениями, тем сильнее они непохожи друг на друга. Например, предсказать значение 2 вместо 1 будет в меньшей степени ошибкой, чем предсказать 10 вместо 1.
    
- В _категориальном признаке_ все значения, называемые классами, одинаково непохожи друг на друга. Например, предсказать 2-й класс вместо 1-го будет в той же степени ошибкой, что и предсказать 10-й класс вместо 1-го. При этом множество значений дискретно и, как правило, конечно.
    

Все остальные отличия в алгоритмах (в формате выходных данных, функции потерь и метрике качества) обусловлены описанной выше разницей между этими типами. Вообще, при желании задачу классификации технически можно решать как регрессию, то есть напрямую предсказывать номер класса и округлять его до целого числа. Регрессию, наоборот, можно свести к классификации, выполнив дискретизацию множества значений целевого признака. Такие модели кое-как обучатся, но чаще всего их качество на валидации будет существенно ниже, впрочем бывают и исключения ([Müller et al., 2021)](https://arxiv.org/abs/2112.10510).

В случае иерархической классификации ([Silla and Freitas, 2011](https://www.cs.kent.ac.uk/people/staff/aaf/pub_papers.dir/DMKD-J-2010-Silla.pdf)) целевой признак на первый взгляд является категориальным, но на деле некоторые классы могут быть ближе по смыслу и положению в иерархии друг к другу, чем другие. Например, в классификации животных предсказать овчарку вместо лабрадора является в меньшей степени ошибкой, чем предсказать бегемота вместо лабрадора. Это означает, что на множестве значений целевого признака есть какая-то нетривиальная метрика сходства, и ее желательно учесть в алгоритме обучения.

Будет ли это по прежнему задачей классификации? Сложно сказать. Базовые понятия "классификации" и "регрессии" не покрывают все разнообразие промежуточных вариантов (так же как есть промежуточные варианты между молотком, топором и другими инструментами) ([Bernholdt et al., 2019](https://arxiv.org/abs/1905.06220), [Twomey et al., 2019](https://arxiv.org/abs/1905.13658)). Важно лишь то, что при выборе формата выходных данных и функции потерь нужно учитывать метрику сходства на множестве значений целевого признака. Это один из способов внесения в модель априорной (известной или предполагаемой заранее) информации, к чему мы будем еще не раз возвращаться.

### 2.2. Вероятностное моделирование

В задачах классификации и регрессии (и многих других задачах) требуется найти зависимость между исходными данными ![X](https://habrastorage.org/getpro/habr/upload_files/e05/a47/2a4/e05a472a4e6226d13179e369a5b1967c.svg) и целевыми данными ![Y](https://habrastorage.org/getpro/habr/upload_files/452/81f/526/45281f526b76db2cfbea71447d4d0958.svg) в виде функции ![f: X \to Y](https://habrastorage.org/getpro/habr/upload_files/45b/cfe/8bb/45bcfe8bbf6a3b2d843165ef088aa96d.svg). Обычно модель имеет параметры, которые подбираются в ходе обучения, поэтому модель можно записывать как функцию от входных данных ![x](https://habrastorage.org/getpro/habr/upload_files/683/30b/321/68330b321a7e0e3eae117a1c31594b31.svg) и параметров ![\theta](https://habrastorage.org/getpro/habr/upload_files/826/efa/c2b/826efac2b4a8d24ba8b72a2c503acb3f.svg). Поскольку параметров обычно много, то ![\theta](https://habrastorage.org/getpro/habr/upload_files/f5e/ac7/1c9/f5eac71c969a26e10b32f118edac6427.svg) - это некий массив чисел. Предсказанное моделью значение ![y](https://habrastorage.org/getpro/habr/upload_files/b1e/807/123/b1e807123272dce985996a11858a0a0e.svg) (в отличие от истинного значения) обычно обозначается крышечкой (циркумфлексом): ![\hat{y} = f(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/7f3/9ec/a95/7f39eca950f538afd18cf3bac2a0adac.svg).

Общая идея вероятностного моделирования заключается в том, что вместо одного числа модель должна предсказывать _распределение вероятностей на множестве_ ![Y](https://habrastorage.org/getpro/habr/upload_files/1e5/e8b/aed/1e5e8baed17e5e3cf3079d0b7de28a59.svg) _при заданном значении_ ![x \in X](https://habrastorage.org/getpro/habr/upload_files/57b/23f/e9e/57b23fe9edbd4ab132560e4872ada02d.svg). В теории вероятностей это называется условным распределением и записывается как ![p(y|X=x)](https://habrastorage.org/getpro/habr/upload_files/c70/e9f/e53/c70e9fe53edb313c98828f4cca8c8c37.svg) или просто ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/a15/f97/b6d/a15f97b6da2841ffebc6f2520dac005f.svg). Поскольку модель имеет параметры, то вероятностную модель записывают как ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/daa/d74/713/daad74713862cece98b4e21cfe125dff.svg) - эта запись читается как "вероятность ![y](https://habrastorage.org/getpro/habr/upload_files/cd2/862/d25/cd2862d25652f831ba2d8ea4310e9423.svg) при ![x](https://habrastorage.org/getpro/habr/upload_files/c51/e88/5f6/c51e885f65ff55e7d220b95ca8b34117.svg) и ![\theta](https://habrastorage.org/getpro/habr/upload_files/bb6/cc2/1fb/bb6cc21fb3fbd556138c5db5e1c16ca3.svg)" (позже рассмотрим конкретные примеры).

Таким образом мы позволим модели "сомневаться" в предсказании. Выполнив такой переход, мы ничего не теряем: распределение вероятностей ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/54b/d74/9b6/54bd749b6345f921727ebb031269a75b.svg) несет больше информации, чем точечная оценка ![f(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/01b/cec/efa/01bcecefa7d512037cfadbc0e982608f.svg). Зато мы получаем важное преимущество. Величина ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/c66/c33/218/c66c33218497d96b095a3f1e88114a36.svg) определена для всех ![y \in Y](https://habrastorage.org/getpro/habr/upload_files/741/4fa/4c9/7414fa4c96f2961f0b3c1d2915ff1c2b.svg), поэтому мы можем количественно оценить ошибку модели: чем меньшую вероятность модель назначает верному ![y](https://habrastorage.org/getpro/habr/upload_files/0e2/d70/288/0e2d702882a4175cd85d92a951918fac.svg), тем сильнее ошибка. Так мы естественным образом можем задать функцию потерь.

### 2.3. Модель регрессии

Пусть мы имеем нейронную сеть с одним скрытым слоем шириной в ![N=1000](https://habrastorage.org/getpro/habr/upload_files/62e/c5c/90e/62ec5c90efa2e0eca5b465290300c477.svg) нейронов и хотим применить ее для решения задачи регрессии с ![M](https://habrastorage.org/getpro/habr/upload_files/051/e8a/d8b/051e8ad8be2c75db34d239eb1bf8d5b3.svg)= 10 входными признаками. Такая сеть имеет 2 матрицы весов и 2 вектора bias'ов: ![\theta = (W_1, b_1, W_2, b_2)](https://habrastorage.org/getpro/habr/upload_files/1a6/020/78a/1a602078a6c55c20049c9335282512c8.svg). Нетрудно посчитать, что, например, матрица ![W_1](https://habrastorage.org/getpro/habr/upload_files/9bd/cd9/cf3/9bdcd9cf3eb9c5530ffa627f6c17867e.svg) содержит ![MN](https://habrastorage.org/getpro/habr/upload_files/72c/3f0/c0b/72c3f0c0b8ceaaace3d71952a17969d4.svg)= 10000 весов, а всего количество весов равно 12001. Пусть в качестве функции активации используется ![\text{ReLU}(x) = \max (0, x)](https://habrastorage.org/getpro/habr/upload_files/7be/155/4cd/7be1554cd2ec63de8af5fba956ffb22a.svg). Преобразование входных данных в выходные осуществляется по следующей формуле (всю сеть обозначим как функцию ![f](https://habrastorage.org/getpro/habr/upload_files/429/488/5a7/4294885a7f862ef7f067549900ff440e.svg)):

![\hat{y} = f(x, \theta) = W_2 \text{ReLU}(W_1x + b) + b_2 \tag{1}](https://habrastorage.org/getpro/habr/upload_files/27e/103/796/27e1037963614171332908ebb573c4d2.svg)

_Примечание._ Умножение вектора ![x](https://habrastorage.org/getpro/habr/upload_files/a46/14a/3fb/a4614a3fbdad95d0601194fb7a4675b3.svg)на матрицу ![W](https://habrastorage.org/getpro/habr/upload_files/e8f/0bf/e11/e8f0bfe11bc0814fe9817027df05456f.svg)может выполняться слева (![Wx](https://habrastorage.org/getpro/habr/upload_files/44b/3d9/0a1/44b3d90a1abb69c56d1f73552f6d295b.svg)) или справа (![xW](https://habrastorage.org/getpro/habr/upload_files/a0b/fa0/6d5/a0bfa06d546e95f3d2d172f10568fff7.svg)), в зависимости от того, работаем мы с векторами-строками или векторами-столбцами. Например, в TensorFlow используется умножение справа, и матрица весов имеет размер (in, out), в PyTorch - умножение слева, и матрица весов имеет размер (out, in).

Меняя параметры ![\theta](https://habrastorage.org/getpro/habr/upload_files/5a8/e84/c55/5a8e84c55a5516c6f726de1121fdefb4.svg), можно получить совершенно разные функции ![f(\cdot, \theta)](https://habrastorage.org/getpro/habr/upload_files/0ff/806/e0c/0ff806e0c39dcdc18ff1389445d66e84.svg). Обучение сети заключается в том, что мы подбираем такие ![\theta](https://habrastorage.org/getpro/habr/upload_files/d34/e14/eab/d34e14eab11754be0ba6bcb9a183f4b0.svg), чтобы минимизировать ошибку предсказания на обучающей выборке. Но способ расчета ошибки предсказания можно выбрать по-разному:

**Алгоритмический подход.** Мы выбираем способ расчета ошибки произвольным образом на основании здравого смысла, руководствуясь любыми соображениями. Например можем взять в качестве ошибки среднеквадратичное отклонение ![\text{MSE}(y, \hat{y}) = (y-\hat{y})^2](https://habrastorage.org/getpro/habr/upload_files/93b/22a/7b0/93b22a7b078a6cccb7256494c2aa08a3.svg) или среднее абсолютное отклонение ![\text{MAE}(y, \hat{y}) = |y-\hat{y}|](https://habrastorage.org/getpro/habr/upload_files/970/3f2/20d/9703f220d75006220683638af4e51941.svg). Нетрудно видеть, что ![\text{MSE}(y, \hat{y}) = \text{MAE}(y, \hat{y})^2](https://habrastorage.org/getpro/habr/upload_files/d54/218/0c2/d542180c2260ee900939c0cec7caf4ba.svg). Поэтому MSE, в сравнении с MAE, не так сильно штрафует несущественные ошибки, но сильнее штрафует большие ошибки. Таким образом, MAE более устойчив к выбросам (подробнее см., например, [здесь](https://stats.stackexchange.com/a/582261/376579)).

Определившись с тем, как сильно нам нужно штрафовать большие ошибки в сравнении с маленькими, мы можем выбрать функцию потерь. Далее, поскольку в обучающей выборке много примеров, сложим величину ошибки на всех примерах и будем минимизировать полученную сумму.

**Вероятностный подход.** Будем рассматривать значение ![f(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/559/651/0a0/5596510a009864a72ca775d42a63b3e2.svg) как мат. ожидание нормального распределения с некой фиксированной дисперсией ![\sigma^2](https://habrastorage.org/getpro/habr/upload_files/597/660/573/597660573f597f34a5d581cb845e238a.svg). Так мы получим распределение вероятностей для ![y](https://habrastorage.org/getpro/habr/upload_files/82b/362/130/82b36213023122b93113c777211459ed.svg) при данном ![x](https://habrastorage.org/getpro/habr/upload_files/b1f/5e1/7aa/b1f5e17aae9476521907eaaebb08cbce.svg):

![\begin{cases}\mu = f(x, \theta)\\p(y|x, \theta)=\mathcal{N}(y|\mu, \sigma^2)\end{cases} \tag{2}](https://habrastorage.org/getpro/habr/upload_files/958/c65/48a/958c6548a45c9b69b75d198ba1f631ca.svg)

Иногда то же самое записывают другим способом:

![y = f(x, \theta) + \textit{noise},\ \ \ \ \textit{noise} \sim \mathcal{N}(0, \sigma^2) \tag{3}](https://habrastorage.org/getpro/habr/upload_files/350/e3c/29e/350e3c29e8172fa2627b56e6c073eab9.svg)

Формула плотности вероятности нормального распределения:

![\mathcal{N}(y|\mu, \sigma^2) = \cfrac{1}{\sigma \sqrt{2 \pi}} \exp {-\cfrac{(y-\mu)^2}{2 \sigma^2}} \tag{4}](https://habrastorage.org/getpro/habr/upload_files/555/592/a90/555592a90aea1569b988f3b236bfd777.svg)

Эта формула выглядит несколько громоздкой, но на самом деле она несложная. Если мы обозначим ![\Delta = y - \mu](https://habrastorage.org/getpro/habr/upload_files/683/304/7a8/6833047a89a8a3b57c331c092b9480d3.svg), то основу формулы (4) составляет выражение ![\exp (-\Delta^2)](https://habrastorage.org/getpro/habr/upload_files/bfa/bee/cbd/bfabeecbd1f67b5222ec3475862c1d00.svg). График этой функции [выглядит](https://en.wikipedia.org/wiki/Normal_distribution) как характерный симметричный "колокол" с центром в ![\Delta=0](https://habrastorage.org/getpro/habr/upload_files/890/46a/34b/89046a34b75610a97038d88393d776a7.svg). Коэффициент ![1/(2 \sigma^2)](https://habrastorage.org/getpro/habr/upload_files/48e/cd3/c05/48ecd3c059d1addc534ce8a9c34bc528.svg) определяет "сжатие" колокола по горизонтальной оси, коэффициент ![1/(\sigma \sqrt{2 \pi})](https://habrastorage.org/getpro/habr/upload_files/974/d42/b8b/974d42b8b21901f7a6f7a45e45c3f920.svg) определяет "сжатие" по вертикальной оси. Эти коэффициенты выбраны так, чтобы интеграл функции от ![-\infty](https://habrastorage.org/getpro/habr/upload_files/978/118/7f0/9781187f0671fdc430a0a3726dfed3e2.svg) до ![+\infty](https://habrastorage.org/getpro/habr/upload_files/68a/79b/e49/68a79be4954b9f67a6f7936d0a482e5c.svg) был равен единице (что требуется для всех распределений), и чтобы распределение имело дисперсию ![\sigma^2](https://habrastorage.org/getpro/habr/upload_files/d7f/7a4/b75/d7f7a4b751fb117b031520d6921bcece.svg).

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fc2/858/4b9/fc28584b9fc72adaf19fd195dc488f86.png)

Итак, мы считаем, что для каждого ![x](https://habrastorage.org/getpro/habr/upload_files/f1a/409/4a6/f1a4094a647156d218c0d16c813c8eb2.svg) величина ![y](https://habrastorage.org/getpro/habr/upload_files/827/012/b4b/827012b4b1a05ce705253f3fd2b07081.svg) распределена нормально, и мат. ожидание распределения является функцией от ![x](https://habrastorage.org/getpro/habr/upload_files/ec6/b2b/f9b/ec6b2bf9b601ca7f13efa64fcc7ef7a7.svg), которую требуется найти. В отличие от предыдущего подхода, теперь мы можем рассчитать вероятность для любого значения ![y](https://habrastorage.org/getpro/habr/upload_files/5c4/5d9/90b/5c45d990b82f750bd621fe532b86a405.svg) при ![x](https://habrastorage.org/getpro/habr/upload_files/622/7f1/4cc/6227f14cc52a1554b5c0a258f71e1784.svg) и ![\theta](https://habrastorage.org/getpro/habr/upload_files/bd3/976/137/bd397613717a5f074f8caab25c0391b0.svg).

Для каждого обучающего примера: чем меньше вероятность истинного значения ![y](https://habrastorage.org/getpro/habr/upload_files/905/6ee/182/9056ee182e15c5edab7f5415aee087b5.svg) при заданных ![x](https://habrastorage.org/getpro/habr/upload_files/fcf/f2a/ae5/fcff2aae5a11f79fb7f8ae2615c96528.svg) и ![\theta](https://habrastorage.org/getpro/habr/upload_files/0d8/29e/4d7/0d829e4d7f9f1d69be470a4fa8dd5e31.svg), тем сильнее ошибка предсказания на данном примере. Отсюда естественным образом вытекает функция потерь: нам нужно максимизировать ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/a43/8e8/b26/a438e8b26e6b222921209e3faf60fa18.svg). Формула (2) задает вид этого распределения, а формула (4) помогает подсчитать конкретное численное значение ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/0d9/b56/e1b/0d9b56e1b455297062e430f698f2d893.svg) для каждого обучающего примера.

Поиск значений параметров ![\theta](https://habrastorage.org/getpro/habr/upload_files/7da/fad/efb/7dafadefbfc4913f21a8000cf8be141c.svg), при которых вероятность (правдоподобие) наблюдаемых данных ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/42f/11c/d69/42f11cd69e5e1e1107f4779a489d7167.svg) максимальна, называется **методом максимизации правдоподобия** (maximum likelihood estimation, MLE). Параметры, максимизирующие правдоподобие, часто обозначают как ![\theta^{ML}](https://habrastorage.org/getpro/habr/upload_files/126/177/29f/12617729f059f64e9eb6cbcaff8af97e.svg), мы будем обозначать их как ![\theta_{best}](https://habrastorage.org/getpro/habr/upload_files/61b/b54/6b8/61bb546b8e22af12d3e2ecf7b406b0df.svg).

Пока что мы рассмотрели только один пример, но в обучающей выборке много примеров. Будем искать такие параметры ![\theta](https://habrastorage.org/getpro/habr/upload_files/8bc/d50/b47/8bcd50b475cd166c8f93ead92838bb50.svg), чтобы максимизировать произведение вероятностей для всех примеров (позже рассмотрим, почему именно произведение, а не сумму). Максимизация некой величины эквивалентна максимизации ее логарифма, а логарифм произведения равен сумме логарифмов множителей:

![\theta_{best} = \underset{\theta}{\text{arg max}} \prod\limits_{i=1}^N p(y_i|x_i, \theta) = \underset{\theta}{\text{arg min}} \sum\limits_{i=1}^N -\log p(y_i|x_i, \theta) \tag{5}](https://habrastorage.org/getpro/habr/upload_files/d0c/02d/d08/d0c02dd082aa88902b0657232b55fddc.svg)

Формула (5) говорит, что нам нужно минимизировать функцию потерь, равную сумме ![-\log p(y_i|x_i, \theta)](https://habrastorage.org/getpro/habr/upload_files/c22/0f7/c3b/c220f7c3bf71615b5941448cb14c9257.svg) по всем обучающим примерам ![(x_i, y_i)](https://habrastorage.org/getpro/habr/upload_files/804/774/01e/80477401e08f6ad79b86dad84ed88fef.svg), где ![p(y_i|x_i, \theta)](https://habrastorage.org/getpro/habr/upload_files/422/d49/3c3/422d493c30ccc3fd601a40b17e8b5c70.svg) мы моделируем нормальным распределением (2). Подставив выражение для нормального распределения (4) получим:

![-\log p(y|x, \theta)=  \log\sigma +\log \sqrt{2 \pi} + \cfrac{(y-f(x, \theta))^2}{2 \sigma^2} \tag{6}](https://habrastorage.org/getpro/habr/upload_files/011/358/71b/01135871b0acb0181f56a41f9bbda5b4.svg)

Первые два слагаемых в (6) являются константами и поэтому не влияют на положение максимума по ![\theta](https://habrastorage.org/getpro/habr/upload_files/2ff/672/5ae/2ff6725ae275b7bbbf3966de0a430413.svg), значит их можно удалить. В третьем слагаемом знаменатель является константой, поэтому он тоже не влияет на положение максимума по ![\theta](https://habrastorage.org/getpro/habr/upload_files/4de/f8e/60f/4def8e60f6beaedeeb0f058610ae3e12.svg), его можно заменить на единицу. После этих действий подставим (6) в (5) и получим:

![\theta_{best} = \underset{\theta}{\text{arg min}} \sum\limits_{i=1}^N (y_i-f(x_i, \theta))^2 \tag{7}](https://habrastorage.org/getpro/habr/upload_files/c57/06e/7e5/c5706e7e59a94e9b27fc21ce8811764b.svg)

Ранее мы вводили обозначение ![\hat{y_i} = f(x_i, \theta)](https://habrastorage.org/getpro/habr/upload_files/43f/3bf/3b6/43f3bf3b63160b7c4eb5389f608c4c1a.svg). Согласно формуле (7) нам надо минимизировать сумму среднеквадратичных отклонений ![(y_i-\hat{y_i})^2](https://habrastorage.org/getpro/habr/upload_files/fd8/56d/00e/fd856d00e516c55a8cbca3a93adec379.svg) по всем обучающим примерам. Вспомним, что изначально в модели регрессии мы считали ![\sigma^2](https://habrastorage.org/getpro/habr/upload_files/2da/834/42b/2da83442b7d2def8bbe988e1da866a77.svg) константой, для которой выбрано произвольное значение. Теперь выясняется, что константа ![\sigma^2](https://habrastorage.org/getpro/habr/upload_files/ad4/8a3/a4e/ad48a3a4e3ef57fb310afe8660cf78a9.svg) не влияет на оптимальные параметры ![\theta_{best}](https://habrastorage.org/getpro/habr/upload_files/145/ac3/d22/145ac3d223ccc6888c3ab42325dfd152.svg), поэтому в задаче поиска оптимальных параметров ее значение не играет роли.

_Примечание._ Значение ![\sigma^2](https://habrastorage.org/getpro/habr/upload_files/30a/ddd/06a/30addd06a868e53a931d9235013559d8.svg)влияет на результат в байесовском выводе, который мы будем рассматривать в следующих частях.

**Резюме.** В алгоритмическом подходе модель машинного обучения - это некая параметризованная функция ![f(\cdot, \theta): X \to Y](https://habrastorage.org/getpro/habr/upload_files/f00/1a3/963/f001a396357b1ece6673dbd39f7fe622.svg). Например, это может быть линейная регрессия, нейронная сеть, ансамбль решающих деревьев или машина опорных векторов (хотя две последние модели имеют переменное число параметров, но это не принципиально). Такая модель напрямую предсказывает значение ![y](https://habrastorage.org/getpro/habr/upload_files/874/fe0/90f/874fe090fdc4630f925b915d6c291d80.svg). В вероятностном подходе модель по-прежнему предсказывает число ![f(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/9dd/86a/4b2/9dd86a4b2fec4c3c544780ca6a990eae.svg), но теперь это число считается не окончательным предсказанием ![y](https://habrastorage.org/getpro/habr/upload_files/57e/670/575/57e670575936d0d35d79679ab98ce9d4.svg), а мат. ожиданием нормального распределения с некой фиксированной дисперсией ![\sigma^2](https://habrastorage.org/getpro/habr/upload_files/c28/f01/16b/c28f0116b6cee0e72f8709b5498a3208.svg). Таким образом мы моделируем условное распределение ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/32b/7c5/c42/32b7c5c42ed72242c937e99f4b41b1bf.svg).

Важно понять, что между этими двумя подходами нет принципиальной разницы. Если вероятностная модель предсказывает, что "![y](https://habrastorage.org/getpro/habr/upload_files/de0/686/eda/de0686eda518c651f2c8d022fdab2c76.svg) находится где-то вокруг точки ![f(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/e7a/f76/6e1/e7af766e1a1311177a0bebf78e6ba0a0.svg) со среднеквадратичным отклонением ![\sigma](https://habrastorage.org/getpro/habr/upload_files/a98/dbe/61e/a98dbe61e209fa9fd4a0e8644ab6d782.svg)", то при точечной оценке модель предсказывает, что "![y](https://habrastorage.org/getpro/habr/upload_files/22b/4c5/2cb/22b4c52cb8b7b513bb6693c1ff74ce85.svg) равно ![f(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/f37/52d/cd6/f3752dcd663a830b5608c7834ed23c78.svg)", но при этом мы понимаем, что модель обычно не выдает идеально точных предсказаний, и интерпретируем ее предсказание как "![y](https://habrastorage.org/getpro/habr/upload_files/2e4/8f2/e51/2e48f2e512646b7a56e03f5390b76460.svg) находится где-то вокруг точки ![f(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/011/788/715/01178871528298db0a878ea8b4fcacd0.svg)".

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/aba/05b/fa1/aba05bfa17b47c407625688518df9eb0.png)

Таким образом, вероятностная модель просто формализует то, что при точечной оценке мы предполагали неформально. Вспомним цитату Лапласа о том, что теория вероятностей - лишь здравый смысл, выраженный в вычислениях.

### 2.4. Обсуждение

На примере регрессии мы увидели, что вероятностный подход позволяет вывести выражение для функции потерь, которое в алгоритмическом подходе мы выбирали произвольно. Однако нормальное распределение в (2) мы выбрали произвольно. Вместо него мы могли бы взять, например, распределение Пуассона или Лапласа. В случае распределения Лапласа мы пришли бы к тому, что надо минимизировать среднее абсолютное отклонение ![|y-\hat{y}|](https://habrastorage.org/getpro/habr/upload_files/e45/3a2/bfa/e453a2bfa3ea302db2f494b93667744c.svg). Отсюда получается, что выбор распределения ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/292/275/8b9/2922758b9ac787f32514a535239ae8c8.svg) в вероятностном подходе эквивалентен выбору функции ошибки ![L(y, \hat{y})](https://habrastorage.org/getpro/habr/upload_files/5ee/1d7/65d/5ee1d765d4439707924b82baa816fcc5.svg) в алгоритмическом подходе.

Какой же подход лучше - вероятностный или алгоритмический? Вероятностный подход удобно применять в тех случаях, когда есть объективные причины предполагать, что ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/ad0/ba5/44d/ad0ba544d992560d7cf9d202af60bca6.svg) имеет тот или иной вид:

**Пример 1.** Иногда мы знаем, что ![y](https://habrastorage.org/getpro/habr/upload_files/3a6/9f2/a23/3a69f2a2342cec704f0ba6e59b63e979.svg) - это количество неких событий, которые произошли в условиях ![x](https://habrastorage.org/getpro/habr/upload_files/33d/49a/91a/33d49a91a731a2b5f92783d2dbba7d2b.svg) - например, количество посетителей тренажерного зала в зависимости от погоды. Тогда распределение ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/6f9/8b9/2e8/6f98b92e81edb6ca81fd16ad24a04399.svg) скорее всего похоже на [распределение Пуассона](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9F%D1%83%D0%B0%D1%81%D1%81%D0%BE%D0%BD%D0%B0), параметр которого является функцией от ![x](https://habrastorage.org/getpro/habr/upload_files/d5d/524/6bd/d5d5246bd4d8cdc896b94f846ebe0c48.svg). Мы можем расписать аналог формулы (2) для распределения Пуассона и из него вывести функцию потерь, которую следует применять. В результате мы получаем [регрессию Пуассона](https://en.wikipedia.org/wiki/Poisson_regression). Кроме того, преимущество в том, что мы получаем не точечную оценку, а распределение вероятностей на ![y](https://habrastorage.org/getpro/habr/upload_files/d04/13f/baa/d0413fbaa50cbf54098cfddaa3df002c.svg).

**Пример 2.** Иногда мы знаем, что распределение ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/324/96e/89e/32496e89e387664197bfec43cc3b7355.svg) [гетероскедастично](https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%82%D0%B5%D1%80%D0%BE%D1%81%D0%BA%D0%B5%D0%B4%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C), то есть дисперсия ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/b5b/980/63d/b5b98063dffc00aa4d478454b6537a44.svg) непостоянна и зависит от ![x](https://habrastorage.org/getpro/habr/upload_files/67b/a40/92a/67ba4092a8538b019dbdecfb7c5633b6.svg). Например, пусть ![x](https://habrastorage.org/getpro/habr/upload_files/c08/953/da0/c08953da04d6b843b2164aab38c39e00.svg) - доходы, а ![y](https://habrastorage.org/getpro/habr/upload_files/cb0/b1a/f30/cb0b1af30fa556382070d5b169e3ddcc.svg) - расходы человека на питание. Понятно что в среднем ![y](https://habrastorage.org/getpro/habr/upload_files/72c/a29/377/72ca293775fff9bc2b97558cc291fc61.svg) растет с ростом ![x](https://habrastorage.org/getpro/habr/upload_files/fed/bfd/25a/fedbfd25a276b5f0faa6aa2e5e96f927.svg), но дисперсия ![y](https://habrastorage.org/getpro/habr/upload_files/36e/1b1/346/36e1b13461a03a2bce0ffae909b39358.svg) также растет: более богатый человек может тратить на еду много, а может тратить мало, в зависимости от предпочтений, тогда как более бедный человек скорее всего тратит мало. Поэтому в формуле (2) мы можем сделать дисперсию тоже функцией от ![x](https://habrastorage.org/getpro/habr/upload_files/91b/e66/d1d/91be66d1d8e011fcc7a8b85ae288fb35.svg). Например, если мы используем нейронную сеть, то пусть она имеет 2 выходных нейрона: один нейрон предсказывает мат. ожидание нормального распределения для ![y](https://habrastorage.org/getpro/habr/upload_files/bde/306/992/bde30699299766cf859a0abb9ebae9cd.svg), а другой нейрон предсказывает дисперсию. Такой способ называется регрессией с оценкой (не)уверенности, в последнем разделе мы рассмотрим его подробнее. Пока что вы можете попробовать сами вывести требуемые формулы.

### 2.5. Функция потерь Хьюбера*

Часто мы используем нормальное распределение для ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/687/dcc/2ac/687dcc2acd51f10ffb16df4f1710665a.svg). Обоснован ли этот выбор? Иногда да. По [центральной предельной теореме](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0), если некая случайная величина ![y](https://habrastorage.org/getpro/habr/upload_files/1e6/87b/9af/1e687b9af211219c4df09e6a5a57ef65.svg) является суммой множества независимых случайных факторов, и каждый фактор вносит исчезающе малый вклад в сумму, то величина ![y](https://habrastorage.org/getpro/habr/upload_files/e38/598/8e7/e385988e7d826bbfe888024430f10b14.svg) распределена приблизительно нормально, что говорит о комбинаторной природе нормального распределения. Например, сумма большого числа независимых величин, каждая из которых с вероятностью 0.5 принимает значение +1 или -1, распределена приблизительно нормально, что замечательно демонстрирует игрушка [Galton Board](https://en.wikipedia.org/wiki/Galton_board):

В реальности многие величины распределены приблизительно нормально. Однако распределения, которые встречаются в реальном мире, часто имеют более [тяжелые хвосты](https://en.wikipedia.org/wiki/Heavy-tailed_distribution), то есть большую вероятность встретить крайние значения. Скажем, рост или вес человека в популяции распределен приблизительно нормально, но рекордсмены по росту или весу (в ту или иную сторону) встречаются намного чаще, чем если бы распределение было строго нормальным.

Поэтому разумно было бы моделировать ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/cc5/347/b4c/cc5347b4c72b6c39ea76b1926b822c84.svg) распределением, похожим на нормальное, но с более тяжелыми хвостами. Это снизило бы влияние выбросов. Например, распределение Лапласа имеет более тяжелые хвосты, чем нормальное распределение. Мы можем "склеить" эти два распределения, взяв центральную часть от нормального распределения и хвосты от распределения Лапласа. Если далее вывести функцию потерь по формуле (6) как минус логарифм плотности вероятности, то получим часто используемую функцию потерь Хьюбера. Эта функция потерь имеет гиперпараметр ![\delta](https://habrastorage.org/getpro/habr/upload_files/86c/d16/4bb/86cd164bb009cfec7fea0a3e3f085e36.svg). Она не так сильно "штрафует" большие выбросы, как среднеквадратичная ошибка.

![\text{Huber}(y, \hat{y}) = \begin{cases}\frac{1}{2} (y - \hat{y})^2,& \text{if } |y - \hat{y}| \leq \delta\\\delta (|y - \hat{y}| - \frac{1}{2} \delta),& \text{otherwise}\end{cases} \tag{8}](https://habrastorage.org/getpro/habr/upload_files/5fd/305/3c7/5fd3053c7695cdbad282140db650b3c6.svg)

В целом, из формулы (5) видно, что функция потерь равна минус логарифму плотности вероятности для выбранного распределения. На самом деле графики плотности для многих распределений удобнее смотреть в логарифмическом масштабе по вертикальной оси. Например, нормальное распределение в логарифмическом масштабе выглядит как парабола с направленными вниз ветвями, а распределение Лапласа в логарифмическом масштабе выглядит как функция ![-|x|](https://habrastorage.org/getpro/habr/upload_files/d65/950/e6b/d65950e6b828f8e2181912ec4c0361fd.svg). Зеркально отразив эти графики по оси ![x](https://habrastorage.org/getpro/habr/upload_files/a2f/367/5d5/a2f3675d58ca149dda86d77a9e734a23.svg), мы увидим график функции потерь. Скомбинировав нормальное распределение с хвостами от распределения Лапласа, получаем функцию потерь Хьюбера.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/55c/9b9/52e/55c9b952ed1aa8af2a37d225dbd1d19a.png)

Интересно, что функцию потерь Хьюбера можно рассматривать как среднеквадратичную ошибку + gradient clipping, применяемый к градиенту функции потерь по ![\hat{y}](https://habrastorage.org/getpro/habr/upload_files/c04/0c2/4dc/c040c24dceb515eda58de9278c023598.svg). Gradient clipping означает, что если при обратном проходе ![\partial loss / \partial \hat{y}](https://habrastorage.org/getpro/habr/upload_files/d6d/1fc/b4f/d6d1fcb4f0093983f8104a6f64f6e3d0.svg) по модулю больше некоего порога ![\delta](https://habrastorage.org/getpro/habr/upload_files/e2f/1ee/4d6/e2f1ee4d67cb2f1369ddd83161cf0390.svg), то он обрезается до этого порога:

![\cfrac{\partial loss(y, \hat{y})}{\partial \hat{y}} := clip \Big( \cfrac{\partial loss(y, \hat{y})}{\partial \hat{y}}, -\delta, \delta \Big)](https://habrastorage.org/getpro/habr/upload_files/805/6c2/f27/8056c2f2743e600f21d54feceae6ce2c.svg)

Gradient clipping также применяется при обучении нейронных сетей, но в этом случае он действует не на градиент по ![\hat{y}](https://habrastorage.org/getpro/habr/upload_files/52e/377/30c/52e37730c9068222b738d55cbc105ca7.svg), а на градиент по весам.

## 3. Вероятностное распределение данных

### 3.1. Понятие распределения данных

Как правило считается, что обучающие и тестовые данные берутся из одного и того же совместного распределения ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/6b9/a93/eb4/6b9a93eb4613ed0eb6a82e980ce3f0a7.svg), называемого _распределением данных_ или _генеральной совокупностью_. Говоря о распределении ![p(x)](https://habrastorage.org/getpro/habr/upload_files/dd6/7af/7f5/dd67af7f5e6d753939ae02c08923dfd6.svg) или ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/a2a/b47/a15/a2ab47a151253831d96409b0e3a016b3.svg), мы условно предполагаем наличие некоего "бесконечного генератора пар ![(x, y)](https://habrastorage.org/getpro/habr/upload_files/136/973/b51/136973b514e897470a100953650d3d70.svg)", из которого взяты обучающая и тестовая выборка.

Конечно, генеральная совокупность данных - это условность, и вопрос ее близости к истине довольно философский. Обычно мы имеем лишь конечную выборку данных, добытую тем или иным способом, но не имеем строгого определения для ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/b59/0eb/ef0/b590ebef015c64aca8928b459579225c.svg). Но в целом мы считаем, что ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/e52/1b0/9bc/e521b09bcf248a2ad7160870dcae4f0b.svg) наиболее велико для "типичных" пар ![(x, y)](https://habrastorage.org/getpro/habr/upload_files/057/a62/dc3/057a62dc3400607fb12abe4470ea3fcc.svg), и равно нулю для невозможных пар (в которых либо ![p(x)=0](https://habrastorage.org/getpro/habr/upload_files/d14/eb5/529/d14eb5529827d6472911877dbaf5bc2e.svg), либо ![p(y|x)=0](https://habrastorage.org/getpro/habr/upload_files/618/c8d/6b7/618c8d6b791e8d40fb509ebee20eb288.svg)).

Например, пусть мы имеем датасет из объявлений о продаже автомобилей. Для нашего датасета верно, например, следующее:

- Количество авто "Lada Granta" превосходит количество авто "Москвич-412"
    
- Количество авто "Победа" с двигателем мощностью 500 л. с. равно нулю
    

Тогда мы можем считать датасет выборкой из распределения, в котором для ![p(x)](https://habrastorage.org/getpro/habr/upload_files/574/f54/859/574f548595dc32a3a8b2a4738300cb59.svg) верно следующее:

- ![p(x|\text{марка}(x) = \text{"Lada Granta"}) > p(x|\text{марка}(x) = \text{"Москвич-412"})](https://habrastorage.org/getpro/habr/upload_files/453/557/448/4535574480427d49dc355846deef707f.svg)
    
- ![p(x|\text{марка}(x) = \text{"Победа"}\ \&\ \text{мощность}(x) \approx \text{"500 л. с."}) \approx 0](https://habrastorage.org/getpro/habr/upload_files/ce4/39d/c08/ce439dc080922a3d1d431245b2a5444a.svg)
    

Если распределение ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/7ea/9e5/084/7ea9e5084d3ee5023c9b62cd795e84c5.svg) невырождено (то есть не назначает всю вероятность одной точке), то это значит, что ![y](https://habrastorage.org/getpro/habr/upload_files/f1d/3bd/f22/f1d3bdf222dd11d2e5715699725d18bd.svg) не может быть однозначно определен из ![x](https://habrastorage.org/getpro/habr/upload_files/89d/4c3/dce/89d4c3dce46a897da249d6991ffa83b8.svg), но может быть определен приблизительно.

### 3.2. Дискриминативные модели

Запишем одну из базовых формул теории вероятностей:

![p(x, y) = p(y|x)p(x) \tag{9}](https://habrastorage.org/getpro/habr/upload_files/60e/7a1/215/60e7a12152c5c067a3ce549ea9471d15.svg)

Модели, которые моделируют ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/104/46f/9c5/10446f9c54b765217666d93368952682.svg), то есть ищут некое приближение для истинного ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/f68/a82/308/f68a82308ea7947dfac8831f995b9b5b.svg), называют _дискриминативными моделями_. Иногда используют другую терминологию: [Murphy, 2023](https://probml.github.io/pml-book/book2.html) называет модели ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/c2e/a33/689/c2ea336894d627e2d9c13f275066d4d8.svg) _предиктивными моделями_, которые делятся на дискриминативные (классификация) и модели регрессии.

Важная особенность всех таких моделей в том, что они не моделируют вероятность входных данных ![p(x)](https://habrastorage.org/getpro/habr/upload_files/4ae/69d/43b/4ae69d43b73ca7e19bda6ce77af544e8.svg). Это означает, что дискриминативная модель не может оценить то, насколько реалистичны входные данные. Например, мы могли обучать нейронную сеть распознавать животных на фотографиях. Получив на вход изображение с "белым шумом", сеть тоже выдаст какой-то ответ (скорее всего, с высокой уверенностью предскажет одно из животных) и никак не сможет сказать вам, что фотография вообще не является животным.

### 3.3. Генеративные модели*

Кроме дискриминативных, существуют еще _генеративные модели_ - в статистике так называются модели, которые моделируют распределение для всех используемых переменных, то есть ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/466/4c7/0e5/4664c70e5b6b816f36b16eb49e3dcd8b.svg), либо ![p(x)](https://habrastorage.org/getpro/habr/upload_files/02c/17f/07b/02c17f07bba58665a396e0e810d2a529.svg), если ![y](https://habrastorage.org/getpro/habr/upload_files/e19/eca/139/e19eca1396e47a781ecb97fb7edadccc.svg) отсутствует. Иногда "генеративными моделями" также называют модели, способные генерировать что-то сложное, вроде картинок или текста - это близко к предыдущему определению, но не всегда одно и то же, так что здесь есть неоднозначность в терминологии. В целом, генеративные модели - это тема для отдельной статьи. Подробно о генеративных моделях можно почитать в книге [Murphy, 2023](https://probml.github.io/pml-book/book2.html), раздел 20 и далее. Дискриминативные модели рассматриваются там же в разделе 14 и далее.

С одной стороны кажется, что в задаче предсказания ![y](https://habrastorage.org/getpro/habr/upload_files/496/d9b/a94/496d9ba9469066d5bf0468a85981ed14.svg) по ![x](https://habrastorage.org/getpro/habr/upload_files/99e/213/178/99e2131781850e7eeaaa213c4e3481d5.svg) "информативность" модели растет в ряду: ![f(x) < p(y|x) < p(x, y)](https://habrastorage.org/getpro/habr/upload_files/b09/879/dd1/b09879dd1e2170b5b227180606ce2d66.svg), поскольку имея ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/3dd/7f6/2b0/3dd7f62b0853939e70f71fde6cd1e4f1.svg) мы можем рассчитать ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/0f7/1f3/1c9/0f71f31c9704f2f79a4fd712a016fca0.svg), а имея ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/fd2/40b/643/fd240b643b323af0c7565f7e8e14b056.svg) мы можем получить точечную оценку ![f(x)](https://habrastorage.org/getpro/habr/upload_files/0b6/619/7b3/0b66197b3bef2a6b0abeee2aff512a9c.svg), но не наоборот.

![p(y|x) = \cfrac{p(x, y)}{p(x)} = \cfrac{p(x, y)}{\int\limits_{y \in Y} p(x, y)}](https://habrastorage.org/getpro/habr/upload_files/72e/5cd/81f/72e5cd81fa4c1757b43d2a61f00f9b6e.svg)

Но здесь не учитываются некоторые тонкости. Моделировать ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/86e/3c3/8c4/86e3c38c41086e1bdd0db1369b552389.svg) можно по-разному, например, одна модель может оценивать для любой пары ![(x, y)](https://habrastorage.org/getpro/habr/upload_files/c72/d6f/005/c72d6f00541e8495325d2c046b37eff1.svg) плотность вероятности ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/e07/c79/edb/e07c79edb5217cd738edebb931d7318f.svg), а другая модель не имеет такой возможности, но позволяет вычислительно эффективно семплировать пары ![(x, y)](https://habrastorage.org/getpro/habr/upload_files/ee4/4de/11d/ee44de11d06dfe5b16e6eac38858074c.svg) из совместного распределения. Если бы мы имели бесконечные вычислительные ресурсы, то эти случаи были бы эквивалентны (то есть умея оценивать плотность вероятности мы могли бы семплировать, и наоборот), но на деле вычислительные ресурсы ограничены, и эти случаи различаются. Если наша модель ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/119/c79/476/119c794763f2e74e46deedcef95b852e.svg) может только семплировать пары ![(x, y)](https://habrastorage.org/getpro/habr/upload_files/862/38a/a8e/86238aa8e21a1212fbed3c9a8bda1682.svg), то задача оценки ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/5f4/3af/482/5f43af4822d597d57dfdb0d65c8912e8.svg) может стать невыполнимой.

### 3.4. i.i.d.-гипотеза и качество обобщения

Часто выборку данных рассматривают как выборку из независимых и одинаково распределенных величин (independent and identically distributed, **i.i.d.**). Это означает, что каждый пример ![(x_i, y_i)](https://habrastorage.org/getpro/habr/upload_files/d20/0b9/b41/d200b9b415b97c247c0b16589bc2b57e.svg) из обучающей и тестовой выборки является случайной величиной, взятой из некоего общего распределения ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/784/f4b/240/784f4b2409f811077c431ea28fad3d6c.svg). Отсюда автоматически следует, что все примеры независимы друг от друга.

![\forall i: (x_i, y_i) \sim p(x, y) \tag{10}](https://habrastorage.org/getpro/habr/upload_files/078/25c/bf6/07825cbf6df2c0a9b2ed20d135d4ed5d.svg)

По моему мнению, данная гипотеза сочетает в себе "блеск и нищету" машинного обучения. С одной стороны, она позволяет формализовать задачу машинного обучения как максимизация ожидаемой метрики качества ![L(y, \hat{y}(x))](https://habrastorage.org/getpro/habr/upload_files/598/3a7/b17/5983a7b174ce6adfb5c7746be331f3b9.svg) на всем распределении данных (подробнее можно почитать, например, [здесь](https://www.cs.cornell.edu/courses/cs4780/2018fa/lectures/lecturenote01_MLsetup.html)):

![\text{(quality of model f)} = \mathop{\mathbb{E}}\limits_{x, y \sim p} L(y, f(x)) = \int\limits_{X, Y} p(x, y) L(y, f(x)) \to \underset{\theta}{\text{max}} \tag{11}](https://habrastorage.org/getpro/habr/upload_files/750/e2c/b9c/750e2cb9cdbd9d86b5f9e6b0b60e9095.svg)

i.i.d.-гипотеза дает очень простой способ оценки качества модели: достаточно разделить данные на train и test, и поскольку примеры в test взяты из того же распределения, что и train, то оценка качества модели на test является оценкой Монте-Карло для ожидаемой метрики на всем распределении данных.

![\text{(quality of model f)} \approx \cfrac{1}{N} \sum\limits_{i=1}^N L(y_i, f(x_i)), \ \ \ \ (x_i, y_i) \sim p \tag{12}](https://habrastorage.org/getpro/habr/upload_files/7bc/900/2ca/7bc9002ca488cb94a940e2ec8dd118f7.svg)

При большом размере тестовой выборки ![N](https://habrastorage.org/getpro/habr/upload_files/fca/bcb/6d2/fcabcb6d279762c724cb175238f11fa2.svg) эта оценка будет достаточно точной. Правда, бывают исключения, когда даже при большом размере тестовой выборки оценка качества будет иметь большую погрешность. Это может происходить в том случае, когда влияние отдельных примеров на метрику качества сопоставимо с суммой влияния всех остальных примеров: например в случае несбалансированных классов или сильных выбросов.

В случае регрессии формула (12) обычно подразумевает точечную оценку для ![y](https://habrastorage.org/getpro/habr/upload_files/e7c/9f3/5fa/e7c9f35fae97f578d19d14364ee00991.svg), а не распределение вероятностей. Если же модель выдает распределение вероятностей ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/e02/559/470/e025594704d18f5decb5cc72fd22797d.svg), то мы легко можем преобразовать его в точечную оценку. Например, если целевая метрика ![L](https://habrastorage.org/getpro/habr/upload_files/a8f/5b7/100/a8f5b71006d50f76a90bf3c430a107a0.svg) - среднеквадратичное отклонение, то нужно взять мат. ожидание ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/653/d5e/9fa/653d5e9fa83d4fe03a62b7ac67841e51.svg), если же целевая метрика - среднее абсолютное отклонение, то нужно взять медиану (подробнее см., например, [здесь](https://math.stackexchange.com/questions/85448/why-does-the-median-minimize-ex-c)).

### 3.5. Проблемы i.i.d.-гипотезы*

В простоте оценки качества заключается внешний "блеск" i.i.d.-гипотезы, за которым часто скрывается "нищета". Дело в том, что она часто не выполняется: обучающая выборка и та выборка, на которой модели предстоит работать по назначению, часто оказываются распределены по-разному.

Например, это практически неизбежно в кредитном скоринге: нам нужно предсказать вероятность того, что заемщик не вернет кредит, то обучающие данные собираются только по тем заемщикам, которым ранее выдали кредит. Если раньше в банке не выдавали кредиты людям моложе 20 лет, то такие люди не попадут в обучающее распределение данных. Модель может не научиться корректно работать на таких примерах. Если тестовая выборка была случайно отделена от обучающей, то на ней эта проблема никак не будет заметна, но при работе модели по назначению такие люди, конечно, будут часто встречаться. О способах решения данной проблемы в кредитном скоринге можно почитать, например, в [Ehrhardt et al., 2021](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9041715/).

Часто бывают ситуации, когда обучающее распределение ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/f37/7c0/a22/f377c0a223aa5bfc3086f2db7e63028b.svg) менее разнообразно (чем то, на котором модели предстоит работать), содержит паразитные корреляции, и избавиться от этого иногда не представляется возможным. Отсюда возникают проблемы сдвига и утечки данных. Подробно и с большим количеством примеров я рассказывал об этом в статье "[Проблемы современного машинного обучения](https://habr.com/ru/company/ods/blog/651103/)".

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c72/dd9/12f/c72dd912f8b8b6e74aa9df8732b58e4d.png)

В целом понятие "обучения" является более широким, чем задача максимизации метрики (11), особенно когда дело касается обучения агентов (роботов, ботов в компьютерных играх и т. д). Во многом обучение связано с умением выявлять причинно-следственные связи ([Pearl, 2009](http://bayes.cs.ucla.edu/BOOK-2K/)), что помогает функционировать в изменяющейся среде и не обращать внимание на нерелевантные детали окружающей среды. Например, робот, который метко бросает мяч в корзину в лаборатории, но впадает в ступор на уличной площадке из-за того, что корзина стала другого цвета, вряд ли будет полезен. Но способность выявлять причинно-следственные связи никак не связана с максимизацией метрики (11), да и само понятие "распределения данных" часто неоднозначно, поскольку обычно источник данных не является генератором независимых и одинаково распределенных примеров.

Таким образом, i.i.d.-обучение, то есть любые методы, целью которых является максимизация метрики (11), имеет свои границы применимости. Во многих случаях, когда очевидно что i.i.d.-гипотеза неверна, применяют другие подходы (например, [марковские цепи](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BF%D1%8C_%D0%9C%D0%B0%D1%80%D0%BA%D0%BE%D0%B2%D0%B0), [авторегрессионные модели](https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D1%80%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C) для прогнозирования временных рядов). Но существуют и пограничные случаи, когда непонятно можно ли применять i.i.d.-обучение. На мой взгляд, в табличных задачах слишком часто полагаются на i.i.d.-гипотезу. Возможно, что когда-нибудь в табличном ML в обиход войдут новые (или "хорошо забытые старые") подходы, которые могут учесть [зависимость](https://bookdown.org/rdpeng/timeseriesbook/residual-autocorrelation.html) примеров друг от друга, например, с помощью латентных переменных или теории информации.

## 4. Статистические модели

В первой части мы рассмотрели метод максимизации правдоподобия, но за кадром остался вопрос о том, почему мы максимизируем именно произведение вероятностей, а не их сумму. В этой части мы еще вернемся к этому методу, используя материал из второй части, и соединим все элементы пазла в единую картину, введя понятие статистической модели и вероятности обучающей выборки.

### 4.1. Простые статистические модели

Статистический вывод (statistical inference) занимается оценкой неизвестных параметров распределений. Пусть у нас есть данные, которые являются выборкой из неизвестного распределения. Нам нужно ответить на вопрос - из какого распределения они получены? Мы вводим набор "распределений-кандидатов", который называется _статистической моделью_. Рассмотрим несколько примеров:

**Пример 1.** У нас есть набор чисел ![X = \{x_1, \dots, x_n\}](https://habrastorage.org/getpro/habr/upload_files/36c/be7/f7d/36cbe7f7dca8e1e12b1adcd00437a356.svg). Мы знаем, что эти числа являются i.i.d.-выборкой из нормального распределения, его дисперсия равна 1, а среднее неизвестно (его нужно оценить из данных). Тогда наша статистическая модель ![\mathcal{M}](https://habrastorage.org/getpro/habr/upload_files/d30/365/2fa/d303652fabb339d0c0e23ec409379abe.svg) - это множество всех одномерных нормальных распределений с дисперсией 1 и всеми возможными значениями среднего:

![\mathcal{M} = \{ \mathcal{N}(\mu, \sigma^2=1) | \mu \in R\} \tag{14}](https://habrastorage.org/getpro/habr/upload_files/ab8/add/789/ab8add7895a57d5377ee0b91741f6642.svg)

Возьмем любое распределение из множества ![\mathcal{M}](https://habrastorage.org/getpro/habr/upload_files/40d/55b/a9a/40d55ba9aa66504f5a263c28aab3f066.svg). Поскольку нам известно, что все примеры в выборке независимы, то плотность вероятности всей выборки ![p(X)](https://habrastorage.org/getpro/habr/upload_files/74a/e41/5dd/74ae415ddb3502653c4310018e34b489.svg) равна произведению плотностей вероятностей для всех примеров:

![p(X) = \prod\limits_{i=1}^N p(x_i) =  \prod\limits_{i=1}^N \mathcal{N}(x_i | \mu, 1) \tag{15}](https://habrastorage.org/getpro/habr/upload_files/00e/ac0/796/00eac0796742723e368891caf02cb705.svg)

Отсюда, зная ![\mu](https://habrastorage.org/getpro/habr/upload_files/d5d/37d/9ee/d5d37d9ee3dbcf91c9330f3e0ee67e08.svg), мы можем рассчитать ![p(X)](https://habrastorage.org/getpro/habr/upload_files/f9a/a14/a95/f9aa14a95f8982097846639e8f68a566.svg). Это значит, что для любого распределения из множества ![\mathcal{M}](https://habrastorage.org/getpro/habr/upload_files/15e/4ae/e74/15e4aee74b93122b51df0a88387ab570.svg) мы можем рассчитать ![p(X)](https://habrastorage.org/getpro/habr/upload_files/fae/287/ba3/fae287ba31c3f53648f992171eb8b2bf.svg). Теперь просто выберем из множества ![\mathcal{M}](https://habrastorage.org/getpro/habr/upload_files/433/73f/a2c/43373fa2c0bb1b5c7cdf61e63599b8ef.svg) то распределение, для которого ![p(X)](https://habrastorage.org/getpro/habr/upload_files/005/6fd/8a1/0056fd8a10acc22fcd71be755e5eb4f8.svg) максимально. Для этого нужно просто подставить формулу нормального распределения в (15) и отыскать максимум полученного выражения по ![\mu](https://habrastorage.org/getpro/habr/upload_files/cc0/20a/7a1/cc020a7a1681aa82494cd490548bffd2.svg) (формулы подробно расписывать здесь не будем). Это и есть метод максимизации правдоподобия.

**Пример 2.** Аналогично предыдущему примеру, но мы не знаем ни среднее, ни дисперсию. Тогда наша статистическая модель - это множество всех одномерных нормальных распределений:

![\mathcal{M} = \{ \mathcal{N}(\mu, \sigma^2) | \mu \in R, \sigma^2 \in R^+\} \tag{16}](https://habrastorage.org/getpro/habr/upload_files/b44/bde/5f7/b44bde5f7b25ba6b06036c64a094d0fa.svg)

Здесь метод максимизации правдоподобия можно выполнить полностью аналогично, только формулы получатся сложнее.

Таким образом, статистическая модель ничего не говорит об оптимальных значениях параметров, а лишь описывает среди какого множества распределений ![\mathcal{M}](https://habrastorage.org/getpro/habr/upload_files/f6d/27a/ad7/f6d27aad749d7c73fd11d55049e541d0.svg) мы выполняем поиск. Сам поиск может выполняться методом максимизации правдоподобия, как в предыдущих примерах. Однако такой подход не всегда хорошо работает, есть и другие методы (байесовский вывод и его аппроксимации), их мы рассмотрим в следующих частях.

На какие "подводные камни" мы можем натолкнуться, используя метод максимизации правдоподобия? Их несколько.

**Проблема 1.** На самом деле распределение, из которого пришла выборка ![X](https://habrastorage.org/getpro/habr/upload_files/394/282/36f/39428236f459614ba457df6e2c80f808.svg) может не быть нормальным. Вообще, практически ни одно из распределений реального мира не является [строго нормальным](https://en.wikipedia.org/wiki/Normal_distribution#Exact_normality) (кроме, наверное, квантовой механики). Значит ли это что наша модель неверна? Строго говоря да. Но если искомое распределение хорошо аппроксимируется нормальным, то выполнив аппроксимацию мы практически ничего не потеряем. То есть, наша модель ![\mathcal{M}](https://habrastorage.org/getpro/habr/upload_files/6c6/361/e37/6c6361e37e2e2d7a34812a769106e9d3.svg) может не содержать искомого распределения, но если элементами из ![\mathcal{M}](https://habrastorage.org/getpro/habr/upload_files/b82/19e/ba5/b8219eba51ded87c278fada03249672e.svg) можно его хорошо аппроксимировать - этого уже достаточно (если же нельзя - говорят о "model misspecification"). Вообще, модель - это некое приближение реальности. Она может быть не идеально точна, но все равно полезна: вся наука и инженерия основаны на моделях как упрощениях наблюдаемых явлений. Как [говорил](https://en.wikipedia.org/wiki/All_models_are_wrong) один из статистиков, "all models are wrong, but some are useful".

**Проблема 2.** Выборка может не быть независимой и одинаково распределенной (i.i.d.). Например, она может быть результатом двухступенчатного семплирования или даже временным рядом, то есть выборкой из ![p(x, t)](https://habrastorage.org/getpro/habr/upload_files/d17/410/fa9/d17410fa9d89d2f3bccb356dc4d8b8a2.svg), где ![t](https://habrastorage.org/getpro/habr/upload_files/ac4/04d/0e8/ac404d0e873dc79432e1d6dea0ddaefe.svg) - время, разное для разных семплов. Здесь опять получается, что наша модель ![\mathcal{M}](https://habrastorage.org/getpro/habr/upload_files/f6b/6b1/c38/f6b6b1c381b84a54af969ac446e56926.svg) неверна, но она все равно может быть полезна, если зависимостью от ![t](https://habrastorage.org/getpro/habr/upload_files/5d2/d2b/d1f/5d2d2bd1ffeab3f21b450ab6af8986d9.svg) можно пренебречь. Если же ей принебречь нельзя, то нужно использовать другие методы, такие как прогнозирование временных рядов. Они тоже могут быть основаны на теории вероятностей, но i.i.d.-гипотеза в них не используется.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/0b5/75d/b78/0b575db787266265148e70f76acb3def.png)

**Проблема 3.** Мы можем заранее иметь предположения о том, какие значения параметров более вероятны, а какие менее вероятны. В этом случае метод максимизации правдоподобия применять не стоит, поскольку он не учитывает эту информацию. В следующей части мы рассмотрим байесовский вывод, который позволяет ее учесть.

**Проблема 4.** Если мы будем искать не 1-2 параметра (![\mu](https://habrastorage.org/getpro/habr/upload_files/daf/d15/c53/dafd15c5386987f7a6254f988bfaa372.svg), ![\sigma](https://habrastorage.org/getpro/habr/upload_files/b3e/290/e8b/b3e290e8b9fa43c1609b80e490bec2dd.svg)), а, скажем, 100 параметров, а в нашей выборке всего 10 семплов, то наверное этих семплов недостаточно. Мы легко сможем подогнать параметры под данные, и мы даже сможем найти много разных значений параметров, одинаково хорошо подогнанных под данные. Но некоторые из таких значений параметров будут очень плохо соответствовать всему распределению данных, при хорошем соответствии выборке. Таким образом, в методе максимизации правдоподобия возникает проблема переобучения ([1](https://stats.stackexchange.com/questions/261056/why-does-maximum-likelihood-estimation-have-issues-with-over-fitting), [2](https://stats.stackexchange.com/questions/376808/maximum-likelihood-estimators-and-overfitting), [3](https://stats.stackexchange.com/questions/82664/bayesian-vs-mle-overfitting-problem)).

В третьей части мы рассмотрим байесовский подход, с точки зрения которого метод максимума правдоподобия является лишь аппроксимацией полного байесовского вывода. При этом чем сложнее модель и меньше данных, тем менее точной получается аппроксимация, что и является причиной переобучения. Полный байесовский вывод часто невозможно выполнить ввиду огромной вычислительной сложности, но существуют его более точные аппроксимации: ансамблирование, вариационный вывод и другие методы.

## 4.2. Статистические модели в машинном обучении

В предыдущем разделе мы рассмотрели статистическую модель как параметризованное семейство распределений. Тот же подход можно применить в машинном обучении.

Модель машинного обучения (такую как линейная регрессия, случайный лес, нейронная сеть) можно рассмотреть как параметризованную функцию. С помощью этой функции мы оцениваем параметры распределения ![y](https://habrastorage.org/getpro/habr/upload_files/1ae/ce0/700/1aece07003b5fec783f4ade23eab53c0.svg). Например, пусть мы предполагаем, что условное распределение ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/d50/fb3/e46/d50fb3e465c09e91a073b11515d710d4.svg) является нормальным распределением с ![\sigma^2=1](https://habrastorage.org/getpro/habr/upload_files/9c5/36b/c76/9c536bc76d643d210a1187cf3cbdbb83.svg) и мат. ожиданием, зависящим от ![x](https://habrastorage.org/getpro/habr/upload_files/cd2/c33/4bd/cd2c334bddfc286cca7683c2c9138dad.svg). За ![\Theta](https://habrastorage.org/getpro/habr/upload_files/91e/acb/fac/91eacbfac69a0c31b8777ca4333e898c.svg) обозначим множество всех возможных значений параметров. Наша статистическая модель будет иметь следующий вид:

![\mathcal{M} = \{\mathcal{N}(\mu = f(x, \theta), \sigma^2=1) | \theta \in \Theta \} \tag{17}](https://habrastorage.org/getpro/habr/upload_files/2be/8da/3be/2be8da3be50163242a291aa6cb00adbd.svg)

У нас есть набор пар ![(x, y)](https://habrastorage.org/getpro/habr/upload_files/f7e/6ea/fca/f7e6eafcad05672db618f61fc60c3d3f.svg), и мы предполагаем, что они являются i.i.d.-выборкой из некоего распределения ![p(x, y)](https://habrastorage.org/getpro/habr/upload_files/5fd/697/9eb/5fd6979eb63a9336eb56cbccba5a7d02.svg). Это предположение мы подробно рассматривали во второй части. Все, то нам осталось сделать - найти такие параметры ![\theta \in \Theta](https://habrastorage.org/getpro/habr/upload_files/f73/6fa/191/f736fa191909a257be135753eb3eb4d7.svg), чтобы вероятность обучающей выборки была максимальна: Поскольку мы предполагаем, что все примеры независимы друг от друга (i.i.d.), то по базовым законам теории вероятностей вероятность выборки равна произведению вероятностей всех примеров, так же как в формуле (5). Именно поэтому в разделе 2 мы максимизировали произведение вероятностей (а не, например, сумму или минимум).

Все остальное ними уже было рассмотрено ранее: осталось сформулировать задачу оптимизации (5-7) и итеративно решить каким-либо способом (для нейронных сетей - градиентным спуском, для случайного леса - построением новых деревьев и т. д.), найдя оптимальные значения параметров ![\theta](https://habrastorage.org/getpro/habr/upload_files/40e/a40/372/40ea40372e0c057058fd1286188a6125.svg), максимизирующие вероятность выборки.

Как видим, здесь есть полная аналогия с простыми статистическими моделями, которые мы рассмотрели в предыдущем разделе. Вместе с этим мы получаем те же самые три подводных камня, основным из которых часто является переобучение: существует множество значений параметров, дающих очень малую ошибку на train и высокую ошибку на test, и процесс оптимизации часто сходится именно к таким решениям.

Зачем нам нужны были сложности с логарифмом, и почему нельзя напрямую максимизировать вероятность ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/ab4/60c/5ac/ab460c5ac29eec7c57a80c05373c5594.svg)? Пожалуй, мы могли бы так сделать. Но во-первых, в случае нормального распределения взятие логарифма упрощает формулы (5-7). Во-вторых, в этом случае мы должны максимизировать уже не сумму, а произведение величин ![p(y|x, \theta)](https://habrastorage.org/getpro/habr/upload_files/f58/1ab/786/f581ab786fbe52d3cb6fc6d1eed5241d.svg) по всем примерам (5). Оптимизация произведения сотен и тысяч множителей может быть численно нестабильной и вызывать переполнение float. В-третьих, для оптимизации суммы большого количества слагаемых существуют методы стохастической оптимизации с доказанной эффективностью, тогда как для оптимизации произведения большого количества множителей аналогичных методов может не быть.

Казалось бы, мы уже рассмотрели много формул и терминов, но от проблемы переобучения никуда не делись, и вообще переход к вероятностной постановке задачи не принес осоой пользы (кроме регрессии Пуассона). Пока что это действительно так. Фундамент дома сам по себе не приносит пользы: жить в нем ничуть не более удобно, чем в вагончике на стройке. В следующих разделах мы рассмотрим как вероятностная постановка задач классификации и регрессии помогает задавать функцию потерь в сложных случаях, когда данные размечены несколькими аннотаторами по-разному, либо когда нам нужно оценивать уверенность в задаче регрессии. В следующей части рассмотрим байесовский вывод, который основывается на материале данной части.

## 5. Регрессия с оценкой уверенности*

## 5.1. Моделирование дисперсии в модели регрессии*

В разделе части 1 мы рассмотрели вариант модели регрессии, в котором ![p(y|x)](https://habrastorage.org/getpro/habr/upload_files/086/504/eae/086504eae438a605912b79456ef3162f.svg) моделируется нормальным распределением, для которого мат. ожидание предсказывается с помощью ![x](https://habrastorage.org/getpro/habr/upload_files/216/aa4/d11/216aa4d11f55eb7ad01a90fc7dcc43c7.svg), а дисперсия является константой. Но нам ничего не мешает предсказывать и дисперсию. Для этого нужно, чтобы модель регрессии выдавала не одно, а два числа: ![f_1(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/f90/093/db6/f90093db682f333b8d0a4a808b59842b.svg) и ![f_2(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/67a/806/950/67a806950b344f8ed935fad005a32994.svg). В случае нейронной сети мы можем взять 2 выходных нейрона. В случае градиентного бустинга над решающими деревьями каждый лист каждого дерева может выдавать 2 числа, которые суммируются по всем деревьям.

Но дисперсия не может быть меньше нуля, а модель может выдавать любое число. Поэтому удобнее, чтобы модель выдавала логарифм дисперсии. Ее дополнительно можно умножить на константу ![C](https://habrastorage.org/getpro/habr/upload_files/f46/3ca/223/f463ca2230ce416c67d1734c7fe44685.svg), которая будет гиперпараметром функции потерь. Тогда мат. ожидание целевой переменной ![\mu](https://habrastorage.org/getpro/habr/upload_files/b91/393/a1b/b91393a1bcc82d5ed2be1b5e5b8418db.svg) и ее дисперсия ![\sigma^2](https://habrastorage.org/getpro/habr/upload_files/499/b8a/3e1/499b8a3e1b0dcb5bf13cf105c218b898.svg) выразим через ![f_1](https://habrastorage.org/getpro/habr/upload_files/de3/10f/71a/de310f71ae39564343918506509a1ae7.svg) и ![f_2](https://habrastorage.org/getpro/habr/upload_files/12e/221/598/12e22159832e46648b2b51197ae7afcd.svg) следующим образом:

![\begin{cases}\mu = f_1(x, \theta)\\\sigma^2 = C \exp f_2(x, \theta)\end{cases} \tag{18}](https://habrastorage.org/getpro/habr/upload_files/0fc/877/b61/0fc877b61dea23121d4ee9891fde3c6c.svg)

Так же как и в первой части, мы минимизируем минус логарифм вероятности для каждого примера. Подставив в (6) выражения для ![\mu](https://habrastorage.org/getpro/habr/upload_files/b5f/20a/ec5/b5f20aec5b9605b4b942b4acb789ab69.svg) и ![\sigma^2](https://habrastorage.org/getpro/habr/upload_files/a0c/503/0c5/a0c5030c5e861c95dcc54b53e6e414f0.svg), получим выражение для функции потерь:

![-\log p(y|x, \theta) = \\ \cfrac{(y-f_1(x, \theta))^2}{2 C \exp f_2(x, \theta)} + \cfrac{1}{2} \log C + \cfrac{1}{2} f_2(x, \theta) + \log \sqrt{2 \pi} \tag{19}](https://habrastorage.org/getpro/habr/upload_files/92c/475/e6c/92c475e6c6442821e30ea5a5396b8c41.svg)

Если функцию потерь умножить на константу или сложить с константой, то положение ее локальных и глобальных минимумов не изменится. Поэтому в формуле (19) удалим второе и четвертое слагаемое, которые являются константами. Затем первое и третье слагаемое умножим на 2. Получим упрощенное выражение для функции потерь:

![loss =  \cfrac{(y-f_1(x, \theta))^2}{C \exp f_2(x, \theta)} + f_2(x, \theta) \tag{20}](https://habrastorage.org/getpro/habr/upload_files/7b6/73e/e78/7b673ee78a86135d7c9ca4fd17fccc92.svg)

Мы снова видим среднеквадратичное отклонение, но теперь к нему добавляется дополнительный множитель и дополнительное слагаемое. Высокое значение предсказанной неуверенности ![f_2](https://habrastorage.org/getpro/habr/upload_files/f0c/d79/dd3/f0cd79dd39758c4b367e90d5d8327aae.svg) повышает значение функции потерь за счет второго слагаемого, но при этом уменьшает вклад первого слагаемого, которое штрафует ошибку предсказания ![(y-f_1)^2](https://habrastorage.org/getpro/habr/upload_files/549/b10/817/549b10817b71f974714fa5090d89507a.svg). Это дает модели некий компромисс: модель может предсказывать на каких-то примерах высокую неуверенность, уменьшая штраф от неточного предсказания самого значения ![y](https://habrastorage.org/getpro/habr/upload_files/5fe/15f/892/5fe15f892000eb5d9de877298a4d5b49.svg) на них.

Проверим этот метод на практике, обучив модель на табличном датасете California Housing, в котором нужно предсказывать цену недвижимости в разных районах Калифорнии, имея 8 исходных признаков. В данном случае хорошо работает значение ![C=0.2](https://habrastorage.org/getpro/habr/upload_files/986/abb/49f/986abb49fbb2f04798b3a9bdef536298.svg).

Код

```

```

**Результаты эксперимента**. Мы обучили 10 моделей с простой функцией потерь MSE и еще 10 моделей с оценкой неуверенности. На рисунке слева - динамика изменения MSE на валидации для всех моделей, в зависимости от эпохи обучения. Видно, что наши модели превысили по качеству обычные модели, обучаемые с функцией потерь MSE. Возможно это связано с тем, что снижается переобучение модели на выбросах, так как в областях с частыми выбросами предсказывается высокое значение неуверенности, что смягчает ошибку предсказания мат. ожидания в этих областях, уменьшая множитель при первом слагаемом.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/8bf/892/494/8bf8924942223c936aace87b8d512213.png)

На втором графике взяли одну из моделей с оценкой неуверенности и рассмотрели корреляцию фактической ошибки предсказания с предсказанной неуверенностью (на валидационной выборке). Положительная корреляция говорит о том, что модель в какой-то степени справляется с задачей оценки собственной уверенности в предсказании.

Описанный в этом разделе подход давно применяется в разных задачах (см. например [Nix and Weigend, 1994](https://ieeexplore.ieee.org/document/374138)). Недавно аналогичная функция потерь была реализована в библиотеке градиентного бустинга CatBoost под названием [RMSEWithUncertainty](https://catboost.ai/en/docs/concepts/loss-functions-regression#optimization). Посмотрим как она работает на практике, используя CatBoost версии 1.1.1:

Код

```

```

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/98c/ba2/18c/98cba218c06da83ec101b87873642960.png)

В целом мы видим похожую картину, хотя точность предсказаний CatBoost получилась выше, чем нейронной сети. В CatBoost есть функция для отрисовки деревьев, воспользуемся ей, чтобы нарисовать первое дерево:

```
model.plot_tree(0)
```

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/cb7/bb4/251/cb7bb42514e7e57a6ff20339d8b825de.png)

Каждое звено дерева содержит разделяющее правило, в котором проверяется, что значение указанного признака больше указанного порога. Каждый лист дерева выдает 2 числа: само значение ![y](https://habrastorage.org/getpro/habr/upload_files/0e5/941/f76/0e5941f76e4a881edae3cb22bc3f7131.svg) и уверенность. Оба эти числа суммируются по всем деревьям.

### 5.2. Регрессия с константной оценкой дисперсии*

Вспомним вероятностную модель регрессии, которую мы рассматривали во второй части (2). В ней ![\sigma](https://habrastorage.org/getpro/habr/upload_files/97c/cc2/df9/97ccc2df9361160a19d9531d152cd7bd.svg) является константой. Для любого значения ![\sigma](https://habrastorage.org/getpro/habr/upload_files/d97/565/7d7/d975657d7acd80100f04cfcafe734153.svg) локальные и глобальные минимумы функции потерь одни и те же, и изменение ![\sigma](https://habrastorage.org/getpro/habr/upload_files/b3c/15b/c48/b3c15bc48f1919464c1536dfc8b4a43e.svg) эквивалентно масштабированию функции потерь, что равносильно изменению learning rate. Отсюда получается, что какое бы ![\sigma](https://habrastorage.org/getpro/habr/upload_files/226/cb2/7ad/226cb27adc6e2f8103975035234927f5.svg) мы не брали - ничего не изменится (поскольку learning rate выбирается совсем по другим соображениям). Но что если мы хотим знать реальное ![\sigma](https://habrastorage.org/getpro/habr/upload_files/0eb/d11/bcd/0ebd11bcd148753fe22ac6c290be6697.svg)?

Для этого мы могли бы сделать ![\sigma](https://habrastorage.org/getpro/habr/upload_files/a41/e5a/4f9/a41e5a4f965f984e15569ea9663aa8fa.svg) обучаемым параметром, не зависящим от ![x](https://habrastorage.org/getpro/habr/upload_files/a5a/300/96f/a5a30096f94e28cd1cb273f0f8c7f3d7.svg). Заменим в формуле (28) выражение ![f_2(x, \theta)](https://habrastorage.org/getpro/habr/upload_files/6c3/ea8/16b/6c3ea816bc0fe593be519845a4cecd21.svg) на обучаемый параметр ![s](https://habrastorage.org/getpro/habr/upload_files/74e/501/f5d/74e501f5d4bb1d782282fd6f9136a74b.svg). Видно, что при стремлении ![s](https://habrastorage.org/getpro/habr/upload_files/f48/7c0/ca0/f487c0ca0285965bbc95b3a6a16fafe5.svg) к ![-\infty](https://habrastorage.org/getpro/habr/upload_files/e4f/2d4/328/e4f2d432850eb4468de19d8a500a60af.svg) или ![+\infty](https://habrastorage.org/getpro/habr/upload_files/3b8/957/7e7/3b89577e749745aca190998c5c11dcc2.svg) все выражение стремится к ![+\infty](https://habrastorage.org/getpro/habr/upload_files/6b0/06e/a1a/6b006ea1a734e9f63d4d7097eaacd299.svg) , поэтому функция потерь никогда не стремится к ![-\infty](https://habrastorage.org/getpro/habr/upload_files/b4f/440/941/b4f44094100869c88712c85b76cca937.svg) и для параметров (![\theta, s](https://habrastorage.org/getpro/habr/upload_files/acb/ad6/ca0/acbad6ca0993257df9d7e5cba8c6a701.svg)) существует глобальный оптимум. Например, в нейронной сети мы можем сделать веса, идущие к нейрону, который выдает уверенность, нулевыми и необучаемыми. Тогда уверенность будет равна bias'у этого нейрона, который является обучаемым параметром.

Имеет ли это смысл? Возможно в каких-то случаях да. Но если дать модели выучивать параметр ![s](https://habrastorage.org/getpro/habr/upload_files/20a/9b0/bee/20a9b0bee7ac7369eab2304dd247cf32.svg), то он будет рассчитываться на обучающей выборке и поэтому может быть переобученным (если модель хорошо запомнила все обучающие примеры, то и ![s](https://habrastorage.org/getpro/habr/upload_files/4ae/65c/e57/4ae65ce572bbe56500936626f58cb499.svg) будет низким). Кроме того, при обучении нейронных сетей часто применяют dropout, и значение ![s](https://habrastorage.org/getpro/habr/upload_files/07c/d4a/9da/07cd4a9da610eb2e56cd2c8510c2291c.svg) будет рассчитано в условиях наличия dropout (хотя на инференсе он обычно не используется). Поэтому обычно нам гораздо удобнее оценивать дисперсию предсказаний на валидационной или тестовой выборке.

Существует еще один похожий подход, называемый inductive conformal prediction ([Vovk et al., 2005](https://www.researchgate.net/publication/223460765_Algorithmic_Learning_in_a_Random_World), [Sousa, 2022](https://arxiv.org/abs/2206.11810)). В нем на отдельной выборке рассчитывается вероятность модели допустить ошибку выше заданного порога, что близко по смыслу к оценке дисперсии.