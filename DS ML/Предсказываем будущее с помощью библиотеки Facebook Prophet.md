---
tags:
  - data
data_type:
  - DS
link: https://habr.com/ru/companies/ods/articles/323730/
company: ODS
author: ODS
source: habr
---


Прогнозирование временных рядов — это достаточно популярная аналитическая задача. Прогнозы используются, например, для понимания, сколько серверов понадобится online-сервису через год, каков будет спрос на каждый товар в гипермаркете, или для постановки целей и оценки работы команды (для этого можно построить baseline прогноз и сравнить фактическое значение с прогнозируемым).

  

Существует большое количество различных подходов для прогнозирования временных рядов, такие как [ARIMA](https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average), [ARCH](https://en.wikipedia.org/wiki/Autoregressive_conditional_heteroskedasticity), регрессионные модели, нейронные сети и т.д.

  

Сегодня же мы познакомимся с библиотекой для прогнозирования временных рядов `Facebook Prophet` (_в переводе с английского, "пророк", [выпущена в open-source](https://research.fb.com/prophet-forecasting-at-scale/) 23-го февраля 2017 года_), а также попробуем в жизненной задаче – прогнозировании числа постов на Хабрехабре.

  
  

## Библиотека

  

Согласно [статье Facebook](https://research.fb.com/prophet-forecasting-at-scale/) `Prophet`, был разработан для прогнозирования большого числа различных бизнес-показателей и строит достаточно хорошие default'ные прогнозы. Кроме того, библиотека дает возможность, изменяя человеко-понятные параметры, улучшать прогноз и не требует от аналитиков глубоких знаний устройства предсказательных моделей.

  

Давайте немного обсудим, как же работает библиотека `Prophet`. По сути, это [additive regression model](https://en.wikipedia.org/wiki/Additive_model), состоящая из следующих компонент:

  

![$y(t) = g(t) + s(t) + h(t) + \epsilon_{t}$](https://habrastorage.org/getpro/habr/post_images/959/04b/dbf/95904bdbfc8292cd94691632babc8629.svg)

  

1. **Сезонные компоненты** ![$s(t)$](https://habrastorage.org/getpro/habr/post_images/eaf/583/ee1/eaf583ee1c49552f156f235623828a82.svg) отвечают за моделирование периодических изменений, связанных с недельной и годовой сезонностью. Недельная сезонность моделируется с помощью `dummy variables`. Добавляются 6 дополнительных признаков, например, `[monday, tuesday, wednesday, thursday, friday, saturday]`, которые принимают значения 0 и 1 в зависимости от даты. Признак `sunday`, соответствующий седьмому дню недели, не добавляют, потому что он будут линейно зависеть от других дней недели и это будет влиять на модель.  
    Годовая же сезонность моделируется рядами Фурье.
2. **Тренд** ![$g(t)$](https://habrastorage.org/getpro/habr/post_images/c2b/7de/df6/c2b7dedf6f4fa002207f0da9e7243b5d.svg) — это кусочно-линейная или логистическая функция. С линейной функцией все понятно. Логистическая же функция вида ![$g(t) = \frac{C}{1+exp(-k(t-b))}$](https://habrastorage.org/getpro/habr/post_images/1fd/d92/faa/1fdd92faaa5b40c5e6651f3086a034f3.svg) позволяет моделировать рост с насыщением, когда при увеличении показателя снижается темп его роста. Типичный пример — это рост аудитории приложения или сайта.  
    Кроме всего прочего, библиотека умеет по историческим данным выбирать оптимальные точки изменения тренда. Но их также можно задать и вручную (например, если известны даты релизов новой функциональности, которые сильно повлияли на ключевые показатели).
3. Компонента ![$h(t)$](https://habrastorage.org/getpro/habr/post_images/299/d07/dbe/299d07dbeab8dd929a8d57710d7c50fb.svg) отвечает за заданные пользователем **аномальные дни**, в том числе и нерегулярные, такие как, например, Black Fridays.
4. **Ошибка** ![$\epsilon_{t}$](https://habrastorage.org/getpro/habr/post_images/efe/886/4ae/efe8864ae200b932551f59e518d0946c.svg) содержит информацию, которая не учтена моделью.

  

Подробнее про алгоритмы можно прочитать в публикации _Sean J. Taylor, Benjamin Letham ["Forecasting at scale"](https://facebookincubator.github.io/prophet/static/prophet_paper_20170113.pdf)_.

  

В этой же публикации представлено и сравнение `mean absolute percentage error` для различных методов автоматического прогнозирования временных рядов, согласно которому `Prophet` имеет существенно более низкую ошибку.

  

![](https://habrastorage.org/r/w1560/files/491/363/dfa/491363dfa9da400686ce13018a167b7f.png)

  

Давайте сначала разберемся, как оценивается качество моделей в статье, а затем перейдем к алгоритмам, с которыми сравнивали `Prophet`.

  

`MAPE (mean absolute percentage error)` — это средняя абсолютная ошибка нашего прогноза. Пусть ![$y_{i}$](https://habrastorage.org/getpro/habr/post_images/ce0/009/fc5/ce0009fc5603a0e2edc997cebe4cc560.svg) — это показатель, а ![$\hat{y_{i}}$](https://habrastorage.org/getpro/habr/post_images/f01/036/a1e/f01036a1e0fc69925d0d591a7ad44d90.svg) — это соответствущий этой величине прогноз нашей модели. Тогда ![$e_{i} = y_{i} - \hat{y_{i}}$](https://habrastorage.org/getpro/habr/post_images/b02/62c/26d/b0262c26d4209386512db0f7bc3fe437.svg) — это ошибка прогноза, a ![$p_{i} =\frac{e_{i}}{y_{i}}$](https://habrastorage.org/getpro/habr/post_images/c4e/e8d/b00/c4ee8db0001bb36be178cd20fcd16007.svg) — это относительная ошибка прогноза.

  

![$MAPE = mean(|p_{i}|)$](https://habrastorage.org/getpro/habr/post_images/66c/006/de5/66c006de5aeb3e603d3656a2e2b9864e.svg)

  

`MAPE` часто используется для оценки качества, поскольку эта величина относительная и по ней можно сравнивать качество даже на различных наборах данных.

  

Кроме того, бывает полезно смотреть и на абсолютную ошибку `MAE - mean absolute error`, чтобы понимать, на сколько ошибается модель в абсолютных величинах.

  

![$MAE = mean(|e_{i}|)$](https://habrastorage.org/getpro/habr/post_images/dec/0db/bbf/dec0dbbbfd88e93e3c28d9f4b6530d41.svg)

  

Cтоит сказать пару слов о тех алгоритмах, с которыми сравнивали `Prophet` в публикации, тем более, большинство из них очень простые и их часто используют как baseline:

  

- `naive` — наивный прогноз, когда мы прогнозируем все последующие значения последней точкой;
- `snaive - seasonal naive` — такой прогноз подходит для данных с явно выраженной сезонностью. Например, если мы говорим о показатели с недельной сезонностью, то для каждого последующего понедельника мы будем брать значение за последний понедельник, для вторника — за последний вторник и так далее;
- `mean` — в качестве прогноза берется среднее значение показателя;
- `arima - autoregressive integrated moving average` — подробности на [wiki](https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average);
- `ets - exponential smoothing` — подробности на [wiki](https://en.wikipedia.org/wiki/Exponential_smoothing).

  

## Практика

  

### Установка

  

Для начала необходимо установить библиотеку. Библиотека `Prophet` доступна для `python` и `R`. Я предпочитаю `python`, поэтому использовала именно его. Для `python` библиотека ставится с помощью `PyPi` следующим образом:

  

```
pip install fbprophet
```

  

Под `R` у библиотеки есть `CRAN package`. Подробные инструкции по установке можно найти в [документации](https://facebookincubator.github.io/prophet/docs/installation.html).

  

### Данные

  

В качестве показателя для предсказания я выбрала количество постов, опубликованных на Хабрахабре. Данные я взяла из учебного конкурса на Kaggle ["Прогноз популярности статьи на Хабре"](https://inclass.kaggle.com/c/howpop-habrahabr-favs-lognorm). [Тут](https://habrahabr.ru/company/ods/blog/323890/#7-domashnee-zadanie--4) рассказано подробнее о соревновании и [курсе](https://habrahabr.ru/company/ods/blog/322626/) машинного обучения, в рамках которого оно проводится.

  

**Код для предобработки данных**

  

Для начала посмотрим на данные и построим `time series plot` за весь период. На таком длинном периоде удобнее смотреть на недельные точки.

  

Для визуализации я как обычно буду использовать библиотеку `plot.ly`, которая позволяет строить в `python` интерактивные графики. Подробнее про нее и визуализацию в целом можно почитать в статье [Открытый курс машинного обучения. Тема 2: Визуализация данных c Python](https://habrahabr.ru/company/ods/blog/323210/).

  

**Код для визуализации**

  
![](https://habrastorage.org/r/w1560/files/cba/53b/cf7/cba53bcf789b43b18e55931554ea50a7.png)  

### Построение прогноза

  

Библиотека `Prophet` имеет интерфейс похожий на `sklearn`, сначала мы создаем модель, затем вызываем у нее метод `fit` и затем получаем прогноз. На вход методу `fit` библиотека принимает `dataframe` с двумя колонками:

  

- `ds` — время, поле должно быть типа `date` или `datetime`,
- `y` — числовой показатель, который мы хотим предсказывать.

  

Для того чтобы измерить качество полученного прогноза, уберем из обучения последний месяц данных и будем предсказывать его. Создатели советуют делать предсказания по нескольким месяцам данных, в идеале – год и более (в нашем случае есть несколько лет истории для обучения).

  

```
#импортируем библиотекуfrom fbprophet import Prophetpredictions = 30# приводим dataframe к нужному форматуdf = aggr_habr_df.reset_index()df.columns = ['ds', 'y']# отрезаем из обучающей выборки последние 30 точек, чтобы измерить на них качествоtrain_df = df[:-predictions] 
```

  

Далее создаем объект класса `Prophet` (все параметры модели задаются в конструкторе класса, для начала возьмем default'ные параметры) и обучаем его.

  

```
m = Prophet()m.fit(train_df)
```

  

С помощью вспомогательной функции `Prophet.make_future_dataframe` создаем `dataframe`, который содержит все исторические временные точки и еще 30 дней, для которых мы хотели построить прогноз.

  

Для того, чтобы построить прогноз вызываем у модели функцию `predict` и передаем в нее полученный на предыдущем шаге `dataframe future`.

  

```
future = m.make_future_dataframe(periods=predictions)forecast = m.predict(future)
```

  

В библиотеке `Prophet` есть встроенные средства визуализации, которые позволяют оценить результат построенной модели.

  

Во-первых, метод `Prophet.plot` отображает прогноз. Честно говоря, в данном случае такая визуализация не очень показательна. Основной вывод из этого графика, который я сделала — в данных много `outlier`'ов. Однако если при прогнозировании будет меньше исторических точек, то по ней можно будет что-нибудь понять.

  

```
m.plot(forecast)
```

  
![](https://habrastorage.org/r/w1560/files/c50/b7d/fb8/c50b7dfb80924f27bc7e193eba4112b4.png)  

Вторая функция `Prophet.plot_components`, на мой взгляд, гораздо более полезная. Она позволяет посмотреть отдельно на компоненты: тренд, годовую и недельную сезонность. Если при построении модели были заданы аномальные дни/праздники, то они также будут отображаться на этом графике.

  

```
m.plot_components(forecast)
```

  
![](https://habrastorage.org/r/w1560/files/667/bd5/b26/667bd5b265774c4188f166d239609351.png)  

На графике видно, что `Prophet` хорошо хорошо подстроился под рост числа постов "ступенькой" в начале 2015-го. По недельной сезонности можно сделать вывод, что меньше постов приходится на воскресенье и понедельник. На графике годовой сезонности ярче всего выделяется провал активности в Новогодние каникулы, также виден спад и на майских праздниках.

  

### Оценка качества модели

  

Давайте оценим качество алгоритма и посчитаем `MAPE` для последних 30 дней, которые мы предсказывали. Для расчета нам нужны наблюдения ![$y_{i}$](https://habrastorage.org/getpro/habr/post_images/ce0/009/fc5/ce0009fc5603a0e2edc997cebe4cc560.svg) и прогнозы для них ![$ \hat{y_{i}}$](https://habrastorage.org/getpro/habr/post_images/f01/036/a1e/f01036a1e0fc69925d0d591a7ad44d90.svg).

  

Для начала посмотрим на объект `forecast`, который генерирует библиотека. На самом деле это `dataframe`, в котором есть вся необходимая нам информация для прогноза.

  

```
print(', '.join(forecast.columns))
```

  

```
ds, t, trend, seasonal_lower, seasonal_upper, trend_lower, trend_upper, yhat_lower, yhat_upper, weekly, weekly_lower, weekly_upper, yearly, yearly_lower, yearly_upper, seasonal, yhat
```

  

Прежде чем продолжить, нам нужно объединить `forecast` с нашими исходными наблюдениями.

  

```
cmp_df = forecast.set_index('ds')[['yhat', 'yhat_lower', 'yhat_upper']].join(df.set_index('ds'))
```

  

Напомню, что мы изначально отложили данные за последний месяц, чтобы построить прогноз на 30 дней и измерить качество получившейся модели.

  

```
import numpy as npcmp_df['e'] = cmp_df['y'] - cmp_df['yhat']cmp_df['p'] = 100*cmp_df['e']/cmp_df['y']print 'MAPE', np.mean(abs(cmp_df[-predictions:]['p']))print 'MAE', np.mean(abs(cmp_df[-predictions:]['e']))
```

  

В результате мы получили качество около `37.35%`, а в среднем в прогнозе модель ошибается на `10.62` поста.

  

### Визуализация

  

Давайте сделаем свою визуализацию построенной `Prophet` модели: с фактическими значениями, прогнозом и доверительными интервалами.

  

Во-первых, я хочу оставить данные за меньший период, чтобы они не превращались в месиво точек. Во-вторых, хочется показывать результаты модели только за тот период, на котором мы делали предсказание — мне кажется, так график будет более читаемым. В-третьих, сделаем график интерактивным с помощью `plot.ly`.

  

**Код для визуализации**

  
![](https://habrastorage.org/r/w1560/files/fd8/1a9/80e/fd81a980ecdb49c6ad53d648bba52d95.png)  

Визуально прогноз модели, кажется достаточно хорошим и разумным. Скорее всего такая низкая оценка качества объясняется аномальным высоким количеством постов 13 и 17 октября и снижением активности с 7 октября.

  

Также по графику можно сделать вывод, что большинство точек лежат внутри доверительного интервала.

  

## Сравнение с ARIMA моделью

  

На глаз прогноз получился вполне разумным, но давайте сравним его с классической моделью `SARIMA - Seasonal autoregressive integrated moving average` с недельным периодом.

  

На Хабрахабре уже есть несколько статей про `ARIMA`-модели, всем интересующимся советую почитать их: [Построение модели SARIMA с помощью Python+R](https://habrahabr.ru/post/210530/) и [Анализ временных рядов с помощью python](https://habrahabr.ru/post/207160/).

  

Для построения прогноза я также вдохновлялась учебными материалами курса [Прикладные задачи анализа данных](https://www.coursera.org/learn/data-analysis-applications/home/week/1) на Сoursera, в котором подробно описаны `ARIMA`-модели и как их строить на `python`.

  

Стоит отметить, что построение `ARIMA` модели требует гораздо больших затрат по сравнению с `Prophet`: нужно исследовать исходный ряд, привести его к стационарному, подобрать начальные приближения и потратить немало времени на подбор гипер-параметров алгоритма (на моем компьютере модель подбиралась почти 2 часа).

  

Но в данном случае усилия были не напрасны и предсказание `SARIMA` получилось более точным: `MAPE=16.54%, MAE=7.28 поста`. Лучшая модель с параметрами: `D=1, d=1, Q=1, q=4, P=1, p=3`.

  
![](https://habrastorage.org/r/w1560/files/331/0dc/ff3/3310dcff35b8496ba98512a73ade4e9c.png)  

Но и `Prophet`, конечно же, можно еще потюнить. Например, если предсказывать в этой библиотеке не исходный ряд, а после [преобразования Бокса-Кокса](http://www.machinelearning.ru/wiki/index.php?title=%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%91%D0%BE%D0%BA%D1%81%D0%B0-%D0%9A%D0%BE%D0%BA%D1%81%D0%B0), нормализующего дисперсию ряда, то мы получим прирост качества: `MAPE=26.79%, MAE=8.49 поста`.

  

**Код для прогноза ряда с преобразованием Бокса-Кокса**

  

## Итог

  

Мы познакомились с open-source библиотекой `Prophet` и ее использованием для предсказания временных рядов на практике.  
Я бы не стала говорить, что эта библиотека творит чудеса и идеально предсказывает будущее. В нашем случае прогноз получился хуже стандартной `SARIMA`. Однако, библиотека `Prophet` достаточно удобная, легко кастомизируется (чего только стоит возможность добавления заранее известных аномальных дней), поэтому ее полезно иметь в своем аналитическом `toolbox'e`.

  

## Полезные ссылки

  

Немного материалов для более глубокого изучения библиотеки `Prophet` и предсказаний временных рядов, в общем:

  

- `Prophet` GitHub [репозиторий](https://github.com/facebookincubator/prophet)
- `Prophet` [документация](https://facebookincubator.github.io/prophet/docs/quick_start.html)
- _Sean J. Taylor, Benjamin Letham ["Forecasting at scale"](https://facebookincubator.github.io/prophet/static/prophet_paper_20170113.pdf)_ — научная публикация, объясняющая алгоритм в основе библиотеки `Prophet`
- _[Forecasting Website Traffic Using Facebook’s Prophet Library](http://pbpython.com/prophet-overview.html)_ — пример использования для прогнозирования трафика на сайт
- _Rob J Hyndman, George Athana­sopou­los ["Forecasting: principles and practice"](https://www.otexts.org/fpp)_ – и напоследок, хорошая online-книга, рассказывающая об основах прогнозирования временных рядов
- [jupyter notebook](http://nbviewer.jupyter.org/github/miptgirl/habra_materials/blob/master/prophet/habra_data.ipynb) с кодом для разобранного в этой статье примера