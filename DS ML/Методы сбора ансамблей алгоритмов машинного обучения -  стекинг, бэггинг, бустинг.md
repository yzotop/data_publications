---
tags:
  - data
source: habr
link: https://habr.com/ru/articles/561732/
data_type:
  - DS
---
## Что такое ансамбли моделей?

Из названия можно догадаться, что ансамбль - это просто несколько алгоритмов машинного обучения, собранных в единое целое. Такой подход часто используется для того, чтобы усилить "положительные качества" отдельно взятых алгоритмов, которые сами по себе могут работать слабо, а вот в группе - ансамбле давать хороший результат. При использовании ансамблевых методов алгоритмы учатся одновременно и могут исправлять ошибки друг друга. Типичными примерами методов, направленных на объединение "слабых" учеников в группу сильных являются (рис. 1):

- **Стекинг**. Могут рассматриваться разнородные отдельно взятые модели. Существует мета-модель, которой на вход подаются базовые модели, а выходом является итоговый прогноз.
    
- **Бэггинг.** Рассматриваются однородные модели, которые обучаются независимо и параллельно, а затем их результаты просто усредняются. Ярким представителем данного метода является случайный лес.
    
- **Бустинг.** Рассматриваются однородные модели, которые обучаются последовательно, причем последующая модель должна исправлять ошибки предыдущей. Конечно, в качестве примера здесь сразу приходит на ум градиентный бустинг.
    

![Рисунок 1](https://habrastorage.org/r/w1560/getpro/habr/upload_files/8ce/f49/84e/8cef4984e977907113b3969a318894db.jpg "Рисунок 1")

Рисунок 1

Три этих способа и будут детальнее рассмотрены далее.

## Стекинг

Из трех вариантов стекинг является наименее популярным. Это можно проследить и по числу готовых реализаций данного метода в программных библиотеках. В том же sklearn.ensemble в python куда чаше используют AdaBoost, Bagging, GradientBoosting, чем тот же самый Stacking (хотя его реализация там тоже есть).

Стекинг выделяется двумя основными чертами: он может объединить в себе алгоритмы разной природы в качестве базовых. Например, взять метод опорных векторов (SVM), k-ближайших соседей (KNN) в качестве базовых и на основе их результатов обучить логистическую регрессию для классификации. Также стоит отметить непредсказуемость работы метамодели. Если в случае бэггинга и бустинга существует достаточно четкий и конкретный ансамблевый алгоритм (увидим далее), то здесь метамодель может с течением времени по-разному обучаться на входных данных.

**Алгоритм обучения выглядит следующим образом (рис. 2):**

- Делим выборку на _k фолдов_ (тот же смысл, что и в кросс-валидации).
    
- Для объекта из выборки, который находится в _k-ом фолде_, делается предсказание слабыми алгоритмами, которые были обучены на _k-1 фолдах._ Этот процесс итеративен и происходит для каждого фолда.
    
- Создается набор прогнозов слабых алгоритмов для каждого объекта выборки.
    
- На сформированных низкоуровневыми алгоритмами прогнозах в итоге обучается метамодель.
    
    ![Рисунок 2](https://habrastorage.org/r/w1560/getpro/habr/upload_files/669/1be/795/6691be7955cdd52269ee31704d7d82c0.jpg "Рисунок 2")
    
    Рисунок 2
    

_Ссылки на библиотеки для использования метода приведены ниже:_

[Классификатор](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier)

[Регрессия](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.StackingRegressor.html#sklearn.ensemble.StackingRegressor)

### Бэггинг

Бэггинг является уже более популярным подходом и зачастую при упоминании этого термина вспоминается алгоритм построения случайного леса, как наиболее типичного его представителя.

При данном методе базовые алгоритмы являются представителями одного и того же семейства, они обучаются параллельно и почти независимо друг от друга, а финальные результаты лишь агрегируются. Нам необходимо, чтобы на вход слабым алгоритмам подавались разные данные, а не один и тот же набор, ведь тогда результат базовых моделей будет идентичен и смысла в них не будет.

Для того, чтобы понять, каким образом исходный датасет делится для формирования входных выборок для слабых алгоритмов, используется понятие **бутстрэпа**. При использовании бутстрэпа из исходной выборки берется один случайный элемент, записывается в обучающую выборку, затем возвращается обратно. Так делается n раз, где n - желаемый размер обучающей выборки. Существует правило, что в обучающей выборке в итоге будет ~ 0.632*n разных объектов. Таким образом, должны сформироваться m обучающих выборок для m слабых алгоритмов.

Бутстрэп выборки являются в значительной степени независимыми. Отчасти поэтому и говорят, что базовые алгоритмы обучаются на выборках независимо.

Что касается агрегации выходов базовых алгоритмов, то в случае задачи классификации зачастую просто выбирается наиболее часто встречающийся класс, а в случае задачи регрессии выходы алгоритмов усредняются (рис. 3). В формуле под _ai_ подразумеваются выходы базовых алгоритмов.

![Рисунок 3](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fc2/44d/580/fc244d580ae4cc7deb0c36061421ee6e.jpg "Рисунок 3")

Рисунок 3

Общий процесс приведен на рисунке ниже (рис. 4):

![Рисунок 4](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5b7/67a/51c/5b767a51c13a6732e430db1806a0f9b0.jpg "Рисунок 4")

Рисунок 4

**Случайный лес**

Бэггинг направлен на уменьшение разброса (дисперсии) в данных, и зачастую данный прием предстает в виде алгоритма случайного леса, где слабые модели - это довольно глубокие случайные деревья. Однако, при построении случайного леса используется еще один прием, такой как _метод случайных подпространств._ Мало того, что благодаря бутсрэпу выбираются некоторые объекты нашего датасета, так еще и выбирается случайное подмножество признаков. В итоге, наша условная матрица признаков уменьшается как по строкам, так и столбцам (рис. 5). Это помогает действительно снизить корреляцию между слабыми учениками.

![Рисунок 5](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c9e/3e5/b9f/c9e3e5b9f8b1c465451fa1cbb0216848.jpg "Рисунок 5")

Рисунок 5

_Ссылки на библиотеки для использования метода приведены ниже:_

[Классификация](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier)

[Регрессия](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html#sklearn.ensemble.RandomForestRegressor)

### Бустинг

В данном случае, модели уже не обучаются отдельно друг от друга, а каждая следующая правит ошибки предыдущей. То есть можно сказать, что если один слабый алгоритм не смог выявить какую-либо закономерность в данных, так как это было для него сложно, то следующая модель должна сделать это. Но из данного подхода вытекает недостаток: работу алгоритма трудно распараллелить из-за зависимости предыдущего и последующего шагов.

Бустинг направлен скорее на уменьшение смещения в данных, чем на снижение разброса в них. Поэтому в качестве базовых алгоритмов могут браться модели с достаточно высоким смещением, например, неглубокие случайные деревья.

![Рисунок 6](https://habrastorage.org/r/w1560/getpro/habr/upload_files/b78/fd0/b99/b78fd0b999b6c7b184ff252f755224b2.jpg "Рисунок 6")

Рисунок 6

Типичными представителями бустинга являются две модели: градиентный бустинг и AdaBoost. Обе по-разному решают одну и ту же оптимизационную задачу по поиску итоговой модели, представляющей собой взвешенную сумму слабых алгоритмов (рис. 6).

Градиентный бустинг использует типичный алгоритм градиентного спуска для решения задачи. Когда приходит время добавить новый слабый алгоритм в ансамбль делается следующее:

- Находится оптимальный вектор сдвига, улучшающий предыдущий ансамбль алгоритмов.
    
- Этот вектор сдвига является антиградиентом от функции ошибок работы предыдущего ансамбля моделей
    
- Благодаря вектору сдвигов мы знаем, какие значения должны принимать объекты обучающей выборки
    
- А поскольку нам надо найти очередной алгоритм в композиции, то находим тот, при использовании которого минимизируется отклонение ответов от истинных
    

Градиентный бустинг - это в своем роде обобщение AdaBoost, поэтому, возможно, зачастую его и изучают первым. На самом деле, два данных алгоритма следует рассматривать куда подробнее, выделяя отдельную статью.

_Ссылки на библиотеки для использования метода приведены ниже:_

[Классификация градиентным бустингом](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier), [классификация AdaBoost-ом](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html#sklearn.ensemble.AdaBoostClassifier)

[Регрессия градиентным бустингом](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor), [регрессия AdaBoost-ом](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostRegressor.html#sklearn.ensemble.AdaBoostRegressor)

## Заключение

Таким образом, мы увидели, что для того, чтобы улучшить качество функционирования отдельно взятых моделей машинного обучения, существует ряд техник их объединения в ансамбли. Эти техники уже заложены в программные продукты и ими можно пользоваться, улучшая свое решение. Однако, с моей точки зрения, при решении задачи не стоит сразу же браться за них. Лучше сначала попробовать одну простую, отдельную модель, понять, как она функционирует на конкретных данных, а уже дальше использовать ансамбли.