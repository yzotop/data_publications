---
tags:
  - data
data_type:
  - DS
company: Magnus
source: habr
author: Magnus
---
Современные нейросетевые архитектуры достигают впечатляющих результатов в сложных задачах ИИ благодаря росту объемов данных и вычислительных мощностей. Однако обратной стороной медали стала высокая ресурсоемкость обучения.

Например, последняя версия GPT-4 от OpenAI обучалась на большом GPU‑кластере. [По некоторым данным](https://the-decoder.com/gpt-4-architecture-datasets-costs-and-more-leaked/), она содержит около 1,8 триллиона параметров, а ее обучение обошлось более чем в 100 млн долларов. А модель Llama 3.1 405B, вроде бы оптимизированная под ограниченные ресурсы, все равно [требовала](https://ai.meta.com/blog/meta-llama-3-1/#:~:text=Model%20Architecture,at%20this%20scale.) более 15 триллионов токенов и свыше 16 тысяч GPU NVIDIA H100.

И хотя нынешнее качество работы LLM уже можно действительно назвать выдающимся, на практике они подкидывают разработчикам широкий ряд проблем производительности: от запредельных объемов данных до оптимизации гиперпараметров. Все это приводит к потребности в ускорении обучения.

Мы подготовили серию материалов, которые помогут разобраться в ускорении обучения нейросетей. В этой статье рассмотрим различные теоретические аспекты от аппаратного ускорения до правильной организации самого обучения, в следующей — поговорим о практике. В общем, нас ждет глубокое погружение в тему. Приятного прочтения!

## Методы ускорения обучения

Ускорение обучения нейронных сетей — комплексная задача, требующая оптимизации на разных уровнях.

Современные подходы к ускорению включают как высокоуровневые методы, такие как распараллеливание вычислений на кластерах GPU и оптимизация архитектуры нейросетей, так и низкоуровневые техники вроде квантизации весов и вычислений со смешанной точностью. Грамотное сочетание этих методов позволяет добиться многократного ускорения обучения без потери качества моделей.

### Эффективное использование аппаратных ресурсов

#### Распараллеливание вычислений на GPU и TPU

Один из ключевых методов ускорения — распараллеливание операций на специализированных процессорах, таких как графические ускорители (GPU) и тензорные процессоры (TPU).

Графические процессоры (GPU) стали де‑факто стандартом для обучения нейронных сетей благодаря архитектуре, оптимизированной под массивно‑параллельные вычисления. Благодаря большой пропускной способности памяти и высокой степени параллелизма, GPU идеально подходят для ускорения матричных операций, на которых основаны нейросети. Фреймворки глубокого обучения, такие как PyTorch и TensorFlow, имеют встроенную поддержку вычислений на GPU, что позволяет легко распараллеливать обучение моделей. В этом отношении NVIDIA доминирует на рынке GPU для глубокого обучения, предлагая как недорогие GeForce RTX для энтузиастов, так и мощные дата‑центровые решения Tesla V100 и A100 с десятками гигабайт памяти и производительностью в сотни терафлопс.

![8x NVIDIA Tesla V100 32GB Server. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e28/f84/4c7/e28f844c7b59cc2d3299b560763b6760.png "8x NVIDIA Tesla V100 32GB Server. Источник")

_8x NVIDIA Tesla V100 32GB Server._ [_Источник_](https://www.servethehome.com/nvidia-tesla-v100s-boasts-big-performance-gain)

TPU — это специализированные интегральные схемы, разработанные Google для ускорения нейросетей. Они содержат матричные умножители, оптимизированные под типичные операции глубокого обучения. TPU объединяются в масштабируемые кластеры серверов, обеспечивая петафлопсы вычислительной мощности. Крупные модели, вроде GPT-4, обучаются именно на кластерах TPU.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/084/1bc/f4a/0841bcf4a7ec6759756df29af53df0a0.png)

Программные фреймворки, такие как PyTorch и TensorFlow, предоставляют высокоуровневые абстракции для распараллеливания вычислений на GPU и TPU. Они автоматически строят вычислительный граф операций и оптимизируют его выполнение на конкретном железе. Для эффективного распределения нагрузки в кластере машин используются расширения вроде [Horovod](https://github.com/horovod/horovod) и [DeepSpeed](https://github.com/microsoft/DeepSpeed).

#### Оптимизация численных форматов и квантование

Другой важный метод ускорения нейросетей — снижение точности вычислений. Традиционно обучение ведется с 32-битной точностью чисел с плавающей запятой (FP32). Однако для многих задач достаточно более компактных форматов, таких как 16-битные числа (FP16) или даже 8-битные целые (INT8). Формат FP16 имеет диапазон чисел от 2^-14 до 2^15 и точность около 3 знаков после запятой. Этого достаточно для большинства задач глубокого обучения.

Современные GPU и TPU поддерживают вычисления с пониженной точностью. Используя FP16 вместо FP32, можно удвоить производительность и вдвое сократить использование памяти. Некоторые GPU (Tensor Cores от NVIDIA) поддерживают смешанную точность: FP16 для прямого прохода нейросети и FP32 для обратного распространения ошибки. Это позволяет ускорить обучение без потери качества.

Некоторые модели допускают даже более агрессивное квантование — до 8-битных целых чисел (INT8). Веса нейросети квантуются до INT8, что дает 4-кратное сжатие по сравнению с FP32. При этом точность модели часто снижается незначительно. Для минимизации ошибок квантования используются специальные техники обучения, такие как квантование с сохранением градиентов (Quantization‑Aware Training, QAT).

![Процесс обучения с использованием квантования](https://habrastorage.org/r/w1560/getpro/habr/upload_files/48a/d97/589/48ad975896b182a67b462751e04a0e4f.jpg "Процесс обучения с использованием квантования")

_Процесс обучения с использованием квантования_

Аппаратная поддержка низкоточных форматов активно развивается. Архитектура NVIDIA Ampere включает ядра Tensor Cores третьего поколения, работающие с форматами TF32 (19 бит мантиссы) и BF16 (8 бит мантиссы). Процессоры Intel начиная с поколения Ice Lake поддерживают инструкции для работы с 8-битными целыми (INT8) и байтовыми (INT4) форматами.

#### Эффективные структуры данных и алгоритмы для работы с разреженными тензорами

Разреженные тензоры, в которых большинство элементов равны нулю, позволяют существенно сократить объем вычислений и памяти, требуемый для обработки нейросетей. Вместо хранения всех элементов используются компактные форматы, кодирующие только ненулевые значения и их индексы. Современные архитектуры, такие как трансформеры, особенно хорошо подходят для разреженных вычислений, так как многие их веса разрежены по своей природе. Популярные форматы хранения разреженных тензоров — это CSR (Compressed Sparse Row) и COO (Coordinate). Библиотеки глубокого обучения, такие как PyTorch, поддерживают разреженные тензоры и могут автоматически использовать их для ускорения вычислений.

Ключевой примитив для работы с разреженными матрицами — это операция умножения разреженной матрицы на плотный вектор (SpMV). Оптимизация SpMV для конкретного паттерна разреженности и аппаратной платформы — активная область исследований. Перспективные форматы хранения включают CSR (Compressed Sparse Row), ELLPACK, DIA (Diagonal) и другие.

Интересный формат разреженности — блочная структурированная разреженность (block sparsity). Веса разбиваются на блоки фиксированного размера (например, 1×4), и в каждом блоке хранится ограниченное число (2 из 4) ненулевых элементов. Блочная разреженность удобна тем, что паттерн ненулевых элементов фиксирован, что позволяет использовать быстрые методы умножения блочно‑разреженных матриц. NVIDIA и Intel добавили аппаратную поддержку 2:4 блочной разреженности в свои новейшие GPU и процессоры.

В [недавнем исследовании](https://pytorch.org/blog/accelerating-neural-network-training/) было показано, что обучение моделей с блочной разреженностью от начала (sparse training) позволяет ускорить обучение на 6% для архитектуры Vision Transformer. При этом точность модели практически не страдает.

![График сравнивает две стратегии 125 000 итераций обучения модели ViT-L на 4 GPU: полностью плотное обучение (синий) и на 70% разреженное, затем плотное (оранжевый). Обе стратегии достигают схожей точности на ImageNet (82.8% и 82.7%), но разреженный вариант обучается на 6% быстрее. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/40a/71d/512/40a71d512efebaf6b7ac051be4199396.png "График сравнивает две стратегии 125 000 итераций обучения модели ViT-L на 4 GPU: полностью плотное обучение (синий) и на 70% разреженное, затем плотное (оранжевый). Обе стратегии достигают схожей точности на ImageNet (82.8% и 82.7%), но разреженный вариант обучается на 6% быстрее. Источник")

_График сравнивает две стратегии 125 000 итераций обучения модели ViT‑L на 4 GPU: полностью плотное обучение (синий) и на 70% разреженное, затем плотное (оранжевый). Обе стратегии достигают схожей точности на ImageNet (82.8% и 82.7%), но разреженный вариант обучается на 6% быстрее._ [_Источник_](https://pytorch.org/blog/accelerating-neural-network-training/)

Блочно‑разреженное обучение реализовано с помощью специального ядра, которое эффективно отображает плотные веса в разреженный формат на лету во время прямого и обратного прохода нейросети. Ключевые оптимизации в данном случае — это обработка весов блоками по 64 байта для эффективного доступа к памяти, отсечение малых весов с сохранением топ-2 элементов в каждом блоке 4×4, а также хранение прямого и транспонированного разреженного представления весов для быстрого умножения на разреженную матрицу в обоих направлениях.

Другое занятное направление — применение разреженности не только к весам, но и к активациям нейросети. Исследовательские работы, такие как [Activation Compressed Training](https://arxiv.org/pdf/2206.11357) (ACT), показывают, что можно эффективно обучать модели, в которых большинство активаций обнуляются. Это позволяет экономить как память, так и вычислительные операции. Для отсечения малых активаций предлагаются различные эвристики и методы обучения порогу отсечения.

### Оптимизация архитектур нейросетей

#### Методы сжатия моделей: прунинг, факторизация, дистилляция знаний

Прунинг — это семейство методов, направленных на удаление «неважных» весов или нейронов из обученной нейросети с целью сжатия модели без существенной потери качества. Основная идея состоит в том, что многие веса в типичной нейросети имеют малые значения и слабо влияют на финальные предсказания, поэтому ими можно пожертвовать.

![Процесс прунинга нейронной сети. Слева показана сеть до прунинга — она содержит много связей между нейронами (синапсов) и нейронов. Справа — сеть после прунинга, где удалены некоторые синапсы и нейроны, признанные неважными. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a25/c36/0a9/a25c360a9e69c6cf247b834453826d7b.png "Процесс прунинга нейронной сети. Слева показана сеть до прунинга — она содержит много связей между нейронами (синапсов) и нейронов. Справа — сеть после прунинга, где удалены некоторые синапсы и нейроны, признанные неважными. Источник")

_Процесс прунинга нейронной сети. Слева показана сеть до прунинга — она содержит много связей между нейронами (синапсов) и нейронов. Справа — сеть после прунинга, где удалены некоторые синапсы и нейроны, признанные неважными._ [_Источник_](https://en.wikipedia.org/wiki/Decision_tree_pruning)

Существует множество алгоритмов прунинга. Прунинг по абсолютной величине весов (magnitude pruning) — один из самых простых и популярных методов, когда веса с абсолютным значением ниже некоторого порога обнуляются. Прунинг по градиенту (gradient‑based pruning) оценивает важность каждого веса по его вкладу в изменение функции потерь на валидационных данных. Структурный прунинг (structured pruning) удаляет целые фильтры или нейроны вместо отдельных весов, что позволяет ускорить не только сжатую модель, но и сам процесс прунинга. А прунинг во время обучения (learning‑based pruning) встраивает механизм прунинга непосредственно в процесс обучения модели, например, добавляя в функцию потерь штраф за L0 или L1 норму весов.

После прунинга разреженная модель обычно дообучается, чтобы скомпенсировать потерю качества. Циклы прунинга и дообучения могут повторяться. Современные методы прунинга позволяют сжимать модели в несколько раз практически без ухудшения точности.

Следующее семейство методов — это факторизация весов. Они основаны на представлении матриц весов в виде произведения нескольких матриц меньшего ранга. Например, полносвязный слой с матрицей весов W ∈ R^{m×n} можно факторизовать в произведение W ≈ U ⋅ V, где U ∈ R^{m×k}, V ∈ R^{k×n}, и k < min(m,n). Это позволяет сократить число параметров с mn до k(m+n).

На практике используются различные методы факторизации. Сингулярное разложение (SVD) представляет матрицу весов в виде W = U ⋅ Σ ⋅ V^T, где U и V — ортогональные матрицы, а Σ — диагональная матрица сингулярных чисел. Факторизация с неотрицательностью (NMF) ищет разложение W ≈ U ⋅ V, где все элементы U и V неотрицательны, что может дать более интерпретируемую факторизацию для некоторых задач. Тензорные разложения, такие как каноническое полиадическое (CP) разложение или разложение Таккера, позволяют факторизовать тензоры весов сверточных слоев, давая дополнительное сжатие по сравнению с покомпонентной факторизацией.

Факторизованные слои могут быть точно эквивалентны исходным (при достаточном ранге) либо давать аппроксимацию с контролируемой точностью. Как и в случае прунинга, факторизованную модель обычно дообучают для восстановления качества.

В этом контексте также интересным является метод дистилляции знаний. Суть здесь в обучении компактной нейросети (ученика) имитировать поведение более сложной модели (учителя). В отличие от прунинга и факторизации, этот подход не требует модификации архитектуры учителя. Вместо этого ученик обучается на псевдометках, выданных учителем на неразмеченных данных.

![Общая система «учитель-ученик» для дистилляции знаний. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5c9/6b0/f6f/5c96b0f6fd58decb93aa38e9fb130500.png "Общая система «учитель-ученик» для дистилляции знаний. Источник")

_Общая система «учитель‑ученик» для дистилляции знаний._ [_Источник_](https://arxiv.org/pdf/2006.05525)

Процесс дистилляции обычно состоит из трех этапов:

1. Обучение большой модели‑учителя обычным способом на размеченных данных.
    
2. Генерация псевдометок учителем на неразмеченном датасете (обычно более многочисленном, чем размеченный).
    
3. Обучение компактной модели‑ученика на смеси размеченных данных и псевдометок, выданных учителем. Функция потерь ученика включает кросс‑энтропию с истинными и псевдометками, а также регуляризатор, поощряющий сходство промежуточных активаций ученика и учителя.
    

Ключевая идея дистилляции в том, что мягкие псевдометки учителя содержат больше информации, чем жесткие истинные метки, и позволяют ученику лучше обобщаться. Дистилляцию можно применять итеративно, когда ученик предыдущего раунда становится учителем для следующего. Это позволяет постепенно сжимать модель в несколько раз.

#### Специализированные архитектуры для мобильных и встраиваемых систем 

Развитие граничных вычислений и интернета вещей привело к росту спроса на компактные нейросети, способные работать на устройствах с ограниченными вычислительными ресурсами. Проектировать такие архитектуры вручную сложно: нужно учитывать множество конфликтующих требований — точность, скорость, энергопотребление, размер модели. [NAS‑алгоритмы](https://en.wikipedia.org/wiki/Neural_architecture_search) позволяют автоматизировать этот процесс: так можно и сэкономить время, и получить на выходе высокое качество.

Наиболее известные семейства мобильных архитектур, разработанных с помощью NAS — это MobileNets и EfficientNets. Они используют общие принципы:

- Глубокие сверточные блоки с pointwise (1×1) свертками для сокращения числа каналов. Такая bottleneck‑структура позволяет снизить вычислительную стоимость при том же рецептивном поле.
    
- Depthwise‑separable свертки, которые факторизуют стандартные свертки на depthwise (применяются независимо к каждому каналу) и pointwise (смешивают каналы). Они требуют в несколько раз меньше параметров и операций.
    
- Инвертированные остаточные блоки (inverted residuals), где узким местом является вход, а не выход блока, что позволяет эффективнее использовать память активаций и улучшить скорость.
    
- Сбалансированное масштабирование глубины, ширины и разрешения сети пропорционально вычислительному бюджету. Подбор оптимальных коэффициентов масштабирования с помощью NAS позволяет получить семейство моделей для различных сценариев использования.
    

Комбинация этих техник делает MobileNets и EfficientNets в несколько раз более эффективными, чем обычные сверточные сети, при той же точности. Например, EfficientNet‑B0 достигает точности ImageNet 77.1% с 5.3M параметров и 0.39B умножений, что на порядок меньше, чем у ResNet-50. Более крупные модели EfficientNet‑B7 превосходят даже чемпионов соревнований по точности вроде GPipe при существенно меньших затратах.

Помимо MobileNets и EfficientNets существуют и другие архитектуры, оптимизированные под мобильные устройства. ShuffleNets используют операцию перемешивания каналов для повышения их связности при малых вычислительных затратах. SqueezeNets применяют bottleneck‑слои и сокращают число параметров в 50 раз относительно AlexNet. MnasNets и ProxylessNAS ищут архитектуры, оптимальные по комбинации точности и времени работы на конкретном «железе». Однако на сегодняшний день MobileNets и EfficientNets остаются самыми популярными решениями, на основе которых строится множество прикладных систем компьютерного зрения для мобильных и встраиваемых платформ.

#### Автоматический поиск архитектур (Neural Architecture Search)

Хотелось бы также ненадолго остановиться на самой технологии NAS.

Автоматический поиск архитектур нейронных сетей — это подход к автоматизации проектирования моделей глубокого обучения с помощью методов оптимизации. Цель NAS — найти архитектуру, максимизирующую заданную метрику качества (например, точность) на определенном наборе данных при выполнении ресурсных ограничений.

Первые работы по NAS появились еще в 1980-х, но подход стал активно развиваться только в последние годы благодаря росту вычислительных мощностей и успехам AutoML. Прорывом стала [статья Зофа и Ли 2017 года](https://arxiv.org/abs/1611.01578), в которой авторы применили обучение с подкреплением для поиска архитектуры сверточной сети на наборе данных CIFAR-10. Найденная модель превзошла по точности лучшие аналоги, разработанные вручную. С тех пор были предложены десятки новых алгоритмов NAS, использующих различные методы оптимизации и функции оценки качества.

![Обзор поиска нейронных архитектур. Стратегия поиска итеративно выбирает архитектуры (обычно с помощью метода кодирования архитектуры) из заранее определенного пространства поиска A. Архитектуры передаются стратегии оценки производительности, которая возвращает оценку производительности стратегии поиска. Для одноразовых методов стратегия поиска и стратегия оценки производительности неразрывно связаны между собой. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/cf1/3bc/5d8/cf13bc5d87825a8feeec76863da33b5e.png "Обзор поиска нейронных архитектур. Стратегия поиска итеративно выбирает архитектуры (обычно с помощью метода кодирования архитектуры) из заранее определенного пространства поиска A. Архитектуры передаются стратегии оценки производительности, которая возвращает оценку производительности стратегии поиска. Для одноразовых методов стратегия поиска и стратегия оценки производительности неразрывно связаны между собой. Источник")

_Обзор поиска нейронных архитектур. Стратегия поиска итеративно выбирает архитектуры (обычно с помощью метода кодирования архитектуры) из заранее определенного пространства поиска A. Архитектуры передаются стратегии оценки производительности, которая возвращает оценку производительности стратегии поиска. Для одноразовых методов стратегия поиска и стратегия оценки производительности неразрывно связаны между собой._ [_Источник_](https://arxiv.org/pdf/1808.05377)

Типичный алгоритм NAS состоит из трех основных компонентов:

1. Пространство поиска, то есть набор кандидатов архитектур, которые будут рассматриваться. Обычно оно параметризуется в виде направленного ациклического графа (DAG), узлы которого соответствуют вычислительным блокам (сверткам, пулинг‑операциям, активациям), а ребра — потокам данных. Варьируемые гиперпараметры могут включать типы операций, их параметры (размеры ядер и карт признаков), топологию соединений. Удачный выбор пространства поиска критически важен — оно должно быть достаточно широким для нахождения новых архитектур, но не настолько огромным, чтобы делать полный перебор невозможным.
    

2. Второй компонент — стратегия поиска, то есть алгоритм оптимизации, который ищет в пространстве поиска архитектуру с наилучшим качеством. Наиболее популярные подходы включают эволюционные алгоритмы, которые поддерживают популяцию архитектур и на каждой итерации отбирают наиболее приспособленные, скрещивают и мутируют их; байесовскую оптимизацию, которая строит вероятностную модель (суррогат) зависимости качества от архитектуры и на каждой итерации выбирает наиболее перспективные точки для измерения; обучение с подкреплением, которое рассматривает NAS как задачу на принятие решений, где агент‑контроллер генерирует архитектуры (действия), получает за них награду (точность на валидации) и оптимизирует свою стратегию генерации; градиентные методы, которые релаксируют дискретное пространство поиска до непрерывного и оптимизируют архитектуру стандартным градиентным спуском совместно с весами.
    

3. Третий компонент — стратегия оценки производительности, то есть способ оценить качество каждой архитектуры‑кандидата для выбора лучшей. Самый надежный, но и самый дорогой способ — полное обучение с нуля на прямом прогоне. Для ускорения используют различные приближения: обучение на малом числе эпох или малом подмножестве данных, экстраполяцию кривых обучения, совместное обучение всех архитектур в суперсети (one‑shot NAS), прогнозирование по косвенным признакам без обучения (zero‑cost NAS).
    

Комбинируя эти три компонента, современные NAS‑методы способны находить архитектуры, превосходящие лучшие ручные модели, при умеренных вычислительных затратах.

В целом, NAS становится все более эффективным и удобным инструментом автоматизации глубокого обучения. Хотя полная автоматизация глубокого обучения пока остается недостижимой, NAS существенно ускоряет и удешевляет создание специализированных моделей.

### Продвинутые методы оптимизации

Оптимизировать процесс обучения нейросетей можно не только с помощью аппаратных ускорителей и эффективных структур данных, но и на уровне алгоритмов оптимизации. Существует множество продвинутых методов и техник, позволяющих ускорить сходимость, улучшить обобщающую способность и робастность моделей. Давайте рассмотрим некоторые из наиболее эффективных подходов.

#### Адаптивные методы оптимизации

Адаптивные методы оптимизации, такие как AdaGrad, AdaDelta и Adam, получили широкое распространение благодаря своей способности динамически настраивать скорость обучения для каждого параметра на основе истории градиентов.

![Здесь показано поведение алгоритмов в «седловой точке», то есть в точке, где одно измерение имеет положительный наклон, а другое — отрицательный, что представляет сложность для SGD. SGD, Momentum и NAG испытывают трудности с нарушением симметрии, хотя двум последним в конце концов удается избежать седловой точки, в то время как Adagrad, RMSprop и Adadelta быстро устремляются вниз по отрицательному склону. Источник](https://habrastorage.org/getpro/habr/upload_files/6ea/89a/b3f/6ea89ab3f0f5f10980323f3401169fd5.gif "Здесь показано поведение алгоритмов в «седловой точке», то есть в точке, где одно измерение имеет положительный наклон, а другое — отрицательный, что представляет сложность для SGD. SGD, Momentum и NAG испытывают трудности с нарушением симметрии, хотя двум последним в конце концов удается избежать седловой точки, в то время как Adagrad, RMSprop и Adadelta быстро устремляются вниз по отрицательному склону. Источник")

_Здесь показано поведение алгоритмов в «седловой точке», то есть в точке, где одно измерение имеет положительный наклон, а другое — отрицательный, что представляет сложность для SGD. SGD, Momentum и NAG испытывают трудности с нарушением симметрии, хотя двум последним в конце концов удается избежать седловой точки, в то время как Adagrad, RMSprop и Adadelta быстро устремляются вниз по отрицательному склону._ [_Источник_](https://www.ruder.io/optimizing-gradient-descent/#adam:~:text=Image%206%20shows,the%20negative%20slope.)

AdaGrad уменьшает скорость обучения для часто встречающихся признаков и увеличивает для редких, используя накопленную сумму квадратов градиентов в знаменателе. AdaDelta заменяет эту сумму на экспоненциальное скользящее среднее квадратов градиентов, что делает настройку более гибкой и не требует ручного выбора глобальной скорости обучения.

Adam комбинирует идеи AdaGrad и RMSProp, оценивая первый и второй моменты градиентов (среднее и несмещенную дисперсию) и используя их для масштабирования скорости обучения. За счет этого Adam часто сходится быстрее других методов и менее чувствителен к выбору гиперпараметров.

Однако у адаптивных методов есть и недостатки: они могут хуже работать для задач с разреженными градиентами и неконвексными (non‑convex) функциями потерь. Поэтому на практике часто используют комбинации адаптивных и неадаптивных методов, например, переключаясь с Adam на SGD на поздних стадиях обучения.

#### Техники нормализации активации

Техники нормализации активаций, такие как BatchNorm, LayerNorm и GroupNorm, позволяют стабилизировать процесс обучения глубоких сетей за счет нормализации активаций на каждом слое.

![Обзор представленных методов нормализации. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/664/e35/63d/664e3563d69053bfd02828a24d66fc9b.png "Обзор представленных методов нормализации. Источник")

_Обзор представленных методов нормализации._ [_Источник_](https://theaisummer.com/normalization/)

BatchNorm нормализует каждый признак в пределах мини‑батча, вычитая среднее и деля на стандартное отклонение. Это позволяет решить проблему внутреннего ковариационного сдвига и использовать более высокие скорости обучения. Однако BatchNorm может ухудшать качество при малых размерах батча и в рекуррентных сетях.

LayerNorm и GroupNorm нормализуют активации в пределах одного примера (либо по всем признакам, либо по группам), что делает их более устойчивыми к размеру батча. Показано, что GroupNorm может успешно заменять BatchNorm в задачах компьютерного зрения, особенно при малых батчах.

#### Методы регуляризации

Регуляризация — важный инструмент для предотвращения переобучения и улучшения обобщающей способности моделей. Стандартные методы L1 и L2 регуляризации добавляют к функции потерь штраф, пропорциональный абсолютным значениям или квадратам весов соответственно. Это способствует их разреживанию и ограничивает их рост.

Техника Dropout состоит в случайном обнулении части активаций на каждом слое во время обучения. Это заставляет нейроны меньше полагаться друг на друга и учиться более робастным признакам. Dropout доказал свою эффективность для регуляризации и ускорения обучения многих архитектур — от стандартных CNN и RNN до современных трансформеров.

![Слева показана сеть без Dropout: все нейроны на скрытом слое участвуют в прямом проходе и обратном распространении ошибки. Справа — сеть с Dropout: случайным образом «выключена» часть нейронов скрытого слоя, они не участвуют в вычислениях и обновлении весов. Dropout помогает предотвратить переобучение, заставляя нейроны учиться более робастным признакам и снижая их взаимную зависимость. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/9d8/6b6/2e1/9d86b62e1ee6ac2f172b9d2f257b679e.png "Слева показана сеть без Dropout: все нейроны на скрытом слое участвуют в прямом проходе и обратном распространении ошибки. Справа — сеть с Dropout: случайным образом «выключена» часть нейронов скрытого слоя, они не участвуют в вычислениях и обновлении весов. Dropout помогает предотвратить переобучение, заставляя нейроны учиться более робастным признакам и снижая их взаимную зависимость. Источник")

_Слева показана сеть без Dropout: все нейроны на скрытом слое участвуют в прямом проходе и обратном распространении ошибки. Справа — сеть с Dropout: случайным образом «выключена» часть нейронов скрытого слоя, они не участвуют в вычислениях и обновлении весов. Dropout помогает предотвратить переобучение, заставляя нейроны учиться более робастным признакам и снижая их взаимную зависимость._ [_Источник_](https://wenkangwei.github.io/2020/11/13/DL-DropOut/#:~:text=How%20DropOut%20Work,will%20be%20zeros.)

Развитием Dropout стали такие методы как DropConnect (случайное обнуление весов вместо активаций), SpatialDropout (согласованное обнуление целых карт признаков), Stochastic Depth (случайное выключение целых блоков в остаточных сетях) и другие. Они позволяют более избирательно регуляризовать модель с учетом ее структуры.

Также для регуляризации применяется сглаживание меток классов (label smoothing). Вместо жестких целевых вероятностей 0 и 1 используются сглаженные значения, например 0.1 и 0.9. Это снижает излишнюю уверенность модели и улучшает калибровку ее предсказаний.

#### Методы ускорения сходимости

Для ускорения сходимости моделей глубокого обучения используются различные расписания изменения скорости обучения. Наиболее распространены методы с постепенным снижением скорости, такие как пошаговое уменьшение (step decay), экспоненциальное затухание (exponential decay) или косинусный отжиг (cosine annealing). Они позволяют начать обучение с высокой скорости для быстрого продвижения, а затем постепенно снизить ее для более точной настройки весов.

Интересной альтернативой являются циклические методы, например Cyclical Learning Rates. Они периодически увеличивают и уменьшают скорость обучения по треугольному или косинусному закону. Это позволяет обходить локальные минимумы и плато на поверхности потерь, ускоряя сходимость.

Также применяются методы «теплого» перезапуска оптимизации (warm restarts). Когда функция потерь перестает уменьшаться, оптимизация перезапускается с увеличенной скоростью обучения. Это помогает выбраться из неоптимальных точек и продолжить обучение. Примером является метод Stochastic Weight Averaging (SWA), который усредняет веса модели по траектории градиентного спуска.

Однако на практике все гораздо сложнее, и выбор конкретных методов и их гиперпараметров требует экспериментального подбора для каждой задачи и архитектуры. Перспективным направлением, с текущей точки зрения, кажется интеграция методов оптимизации с алгоритмами AutoML и NAS. Это позволит автоматически настраивать гиперпараметры оптимизации под конкретную задачу и находить оптимальные комбинации архитектур и алгоритмов обучения.

### Эффективная организация процесса обучения

Для успешного обучения глубоких нейронных сетей недостаточно только выбрать подходящую архитектуру и метод оптимизации. Не менее важно правильно организовать сам процесс обучения, включая подбор гиперпараметров, подготовку данных, распараллеливание вычислений и использование переноса знаний. Рассмотрим основные методы и подходы, позволяющие сделать обучение глубоких моделей более эффективным и масштабируемым.

#### Правильный подбор гиперпараметров

Производительность алгоритмов глубокого обучения сильно зависит от гиперпараметров, таких как скорость обучения, размер мини‑батча, коэффициенты регуляризации и многих других. Подбор оптимальных значений этих гиперпараметров является нетривиальной задачей, требующей значительных вычислительных ресурсов.

Традиционно для этого применяется метод полного перебора по сетке (grid search), но он быстро становится неосуществимым с ростом числа гиперпараметров. Более эффективной альтернативой является байесовский поиск (bayesian search), который строит вероятностную модель зависимости целевой метрики от гиперпараметров и на каждой итерации выбирает наиболее перспективную точку для измерения.

![Три стратегии поиска: Поиск по сетке осуществляется последовательно в соседних ячейках, случайный поиск — в произвольном порядке. Байесовский поиск использует априорные вероятности нахождения объекта в каждой ячейке и обновляет их по мере поиска, что позволяет более эффективно находить искомый объект. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/4ab/16a/a77/4ab16aa774b236453fdbcbd32fe12ad2.png "Три стратегии поиска: Поиск по сетке осуществляется последовательно в соседних ячейках, случайный поиск — в произвольном порядке. Байесовский поиск использует априорные вероятности нахождения объекта в каждой ячейке и обновляет их по мере поиска, что позволяет более эффективно находить искомый объект. Источник")

_Три стратегии поиска: Поиск по сетке осуществляется последовательно в соседних ячейках, случайный поиск — в произвольном порядке. Байесовский поиск использует априорные вероятности нахождения объекта в каждой ячейке и обновляет их по мере поиска, что позволяет более эффективно находить искомый объект._ [_Источник_](http://minjeancho.com/bayesian_search/bayesian_search.html)

Другой подход — это использование методов оптимизации на основе градиента, которые рассматривают гиперпараметры как дополнительные переменные модели и оптимизируют их совместно с весами с помощью градиентного спуска. Это позволяет находить хорошие значения гиперпараметров за меньшее число итераций, но может быть неустойчиво и требует модификации алгоритма обучения.

В последнее время набирают популярность методы AutoML, в частности, алгоритмы совместного поиска архитектур и гиперпараметров. Они позволяют автоматически находить оптимальные комбинации архитектурных блоков и значений гиперпараметров для заданной задачи и набора данных. Однако AutoML алгоритмы пока еще довольно ресурсоемки и не до конца раскрыли свой потенциал в деле.

#### Аугментация и предобработка данных

Качество и количество обучающих данных являются ключевыми факторами успеха глубокого обучения. Для улучшения обобщающей способности моделей и борьбы с переобучением широко применяются методы аугментации данных — генерации новых примеров на основе имеющихся путем различных преобразований.

![Техники аугментации данных для исходного изображения. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e88/775/da4/e88775da4edac5b0dca88d69a0385088.png "Техники аугментации данных для исходного изображения. Источник")

_Техники аугментации данных для исходного изображения._ [_Источник_](https://ubiai.tools/what-are-the-advantages-anddisadvantages-of-data-augmentation-2023-update/)

Например, в задачах компьютерного зрения популярна аугментация изображений с помощью случайных поворотов, отражений, сдвигов, изменений масштаба и цвета. В обработке естественного языка применяется случайная вставка, удаление и замена слов и предложений. Аугментация позволяет увеличить эффективный размер обучающей выборки и сделать модели более устойчивыми к шуму и вариациям в данных.

Другой важный аспект — предобработка и нормализация входных данных. Например, стандартизация изображений путем вычитания среднего и деления на стандартное отклонение ускоряет сходимость и улучшает качество моделей. В обработке текстов и графов большую роль играет представление объектов в виде плотных векторных эмбеддингов, полученных с помощью алгоритмов типа word2vec, GloVe, node2vec и т. д. Правильный выбор техник аугментации и предобработки под конкретную задачу может значительно улучшить результаты обучения.

#### Распределенное обучение на нескольких узлах

С ростом размера моделей и объема данных обучение глубоких нейросетей требует все больших вычислительных ресурсов и может занимать недели и месяцы даже на мощных GPU. Для ускорения обучения используются методы распределенных вычислений, позволяющие задействовать множество узлов одновременно.

Наиболее популярная схема распределенного обучения — это синхронный data‑parallel подход, когда каждый узел имеет свою копию модели и обрабатывает свой мини‑батч данных. Градиенты от всех узлов усредняются (через allreduce операцию) и используются для синхронного обновления весов на каждом узле. Этот подход эффективно масштабируется до сотен узлов и ускоряет обучение почти линейно с их числом. Его реализуют многие фреймворки глубокого обучения, такие как Horovod и PyTorch DDP.

![Процесс обучения на различных методах распараллеливания. Источник](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d42/4ad/dd6/d424addd6875a81eb45042f4228a1900.png "Процесс обучения на различных методах распараллеливания. Источник")

_Процесс обучения на различных методах распараллеливания._ [_Источник_](https://www.semanticscholar.org/paper/Efficient-and-Robust-Parallel-DNN-Training-through-Chen-Yang/d3b0d4b2ea111f9b560815487e65c2619d9cf15d/figure/0)

Менее популярны асинхронные схемы, в которых узлы обновляют общую модель независимо, без синхронизации. Они проще в реализации, но могут страдать от проблемы устаревших градиентов и давать худшую сходимость. Гибридным подходом является Stale‑Synchronous Parallel (SSP), допускающий ограниченную асинхронность — узлы могут отставать друг от друга не более чем на заданное число итераций.

Для эффективного распределенного обучения важно учитывать особенности конкретных моделей и аппаратных платформ. Например, для гигантских языковых моделей типа GPT-4 хорошо работает комбинация data и model parallel подходов. Для обучения на системах с множеством слабых узлов (например, мобильных устройствах) перспективны алгоритмы федеративного обучения. Оптимизация коллективных коммуникаций и алгоритмов сжатия градиентов позволяет дополнительно ускорить распределенное обучение.

#### Инкрементальное и трансферное обучение

Еще один способ ускорить обучение и улучшить обобщающую способность моделей — перенос знаний из ранее обученных моделей. Вместо обучения каждой модели с нуля мы можем взять готовую модель (например, ResNet, предобученную на ImageNet) и дообучить ее на целевой задаче, заморозив часть слоев. Это позволяет сэкономить вычислительные ресурсы и данные, а также улучшить качество в условиях небольших выборок.

Дальнейшим развитием идеи переноса знаний являются методы мета‑обучения, когда модель учится не решать конкретные задачи, а быстро адаптироваться к новым задачам, опираясь на свой прошлый опыт. Примерами метаобучающихся моделей можно назвать MAML, Prototypical Networks, Relation Networks. Они могут эффективно переносить знания между задачами, требуя лишь небольшого количества данных и итераций обучения для адаптации.

![Иллюстрация процесса метаобучения](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6b3/b65/5b5/6b3b655b5b292fa3e0d7cf6627a3dacc.jpg "Иллюстрация процесса метаобучения")

_Иллюстрация процесса метаобучения_

Близкой концепцией является инкрементальное или непрерывное обучение, когда модель обучается на потоке данных, постепенно адаптируясь к новым примерам и задачам без катастрофического забывания уже изученного. Для ее преодоления применяются методы регуляризации, реверсивные градиенты, обучение без забывания (LwF) и ряд других методов.

---

Как видите, тема крайне обширная. Чтобы не перегружать вас обилием информации, предлагаю остановиться здесь. Если вы знаете какие‑то новые интересные методы, которые мы не затронули, расскажите о них в комментариях. Встретимся в следующей статье, где мы рассмотрим, как эти и другие методы применяются на практике!