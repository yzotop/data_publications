---
tags:
  - data
source: habr
link: https://habr.com/ru/companies/X5Tech/articles/814579/
data_type:
  - AB tests
company: X5
author: X5
---


Всем привет!

Как и во многих других компаниях, в X5 существует огромное количество данных, зависящих от времени. Такие данные принято называть временными рядами (time-series). Это могут быть данные о продажах в магазинах, об остатках на складах или об удовлетворенности клиентов. Используя эти данные, мы хотим искать инсайты и приносить пользу бизнесу.

_Бутстрап_ является ценным инструментом — он позволяет генерировать множество синтетических выборок из исходных данных, на основе которых мы можем оценить распределение интересующей нас статистики и построить доверительные интервалы. Например, если нужно определить доверительный интервал для медианы или какого-то другого квантиля предсказаний, бутстрап позволяет это сделать, даже когда прямое аналитическое вычисление невозможно.

Для временных рядов бывает полезно оценить границы, в которых находятся параметры модели, из которой получен ряд. Кроме того, часто необходимо посчитать доверительный интервал, в котором находятся предсказания для объекта с использованием моделей машинного обучения. Однако обычные методы бутстрапа не подойдут для временных рядов, так как они не учитывают структуру таких данных.

В нашем обзоре мы рассмотрим, как различные модификации метода бутстрапа учитывают структурные особенности и зависимости в данных временных рядов. Особое внимание будет уделено объяснению, почему нельзя применять стандартный подход бутстрапа к временным рядам без учёта их структуры. Затем мы перейдем к обзору методов, которые позволяют эффективно решить эту проблему.

### Временной ряд и его свойства

#### Общие понятия

**Временной ряд (time‑series)** — это собранный в разные моменты времени статистический материал о значении каких‑либо параметров (в простейшем случае одного) исследуемого процесса. Каждая единица статистического материала называется измерением или точкой данных. Во временном ряде для каждого отсчёта должно быть указано время измерения или номер измерения по порядку:

![Y = Y_{t} : t \in T](https://habrastorage.org/getpro/habr/upload_files/c9f/ba7/930/c9fba79308c682c2850b631aeead7efb.svg)

На практике мы можем понимать временной ряд как таблицу, состоящую из метки времени (независимая переменная), а также соответствующего значения (зависимая переменная).

![Данные о выбросах углекислого газа в одном из итальянских городов](https://habrastorage.org/r/w1560/getpro/habr/upload_files/3ca/b4b/9f5/3cab4b9f5a64f73695f48e22f426197d.png "Данные о выбросах углекислого газа в одном из итальянских городов")

Данные о выбросах углекислого газа в одном из [итальянских городов](https://archive.ics.uci.edu/dataset/360/air+quality)

Выявление компонентов временного ряда (time-series decomposition) предполагает его разложение на _тренд (trend), сезонность (seasonality)_ и _остатки (residuals)_.

**Тренд (trend)** — это основная тенденция изменения временного ряда. Тренд может быть направлен вверх (положительный тренд) или вниз (отрицательный тренд). Он отражает общий характер изменений и может быть вызван фундаментальными факторами, такими как экономические тенденции, демографические изменения или другие долгосрочные воздействия. Вид тренда может быть определен с помощью построения функциональной модели статистическими методами.

**Сезонность (seasonality)** отражает периодические колебания в данных. Эти колебания могут быть связаны с сезонными факторами, такими как времена года, месяцы или дни недели. Например, продажи мороженого могут иметь сезонность с пиком в летние месяцы и спадом зимой.

**Остатки (residuals)** представляют собой непрогнозируемую составляющую в данных. Это то, что остается после удаления тренда и сезонности из данных. В идеальном случае остатки выглядят как случайные колебания, то есть математическое ожидание и дисперсия будут постоянны и независимы от времени. Если это не так, значит, мы недостаточно точно выделили тренд или сезонность. Таким образом, мы можем валидировать качество нашей декомпозиции при анализе остатков. При хорошей декомпозиции эти остатки будут выглядеть как случайные колебания.

![Пример декомпозиции временного ряда продаж магазинов из открытых данных Facebook Prophet](https://habrastorage.org/r/w1560/getpro/habr/upload_files/373/f7b/39f/373f7b39fdb23e79a1b3018214f2dcda.jpeg "Пример декомпозиции временного ряда продаж магазинов из открытых данных Facebook Prophet")

Пример декомпозиции временного ряда продаж магазинов из открытых данных [Facebook Prophet](https://raw.githubusercontent.com/facebook/prophet/master/examples/example_retail_sales.csv)

Временные ряды могут обладать разными свойствами. Остановимся на некоторых из них подробнее:  
  
**Строгая стационарность (strict stationarity)**. Пусть ![(X_t, ; t \in T)](https://habrastorage.org/getpro/habr/upload_files/2be/f35/5bc/2bef355bcb62598badeee8aab578c280.svg) будет стохастическим (случайным) процессом, то есть семейством случайных величин,  
индексируемых параметром ![t](https://habrastorage.org/getpro/habr/upload_files/10a/ff0/e3b/10aff0e3b0f95b80182f6c0688effa95.svg), изменяющихся в индексном множестве ![T](https://habrastorage.org/getpro/habr/upload_files/a5d/35e/e72/a5d35ee72c5e3b47c02b6bb08f7dfc21.svg).  
![F_X(x_{t_1+\tau}, \ldots, x_{t_n+\tau})](https://habrastorage.org/getpro/habr/upload_files/6ad/9a7/8bf/6ad9a78bfece9e7a51779d22f5d945b9.svg)представляет собой функцию совместного распределения ![{X_t}](https://habrastorage.org/getpro/habr/upload_files/ee1/ec4/a26/ee1ec4a26d6198e3e0b3cbebea6a3cd4.svg) в моменты времени ![t_1 + \tau, \ldots, t_n + \tau](https://habrastorage.org/getpro/habr/upload_files/5cd/6de/a40/5cd6dea40e1c42e800a5348a6020772e.svg). Тогда ![{X_t}](https://habrastorage.org/getpro/habr/upload_files/b43/8b9/c31/b438b9c31e9601b0587772af7e33fb81.svg)называется строго стационарным, если  
![F_X(x_{t_1+\tau}, \ldots, x_{t_n+\tau}) = F_X(x_{t_1}, \ldots, x_{t_n}), ;](https://habrastorage.org/getpro/habr/upload_files/38d/80a/47d/38d80a47d4c691da9955f0fee08fe0c8.svg) для всех ![\tau, t_1, \ldots, t_n \in T](https://habrastorage.org/getpro/habr/upload_files/457/09a/a97/45709aa978f17822f4c2f8e3d6cbd03c.svg)  
и для всех ![n \in \mathbb{N}_0](https://habrastorage.org/getpro/habr/upload_files/84c/c5c/e5e/84cc5ce5ec2632f80f7a1a6855fe2769.svg).

Для временного ряда строгая стационарность означает, что сдвиг во времени не меняет  
функцию совместного распределения, то есть характеристики ряда не меняются со временем, например, дисперсия и математическое ожидание.

![Строго стационарный ряд](https://habrastorage.org/r/w1560/getpro/habr/upload_files/9b7/0fd/c6f/9b70fdc6f93595997be835b32e37e01f.png "Строго стационарный ряд")

Строго стационарный ряд

**Слабая стационарность (weak stationary) или просто стационарность**. Для временного ряда ![X_t](https://habrastorage.org/getpro/habr/upload_files/b61/f5f/dd0/b61f5fdd08fa80f058eff480406b98a0.svg)с дискретными моментами времени ![t](https://habrastorage.org/getpro/habr/upload_files/2d1/dac/f88/2d1dacf887c35c98b07e9c3b480643c0.svg), можно сказать, что ряд считается слабо стационарным, если выполняются следующие условия:

1. **Математическое ожидание** ![(\mu)](https://habrastorage.org/getpro/habr/upload_files/cb6/8af/1f0/cb68af1f00d10bc20618cf606a28ce8c.svg)временного ряда не зависит от времени:  
    ![E[X_t] = \mu](https://habrastorage.org/getpro/habr/upload_files/a59/94d/1d3/a5994d1d30726e3b10354774f62eee66.svg)для всех ![t](https://habrastorage.org/getpro/habr/upload_files/ed7/9bb/f29/ed79bbf298666a52c7dc2cc1ad3fd9f0.svg)
    
2. **Дисперсия** ![(\sigma^2)](https://habrastorage.org/getpro/habr/upload_files/2c4/44e/032/2c444e03244d17ea4c3e7de90997ac15.svg)временного ряда не зависит от времени:
    
    ![Var[X_t] = \sigma^2 \leq \infty](https://habrastorage.org/getpro/habr/upload_files/72e/d9f/014/72ed9f014a5f4b8c76b1975718aae795.svg)
3. **Автоковариационная функция** ![Cov(x_t, x_{t + s}) = \gamma_s](https://habrastorage.org/getpro/habr/upload_files/381/195/3af/3811953aff3bc2aa04024cddd38f062f.svg) зависит только от длины интервала между моментами времени ![(t_1)](https://habrastorage.org/getpro/habr/upload_files/cdc/d91/9d5/cdcd919d53ed0af2ea3f1055be92b3fb.svg)и ![(t_2)](https://habrastorage.org/getpro/habr/upload_files/55d/d8d/096/55dd8d0967f83a92396bb866d14f2d59.svg):
    
    ![Cov(x_t, x_{t + s}) = Cov(x_{t + k}, x_{t + k + s}) = \gamma_s, ; k \in T](https://habrastorage.org/getpro/habr/upload_files/661/25f/004/66125f00435246448d3bd81a940c4fb6.svg)

![Слабостационарный ряд](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6a6/2e6/9bb/6a62e69bb3876634d26e44354a2b320f.png "Слабостационарный ряд")

[Слабостационарный ряд](https://www.asc.ohio-state.edu/de-jong.8/note1.pdf)

#### Свойства статистических оценок

1. **Несмещенная статистическая оценка** — это такая оценка параметра, которая в среднем равна истинному значению этого параметра. Математически это можно выразить следующим образом:
    
    ![\mathbb{E}(\hat{\theta}) = \theta](https://habrastorage.org/getpro/habr/upload_files/0e3/5c8/931/0e35c893142a56440d3d51786936a5d8.svg)
    
    Если ![\hat{\theta}](https://habrastorage.org/getpro/habr/upload_files/b78/d3b/949/b78d3b9496fab3f69ec1530d92e95d79.svg) — оценка параметра ![\theta](https://habrastorage.org/getpro/habr/upload_files/459/5b9/f6f/4595b9f6f0225846c8628e06e840a0b9.svg), то оценка называется несмещённой, если:
    
    где ![\mathbb{E}(\hat{\theta})](https://habrastorage.org/getpro/habr/upload_files/8f5/476/ae3/8f5476ae38040f9e3af1aae067f4e512.svg) обозначает математическое ожидание (среднее) оценки ![\hat{\theta}](https://habrastorage.org/getpro/habr/upload_files/2a1/8d6/094/2a18d60941ddc9558368cbe4628d425d.svg), а ![\theta](https://habrastorage.org/getpro/habr/upload_files/20e/a0d/891/20ea0d8915bcc8caff59d3295cf7eebd.svg) - истинное значение параметра.
    
    Несмещенная оценка в среднем не завышает и не занижает истинное значение параметра, поэтому это свойство является критически важным при оценке параметров.
    
2. **Состоятельная статистическая оценка** — это такая оценка параметра, которая с ростом объема выборки стремится к истинному значению этого параметра. Математически это можно выразить следующим образом:
    
    Если ![\hat{\theta}](https://habrastorage.org/getpro/habr/upload_files/53f/2ee/6cc/53f2ee6ccc861035c6ce2404fe94cd64.svg) — оценка параметра ![\theta](https://habrastorage.org/getpro/habr/upload_files/b26/940/3e9/b269403e9913b9efdf370570198a2e16.svg), то оценка называется состоятельной, если:
    
    ![\lim_{n \to \infty} \text{P}(|\hat{\theta} - \theta| < \epsilon) = 1, ; \forall \epsilon > 0](https://habrastorage.org/getpro/habr/upload_files/e7a/3d1/e85/e7a3d1e85dfbc4a48ca50cef1d19f137.svg)
    
    Состоятельная оценка с увеличением размера выборки становится все более точной по вероятности. Важно, чтобы при росте объема данных оценка параметра стремилась к истинному значению этого параметра, иначе такой оценке полноценно верить нельзя.
    
3. **Эффективная статистическая оценка** - это такая оценка параметра, которая обладает минимальной дисперсией среди всех возможных несмещенных оценок этого параметра. Математически это можно выразить следующим образом:
    
    Если ![\hat{\theta}](https://habrastorage.org/getpro/habr/upload_files/126/8c9/712/1268c9712f0a8b6e02f5eabe2c370748.svg) — оценка параметра ![\theta](https://habrastorage.org/getpro/habr/upload_files/920/6a7/f23/9206a7f23b8c483e67690566136d6258.svg), то оценка ![\hat{\theta}](https://habrastorage.org/getpro/habr/upload_files/a10/f7c/ab3/a10f7cab3a5745393f445faa5cfd5c57.svg) называется эффективной, если для любой другой несмещенной оценки ![\tilde{\theta}](https://habrastorage.org/getpro/habr/upload_files/dad/14f/fbe/dad14ffbeec9fda407c11462d0a9eb2d.svg) параметра ![\theta](https://habrastorage.org/getpro/habr/upload_files/c26/579/e75/c26579e75b7b9df15be7328aa9671696.svg) выполняется неравенство Крамера-Рао:
    
    ![Var(\hat{\theta}) \leq \text{Var}(\tilde{\theta})](https://habrastorage.org/getpro/habr/upload_files/502/803/e64/502803e64a9eb71b5340c77f858375d8.svg)
    
    То есть, чем меньше варьируется наша оценка параметра, тем больше мы можем быть уверены в этой оценке.
    

#### Почему это важно?

Чтобы надёжно оценить параметры временного ряда или построить доверительный интервал для его предсказаний, нам необходимо анализировать множество таких рядов. Однако, в реальности мы часто располагаем только одним набором наблюдений. В этом случае бутстрап приходит на помощь, позволяя нам смоделировать и исследовать различные сценарии и тем самым аппроксимировать истинное распределение с помощью эмпирических данных.

При этом, в основном ряды не являются стационарными. В таких случаях, нам необходимо исключить влияние тренда и сезонностей, чтобы привести остатки к как можно более стационарному виду (например, через декомпозицию).

Получив их в таком виде, мы можем применить к ним _классическое_ бутстрапирование. Если нам не удастся достичь стационарного вида остатков, при бутстрапе мы должны учесть связь между наблюдениями во времени. О методах бутстрапа, учитывающих зависимость данных во времени, речь пойдет в следующих главах.

После бутстрапирования, мы можем восстановить исходные временные ряды из исключенных компонент, получив эмпирическое распределение. На его основе уже можно делать выводы о доверительных интервалах _оценок параметров_ или _предсказаний_.

### Bootstrap

**Классический бутстрап** — это метод, который позволяет оценивать статистические характеристики (например, квантили, дисперсию) генеральной совокупности путем многократного случайного выбора элементов из существующей выборки с возвращением. Хотя прямое вычисление точечных оценок, таких как квантиль, может быть более точным и эффективным, бутстрап особенно полезен для оценки их изменчивости или доверительных интервалов. Таким образом, когда необходимо изучить распределение статистической меры, а не только её точечную оценку, бутстрап становится ценным инструментом. Алгоритм классического бутстрапа обычно включает следующие шаги:

На входе у нас есть выборка ![x_1, x_2,  \ldots , x_N \in X](https://habrastorage.org/getpro/habr/upload_files/0ed/481/087/0ed48108787744fdfd461f7b51bea799.svg), где ![N](https://habrastorage.org/getpro/habr/upload_files/eb7/930/a32/eb7930a32b3d33b4ccfd3f4e6508f99b.svg)— это размер выборки.

Для ![b = 1, 2,3, \ldots ,B](https://habrastorage.org/getpro/habr/upload_files/588/62b/167/58862b167553729b9710dd061905b7ca.svg) повторяем следующее (![B](https://habrastorage.org/getpro/habr/upload_files/b23/997/3c2/b239973c22406a8d8c48eb765812ea7d.svg) это параметр, указывающий, сколько псевдо выборок подлежат к рассмотрению):

1. Семплируем с возвращением точки ![x_1^{*(b)}, x_2^{*(b)},x_3^{*(b)}, \ldots , x_N^{*(b)}](https://habrastorage.org/getpro/habr/upload_files/760/6d8/35d/7606d835dbdaa8ece5c78591bcac67c3.svg) из того набора данных, который мы пронаблюдали (эмпирического распределения). Назовем эту выборку бутстрапным набором данных.
    
2. Посчитаем значение искомого параметра ![\bar A_b^{*} = A(x_1^{*(b)}, x_2^{*(b)},x_3^{*(b)}, \ldots , x_N^{*(b)})](https://habrastorage.org/getpro/habr/upload_files/b0b/239/001/b0b23900132ca4a10755929e2bd9c4eb.svg) и где-то сохраним результат.
    
3. Произведем шаг 1. и шаг 2. ![B](https://habrastorage.org/getpro/habr/upload_files/011/808/c79/011808c7987d27e1b8cda7a9706ac6bb.svg) раз.
    

Как итог, мы получаем новую выборку ![\bar A_1^{}, \bar A_2^{}, \ldots ,\bar A_b^{*}](https://habrastorage.org/getpro/habr/upload_files/6ee/454/b2a/6ee454b2ad8b273ebd17f55ed0f21b5d.svg)размера![B](https://habrastorage.org/getpro/habr/upload_files/f91/448/854/f9144885477f22af6f6759093c42d6e9.svg), состоящую из оценок искомого параметра.

На ее основе мы можем судить о доверительном интервале, в котором находится истинное значение статистики с заданной доверительной вероятностью. Обычно эту вероятность (уровень доверия) берут на уровне ![95\%](https://habrastorage.org/getpro/habr/upload_files/8b2/1b8/47b/8b21b847b724064d454f1f98644e015a.svg). Если говорить строго, то:

![\theta](https://habrastorage.org/getpro/habr/upload_files/22a/43c/207/22a43c207a67bc771e392b80a0d22c95.svg) — оцениваемый параметр (например среднее), ![L](https://habrastorage.org/getpro/habr/upload_files/e61/798/1a9/e617981a984ffd3e42d19558045fee74.svg) — нижняя граница интервала, ![U](https://habrastorage.org/getpro/habr/upload_files/ac4/da7/85a/ac4da785a50253f139b5ddf3f51165bb.svg) — верхняя граница, а ![1 - \alpha](https://habrastorage.org/getpro/habr/upload_files/33d/3d8/90e/33d3d890e7c16bcdba51c5d02e29594c.svg) — уровень доверия (где ![\alpha](https://habrastorage.org/getpro/habr/upload_files/65e/c0d/901/65ec0d90101e1f2b88bdbc5fb8be3e02.svg) — уровень значимости), тогда доверительный интервал для ![\theta](https://habrastorage.org/getpro/habr/upload_files/22a/43c/207/22a43c207a67bc771e392b80a0d22c95.svg) можно записать как:

![P(L < \theta < U) = 1 - \alpha](https://habrastorage.org/getpro/habr/upload_files/693/150/745/693150745a57a5c59e48cfdc158f2a37.svg)

где ![P](https://habrastorage.org/getpro/habr/upload_files/a62/aa1/03a/a62aa103ad8a1f279529c7d19674043f.svg)обозначает вероятность, что параметр находится в интервале между случайными величинами ![L](https://habrastorage.org/getpro/habr/upload_files/5d7/0f1/c73/5d70f1c738259464fc63d5c64b6ba509.svg) и ![U](https://habrastorage.org/getpro/habr/upload_files/e26/1c1/d4c/e261c1d4c9ca2b78315c745f4f6cf99c.svg).

И как будто на этом можно было бы и закончить, однако, этот метод работает корректно только с выборками, которые _независимо_ и _одинаково распределены (i.i.d.)_.

![Из статьи про бутстрап](https://habrastorage.org/r/w1560/getpro/habr/upload_files/518/1b0/7ec/5181b07ec0a58709699b1835cecd5e7a.png "Из статьи про бутстрап")

Из [статьи](https://towardsdatascience.com/an-introduction-to-the-bootstrap-method-58bcb51b4d60) про бутстрап

Бутстрап может быть применен в большом количестве практических приложений, поскольку запускается в три строчки кода на питоне. Его главный минус заключается в требовании к вычислительным мощностям при работе с большими выборками. Подробнее о бутстрапе можно прочитать в одной из наших [статей](https://habr.com/ru/companies/X5Tech/articles/679842/).

При работе с временными рядами, классический бутстрап может быть применен только для стационарных рядов, где автоковариационная функция остаётся постоянной во времени. При этом для нестационарных рядов есть риск неправильной интерпретации результатов.

Мы должны избавиться от _тренда_ и _сезонности_ — это делается для того, чтобы сделать временной ряд более стабильным и предсказуемым. После этого можно применить бутстрап к остаткам ряда, а затем восстановить данные, повторяя процесс ![B](https://habrastorage.org/getpro/habr/upload_files/b65/f94/95d/b65f9495df069e60b024abb1aac3d57f.svg) раз, получив матрицу размера ![(B, N)](https://habrastorage.org/getpro/habr/upload_files/6e3/61e/91f/6e361e91fbb1f5f65d611cc327cbf0d4.svg). Зачастую, предпосылки применения классического бутстрапа нарушаются, и в таком случае нам нужно учитывать зависимость данных между собой. О таких методах модифицированного бустрапа дальше и пойдет речь.

#### Постановка задачи

Представим, что мы уже избавились от тренда и сезонности. Попробуем на примере стационарного временного ряда, параметры которого нам известны и поддаются контролю, понять, как влияет выбор метода бустрапа на оценку параметров модели, из которой он был получен.

Пусть у нас есть временной ряд, полученный из авторегрессионной ![AR(2)](https://habrastorage.org/getpro/habr/upload_files/dca/ee0/511/dcaee051152ee1a79ee177bb2d68feb1.svg) модели вида:

![x_t = \phi_1 x_{t-1} + \phi_2 x_{t-2} + \epsilon_t, \; \epsilon_t \sim \mathcal{N}(0, 1), \; \phi_1 = 0.2, \; \phi_2 = 0.4, \; N = 300](https://habrastorage.org/getpro/habr/upload_files/071/c93/6e7/071c936e7a9e1847be09ee83ddc5a3cb.svg)

Представим, что мы знаем вид модели, из которой мы получили этот ряд. Мы хотим сделать _оценку_ параметров ![\hat{\phi}_1](https://habrastorage.org/getpro/habr/upload_files/945/358/1f8/9453581f8b9eb73acf1489d237c40fb5.svg) и ![\hat{\phi}_2](https://habrastorage.org/getpro/habr/upload_files/442/b4d/a54/442b4da54e814b83f743989a5b270884.svg) модели на основе этого ряда.

![Рассматриваемый временной ряд](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d4a/201/1cd/d4a2011cd778ff94ad6754bd9ae3d692.png "Рассматриваемый временной ряд")

Рассматриваемый временной ряд

Воспользуемся тем, что мы знаем вид модели и ее параметры, сгенерируем в дополнение к этому ряду еще ![B - 1](https://habrastorage.org/getpro/habr/upload_files/7d6/b6e/e90/7d6b6ee909e7992e0537b7f3749da948.svg) временных рядов, где ![B = 1000](https://habrastorage.org/getpro/habr/upload_files/295/d75/e4f/295d75e4f3bf831e4b83d1a7c9154539.svg) (параметр равен числу бутстрап итераций). Мы будем рассматривать эту выборку как генеральную совокупность (обозначим ее как ![True](https://habrastorage.org/getpro/habr/upload_files/8d6/a43/144/8d6a43144df9767e01ddededa247d643.svg)), к которой у нас нет доступа в реальной жизни, но есть доступ в рамках симуляции. Оценки параметров на основе этих данных будут являться эталоном для сравнения разных методов бутстрапа.

### Block bootstrap

Блочный бутстрап является наиболее общим методом для улучшения точности бутстрапа для временных рядов.

Разделяя данные на несколько блоков, он может сохранить оригинальную структуру временного ряда внутри блока. Однако точность блочного бутстрапа зависит от выбора длины блока, и оптимальная длина блока зависит от размера выборки, процесса генерации данных и рассматриваемой статистики.

Для того чтобы реализовать любой из методов блочного бутстрапа, нам необходимо выбрать (ожидаемую) длину блока. Оптимальная длина блока зависит от размера выборки и ее корреляционной структуры, и различается для разных методов блочного бутстрапа. Существуют два основных подхода к выбору длины блока: _метод перекрестной проверки_ и \emph{метод подстановки}. В методе перекрестной проверки мы выбираем критерий (например, среднеквадратичную ошибку) и минимизируем оцененный критерий, чтобы получить оценку оптимального размера блока. В методе подстановки мы сначала выражаем оптимальный размер блока через модельные параметры, а затем подставляем оценки этих параметров для получения конкретного значения размера блока. Метод перекрестной проверки обычно требует меньше аналитической работы, но требует больше вычислений.

Идея блочного бутстрапа лучше всего иллюстрируется на примере. Предположим у нас есть временной ряд:

![X_1, X_2, X_3, X_4, X_5, X_6, X_7, X_8, X_9, X_{10}](https://habrastorage.org/getpro/habr/upload_files/c5f/1b1/16d/c5f1b116da010eaf9a6a75ad6e2ea3ea.svg)

Первое, что мы делаем, это разбиваем его на блоки. Для этого нам нужно определить, сколько наблюдений поместить в каждую группу. Допустим, мы будем использовать две точки данных в каждом блоке.

![\overbrace{X_1, X_2}^{\text {block } 1}, \overbrace{X_3, X_4}^{\text {block } 2}, \overbrace{X_5, X_6}^{\text {block3 }}, \quad \overbrace{X_7, X_8}^{\text {block } 4}, \overbrace{X_9, X_{10}}^{\text {block5 }}.](https://habrastorage.org/getpro/habr/upload_files/980/525/6bb/9805256bbae434ccd8525b89fff1f39a.svg)

После определения блоков мы можем провести бутстрап. Это делается путем формирования новой выборки, в которой блоки извлекаются с возвращением, то есть каждый блок, после того как был извлечен, возвращается в общий пул и может быть выбран снова. Следовательно, порядок извлечения блоков определяет их расположение в бутстрап-выборке. Например, бутстрап-выборка блоков может быть сформирована следующим образом:

![block3, \quad block 1, \quad block 5 , \quad block 2, \quad block 5](https://habrastorage.org/getpro/habr/upload_files/681/b95/78f/681b9578f2e087ddc4f403484966071f.svg)

или, с точки зрения исходного ряда,

![X_5, X_6, \quad X_1, X_2, \quad X_9, X_{10}, \quad X_3, X_4, \quad X_9, X_{10}](https://habrastorage.org/getpro/habr/upload_files/a60/301/c2d/a60301c2d7069a4e139fa7d6ea3d67b0.svg)

Это основная идея бутстрапа временных рядов — разбить ряд на последовательные блоки, а затем повторно выбрать эти блоки. Это позволяет нам получить новый ряд с той же (краткосрочной) структурой зависимости. Для состоятельности оценки необходимо, чтобы размер блоков рос медленнее, чем размер выборки, и чтобы блоки были репрезентативными для исходной выборки. Для эффективности необходимо, чтобы размер блоков был оптимальным, то есть минимизировал дисперсию оценки.

Один из ранних вариантов блочного бутстрапа, предложенный Карльштейном (1986), ограничивает внимание на наборе непересекающихся блоков данных и формирует выборку из этого набора для генерации бутстрап-наблюдений. Это метод также называют блочным бутстрапом без перекрытия (_NBB_). Чтобы кратко описать его, предположим, что ![\ell](https://habrastorage.org/getpro/habr/upload_files/55c/0d9/d31/55c0d9d31b0b22df6df53f6e37a69e91.svg) — целое число в промежутке ![(1, n)](https://habrastorage.org/getpro/habr/upload_files/137/ee8/927/137ee8927250c781ee82e37c470d9134.svg). Также, для упрощения, предположим, что ![\ell](https://habrastorage.org/getpro/habr/upload_files/ac6/b99/4ad/ac6b994ad8febb41f107d27c96ab6a91.svg) делит ![n](https://habrastorage.org/getpro/habr/upload_files/fa2/e67/6e3/fa2e676e39c18b15c76f9a3a618cec48.svg) и установим ![b=n / \ell](https://habrastorage.org/getpro/habr/upload_files/fbf/cad/8d9/fbfcad8d9c85f6d321ea22d56aa740d7.svg). Бутстрап-наблюдения NBB генерируются путем случайного выбора ![b](https://habrastorage.org/getpro/habr/upload_files/bf9/e2d/64a/bf9e2d64ab9e924eba9d3eeed0dcc924.svg) блоков с возвращением из коллекции ![\left\{\tilde{\mathbb{B}}_1, \ldots, \tilde{\mathbb{B}}_b\right\}](https://habrastorage.org/getpro/habr/upload_files/e88/42a/130/e8842a13033980032fde9ba71100c378.svg), где

![\begin{aligned}    & \tilde{\mathbb{B}}_1=\left(X_1, \ldots, X_{\ell}\right), \\    & \tilde{\mathbb{B}}_2=\qquad\qquad\qquad\left(X_{\ell+1}, \ldots, X_{2 \ell}\right), \\  & \tilde{\mathbb{B}}_b= \qquad\qquad\qquad\qquad\qquad\qquad\qquad\left(X_{(b-1) \ell+1}, \ldots, X_n\right) \text {. } \\\end{aligned}](https://habrastorage.org/getpro/habr/upload_files/ff2/a9d/9b6/ff2a9d9b648c519dd94d64da54e8aeba.svg)

![Иллюстрация метода NBB](https://habrastorage.org/r/w1560/getpro/habr/upload_files/17f/452/e45/17f452e450203cdd150cc6760160969b.png "Иллюстрация метода NBB")

Иллюстрация метода NBB

Оценка методом non-overlapping bootstrap может быть лучше, чем оценка методом block bootstrap, если данные имеют слабую или среднюю зависимость и длина блока достаточно большая, чтобы уловить структуру зависимости.

**NBB имеет следующие свойства:**

1. _Несмещенность_: NBB является несмещенным методом оценки, если длина блока b стремится к бесконечности при увеличении размера выборки n. Это означает, что среднее значение бутстрапных оценок сходится к истинному значению статистики при ![n \rightarrow \infty](https://habrastorage.org/getpro/habr/upload_files/f03/6c0/6ab/f036c06ab38e22739defb34b13e605d1.svg) и ![b \rightarrow \infty](https://habrastorage.org/getpro/habr/upload_files/926/f1b/493/926f1b4933c89cfc6fa4856443497345.svg).
    
2. _Состоятельность_: NBB является состоятельным методом оценки, если отношение b/n стремится к нулю при увеличении n. Это означает, что распределение бутстрапных оценок сходится к истинному распределению статистики при ![n \rightarrow \infty](https://habrastorage.org/getpro/habr/upload_files/413/025/2f8/4130252f855b64cc0ae08b299cf351be.svg) и ![b/n \rightarrow \infty](https://habrastorage.org/getpro/habr/upload_files/e86/0c1/cda/e860c1cda7cfaecd2dad9fcdfe880226.svg).
    
3. _Эффективность_**:** NBB считается эффективным методом оценки, когда он обеспечивает наименьшую дисперсию оценки по сравнению с другими методами бутстрапа для конкретной статистики. Это достигается через выбор оптимальной длины блока b, которая наилучшим образом учитывает структуру зависимости в данных. Для определения оптимальной длины блока используются различные критерии, включая правило Холла-Хоровица, правило Политиса-Романо и правило Люнгбокса.
    

![Оценка параметров временного ряда c использованием NBB](https://habrastorage.org/r/w1560/getpro/habr/upload_files/21c/859/a12/21c859a12b770c78afc92bbe226f946e.png "Оценка параметров временного ряда c использованием NBB")

Оценка параметров временного ряда c использованием NBB

Однако, несмотря на многие преимущества метода, одна из обычных проблем при использовании NBB заключается в том, что общее количество блоков часто оказывается недостаточным. В результате бутстрап-выборки не отражают полную статистическую вариативность данных, что может привести к некорректным статистическим выводам. Для устранения этой проблемы можно применить метод _moving-block bootstrap._

#### Moving block bootstrap

Для применения метода moving-block bootstrap _(MBB)_ сначала нужно определить размер блока, который будет использоваться для формирования новых выборок. Затем исходная выборка разбивается на несколько блоков равного размера. Каждый блок перемещается по выборке с некоторым шагом и используется для формирования новой выборки путем случайного выбора элементов из данного блока с возвращением. Таким образом, каждая новая выборка будет иметь тот же размер и ту же структуру блоков, что и исходная выборка. Затем, на основе каждой новой выборки вычисляется интересующий нас статистический параметр. Повторяя этот процесс множество раз, мы получаем распределение данного параметра.

![Иллюстрация moving-block bootstrap](https://habrastorage.org/r/w1560/getpro/habr/upload_files/806/1c6/3fa/8061c63fa411a5adc096cbf05830bc96.png "Иллюстрация moving-block bootstrap")

Иллюстрация moving-block bootstrap

Использование метода moving-block bootstrap позволяет учесть зависимость между данными в выборке и получить более реалистичные оценки распределения параметров. Вспомним, что блоки в конструкции NBB не перекрываются, из-за этого теоретические свойства оценок NBB легче анализировать, чем свойства оценок MBB. Однако оценки NBB обычно имеют более высокую среднеквадратическую ошибку при любом размере блока ![\ell](https://habrastorage.org/getpro/habr/upload_files/74d/ed8/488/74ded84884ac10060b12ac1b1367d1c5.svg) по сравнению с MBB.

Свойства оценки методом MBB зависят от выбора длины блока ![\ell](https://habrastorage.org/getpro/habr/upload_files/252/a06/c17/252a06c17703c19bb9471d2b25033ac7.svg) и количества повторений B. В общем случае, можно сказать следующее:

1. _Несмещённость_: Оценка методом MBB будет несмещенной, если длина блока ![\ell](https://habrastorage.org/getpro/habr/upload_files/83a/e4d/1f7/83ae4d1f7944b9f50897986494bf4d50.svg) увеличивается с ростом объема выборки n таким образом, что ![\ell](https://habrastorage.org/getpro/habr/upload_files/2f0/b3f/eca/2f0b3feca9830732408fa80c5b37390d.svg) растет медленнее, чем квадратный корень из n.
    
2. _Состоятельность_: Оценка методом MBB будет состоятельной, если длина блока ![\ell](https://habrastorage.org/getpro/habr/upload_files/101/f2c/61f/101f2c61f8933f824a1225d7b8687a80.svg) увеличивается быстрее, чем логарифм от объема выборки n.
    
3. _Эффективность_: Оценка методом MBB считается эффективной, когда длина блока ![\ell](https://habrastorage.org/getpro/habr/upload_files/6a0/338/f17/6a0338f170f4a399f9049342b73a68ab.svg) выбирается таким образом, чтобы наилучшим образом учесть характеристики временного ряда. Для определения оптимальной длины блока могут применяться различные методы, включая анализ политропического спектра или выбор на основе минимизации среднеквадратичной ошибки.
    

![Оценка параметров временного ряда c использованием MBB](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5f0/110/e98/5f0110e980f3e1160c2ecd718567289e.png "Оценка параметров временного ряда c использованием MBB")

Оценка параметров временного ряда c использованием MBB

#### Circular block bootstrap

Цель метода Circular block bootstrap _(CBB)_ — это устранение эффекта неравномерного взвешивания наблюдений на краях, который возникает в методе MBB. В MBB, например, первое значение выборки появляется только в первом блоке, в то время как пятое значение будет встречаться в пяти блоках, если b > 5. В CBB блоки формируются аналогично MBB, с перекрытием, но дополнительно используется 'циклическое' обертывание данных, когда конец последовательности соединяется с её началом, позволяя таким образом сформировать дополнительные блоки. Этот метод особенно ценен для данных с круговой природой, как, например, годовые циклы температур.

![Иллюстрация circular block bootstrap](https://habrastorage.org/r/w1560/getpro/habr/upload_files/599/a38/e23/599a38e23f8601b6908143f04c655b7d.png "Иллюстрация circular block bootstrap")

Иллюстрация circular block bootstrap

"Обернутый круг" определяется как ![X_i \equiv X_j](https://habrastorage.org/getpro/habr/upload_files/781/672/8b8/7816728b809e2f15fac1808e88f3f0fe.svg) для ![i>n](https://habrastorage.org/getpro/habr/upload_files/0c0/786/8a8/0c07868a8664b7c766fe9a15fba08b26.svg), где ![j=i \bmod n](https://habrastorage.org/getpro/habr/upload_files/18a/3e2/880/18a3e2880177bc7fa6190f64120af1d7.svg), и ![X_0=X_n](https://habrastorage.org/getpro/habr/upload_files/e3e/92f/df9/e3e92fdf9bbfc56efa58ca97aeac8cc9.svg).

Как упоминалось выше, пусть ряд будет иметь вид ![\left\{X_1, \ldots, X_n\right\}](https://habrastorage.org/getpro/habr/upload_files/735/43b/e35/73543be358ad2a5cd2b1f62660949fd9.svg), тогда весь дуговой сегмент "обернутого круга" будет ![\left\{X_1, \ldots, X_n, X_1, \ldots, X_{n+l-1}\right\}](https://habrastorage.org/getpro/habr/upload_files/fe2/a0e/fa2/fe2a0efa2a5dfcc85b337561e894baa4.svg); таким образом, установив длину блока равной l, получим в целом n блоков, и каждый блок определяется как ![Y_i=\left\{X_i, \ldots, X_{i+l-1}\right\}](https://habrastorage.org/getpro/habr/upload_files/7ff/5fb/ad3/7ff5fbad3e3d46f5014ef8eaf68c792e.svg).

Множество блоков представлено как ![\left\{Y_1, \ldots, Y_n\right\}](https://habrastorage.org/getpro/habr/upload_files/797/280/b8b/797280b8b737a9298ac1324b024dd87a.svg). С вероятностью ![1 / n](https://habrastorage.org/getpro/habr/upload_files/c82/ea7/f16/c82ea7f16364cf7745b968a585bdc732.svg) производится выборка с возвращением, случайным образом выбираются ![b](https://habrastorage.org/getpro/habr/upload_files/411/845/ccf/411845ccfa4a434dcd7f8f1d96fb1545.svg) независимых и одинаково распределенных блоков из этого множества, где ![l b=m \approx n](https://habrastorage.org/getpro/habr/upload_files/3d7/8bc/a03/3d78bca03dea703273330321dd331b75.svg). Затем у нас появляется новая последовательность ![X_1^*, \ldots, X_m^*](https://habrastorage.org/getpro/habr/upload_files/6d9/37b/480/6d937b480dac12a25c1111e95a963979.svg). С использованием этой новой последовательности также можно рассчитать доверительный интервал.

Свойства оценки методом CBB зависят от длины блока, которая должна быть достаточной, чтобы учитывать корреляцию между наблюдениями. В общем случае, оценка методом CBB обладает следующими свойствами:

1. _Несмещенность_: оценка методом CBB считается несмещенной, если длина блока увеличивается, но не слишком быстро по сравнению с размером всего временного ряда. То есть длина блока должна расти, но так, чтобы каждый элемент временного ряда имел высокую вероятность включения в блок. Это обеспечивает равномерное представление всех элементов в анализе, минимизируя искажение результатов.
    
2. _Состоятельность_: оценка методом CBB является состоятельной, если длина блока стремится к бесконечности со скоростью большей, чем логарифм от объема выборки. Это условие гарантирует, что вероятность того, что блок содержит два исходных наблюдения, стремится к нулю.
    
3. _Эффективность_: оценка методом CBB является асимптотически нормальной с той же дисперсией, что и оценка методом MBB. Однако, в конечных выборках оценка методом CBB может быть более эффективной, чем оценка методом MBB, так как она лучше учитывает зависимость между наблюдениями.
    

Преимущества метода CBB по сравнению с NBB и MBB заключаются в следующем:

1. Метод CBB уменьшает эффект края, который возникает при использовании метода MBB. Эффект края означает, что начальные и конечные значения данных всегда будут начинать или заканчивать блок соответственно, что может привести к искажению распределения оценок.
    
2. Метод CBB позволяет использовать все данные для построения доверительных интервалов, в то время как метод NBB использует только часть данных, которая делится на непересекающиеся блоки. Это может привести к потере эффективности оценок.
    
3. Метод CBB подходит для данных с периодической или почти периодической структурой, так как он сохраняет эту структуру при оборачивании данных на круг. Методы NBB и MBB могут нарушить эту структуру при разбиении данных на блоки.
    

![Оценка параметров с использованием CBB](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fff/832/c51/fff832c518441a36b950a3bc522b9a97.png "Оценка параметров с использованием CBB")

Оценка параметров с использованием CBB

#### Stationary bootstrap

Стационарный бутстрап (_SB_) отличается от других трёх методов, упомянутых ранее, тем, что длина блока не фиксирована, а является случайной величиной с некоторым распределением (обычно геометрическим) и ожидаемым значением ![l](https://habrastorage.org/getpro/habr/upload_files/c23/b7b/12c/c23b7b12c797bbc5179e456f6c02f1ab.svg). Из-за случайной длины блока количество блоков также является случайным. Подобно CBB, метод SB был разработан с целью устранения неравномерного взвешивания наблюдений в начале и в конце ряда. Дополнительный источник случайности возникает из выбора точек начала блоков. Это аналогично случайному выбору блоков в методе MBB, поскольку каждая точка данных в последовательности является началом блока в MBB.

Предположим, что ![\left\{X_t\right\}](https://habrastorage.org/getpro/habr/upload_files/86d/5c8/0ff/86d5c80ff9fb0f8dbc77a759117c131b.svg) - заданный слабо стационарный временной ряд, как уже упоминалось ранее. Определим каждый блок как ![B_{i, l}=\left\{X_i, X_{i+1}, \cdots, X_{i+l-1}\right\}](https://habrastorage.org/getpro/habr/upload_files/c89/f08/1e5/c89f081e5221ea0cbf35535afca056da.svg), где ![l](https://habrastorage.org/getpro/habr/upload_files/dc9/a8e/64f/dc9a8e64f9b1e385e6f3e185dccd36ad.svg) - длина блока. Поскольку, когда мы случайным образом выбираем начальную точку каждого блока и длина блока имеет геометрическое распределение, наблюдения в некоторых блоках могут выходить за пределы данной выборки. Чтобы гарантировать, что все наблюдения будут включены в блоки и не будет 'обрезания' данных на краях, можно использовать технику 'обертывания' ряда. 'Обертывание' означает, что конец временного ряда соединяется с его началом, образуя замкнутую циклическую структуру:

![X_i \equiv X_j\;\text{для}\; i>n,\;\text{где}\;j=i(\bmod n),\;\text{и}\;X_0=X_n](https://habrastorage.org/getpro/habr/upload_files/533/037/1c9/5330371c940317ff6b5042e2994216fe.svg)

Поскольку длины блоков могут быть разными, определим ![l_1, l_2, \cdots](https://habrastorage.org/getpro/habr/upload_files/290/908/3d1/2909083d170e54292ddb5695db06bbaf.svg) как длину блока, независимую от ![X_i](https://habrastorage.org/getpro/habr/upload_files/ace/dc1/45e/acedc145e7184f6f516f14a89a247276.svg), и ![\left\{l_i\right\}](https://habrastorage.org/getpro/habr/upload_files/36a/c0e/e79/36ac0ee7912ada91efd3078159986d36.svg) — последовательность независимых одинаково распределенных случайных величин, имеющих геометрическое распределение:

![P\left\{l_i=u\right\}=\left(1-p_S\right)^{u-1} p_S \;\text{для}\;u=1,2, \ldots.](https://habrastorage.org/getpro/habr/upload_files/09a/fb9/77b/09afb977b45f6582161cf236e939e030.svg)

Тогда для любого заданного ![p_S](https://habrastorage.org/getpro/habr/upload_files/97f/2ce/3f8/97f2ce3f8da3ff89c41985996304d9e7.svg) мы можем сгенерировать последовательность ![\left\{l_i\right\}](https://habrastorage.org/getpro/habr/upload_files/f3a/285/fff/f3a285fffe584651c1b7d705d0db98a8.svg). Что касается индекса начальной точки каждого блока ![i_i](https://habrastorage.org/getpro/habr/upload_files/df1/171/7a1/df11717a15d3a8452f9fecae3db6c0de.svg), независимого от ![X_i](https://habrastorage.org/getpro/habr/upload_files/e0e/993/415/e0e993415637c09273a1edbd1045e833.svg) и ![l_i](https://habrastorage.org/getpro/habr/upload_files/7a1/6d1/5fa/7a16d15fa7728fb63adcf73f53ed1a9b.svg), случайно выбираем из ![\{1, \ldots, n\}](https://habrastorage.org/getpro/habr/upload_files/9e9/b11/37a/9e9b1137a8d85b8bda19c3c3b9ff0649.svg), то есть ![\left\{i_i\right\}](https://habrastorage.org/getpro/habr/upload_files/981/4a7/6af/9814a76af2ac226e6fdbeeafefacd20a.svg) — последовательность независимых одинаково распределенных случайных величин, имеющих дискретное равномерное распределение на ![\{1, \cdots, n\}](https://habrastorage.org/getpro/habr/upload_files/c85/9be/ccf/c859beccffee3975633bc3785f2ea33f.svg). Таким образом, выборочная последовательность блоков с случайной длиной будет иметь следующий вид:

![\left\{B_{i_1, l_1}, B_{i_2, l_2}, \ldots\right\}=\left\{X_{i_1}, X_{i_1+1}, \ldots, X_{i_1+l_1-1}, X_{i_2}, X_{i_2+1}, \ldots, X_{i_2+l_2-1}, \ldots\right\}](https://habrastorage.org/getpro/habr/upload_files/008/399/d9d/008399d9d79de7dc68ce683f3de0a5d7.svg)

Если длина сгенерированной последовательности превышает размер выборки ![n](https://habrastorage.org/getpro/habr/upload_files/640/429/964/64042996485611b07abd169ec5b4426d.svg), то процесс генерации останавливается после получения ![n](https://habrastorage.org/getpro/habr/upload_files/1b2/d2c/53b/1b2d2c53b689485f44001794df88b299.svg) наблюдений. Моделируя большое количество синтетических подвыборок, мы можем аппроксимировать распределение статистики ![T^*](https://habrastorage.org/getpro/habr/upload_files/161/165/c22/161165c2285852089f93e6f5bdee2764.svg). На основе этого распределения далее вычисляются критическое значение и доверительный интервал для оценки параметров исследуемой модели, что позволяет провести статистические выводы.

Свойства оценки методом stationary bootstrap зависят от выбора параметра ![p](https://habrastorage.org/getpro/habr/upload_files/415/ba4/420/415ba442046d9752a72fc94b270b4515.svg), который определяет среднюю длину блока. В общем случае, оценка методом stationary bootstrap обладает следующими свойствами:

1. _Несмещенность_: оценка методом stationary bootstrap является несмещенной, если ![p](https://habrastorage.org/getpro/habr/upload_files/915/00e/3b1/91500e3b149dddc238efbcf8c13e5505.svg) стремится к нулю с увеличением объема выборки ![n](https://habrastorage.org/getpro/habr/upload_files/e2c/d20/c91/e2cd20c91466012e57860fd057a69e19.svg). Это означает, что среднее значение оценки сходится к истинному значению параметра.
    
2. _Состоятельность_: оценка методом stationary bootstrap является состоятельной, если p удовлетворяет условию ![np \rightarrow \infty \text { при } n \rightarrow \infty](https://habrastorage.org/getpro/habr/upload_files/2cf/c6a/265/2cfc6a2653fdbce733dcd9564e95a6a7.svg). Это означает, что дисперсия оценки уменьшается с увеличением объема выборки и стремится к нулю.
    
3. _Эффективность_: оценка методом stationary bootstrap является асимптотически эффективной, если p выбирается таким образом, чтобы минимизировать среднеквадратичную ошибку оценки. Оптимальное значение ![p](https://habrastorage.org/getpro/habr/upload_files/249/e1b/1b2/249e1b1b24334d45abe9325e71cd8f9f.svg) зависит от конкретной статистики и степени зависимости данных. В некоторых случаях, оптимальное значение ![p](https://habrastorage.org/getpro/habr/upload_files/2fc/e0a/a99/2fce0aa9916f3372ab0d8566d6c53120.svg) может быть получено из данных с помощью метода максимального правдоподобия или кросс-валидации.
    

![Оценка параметров с использованием SB](https://habrastorage.org/r/w1560/getpro/habr/upload_files/3cb/1c3/f47/3cb1c3f47576439195544b2db6d48f07.png "Оценка параметров с использованием SB")

Оценка параметров с использованием SB

### Model-Based Bootstrap

Другой метод, не требующий стационарности, это модельный бутстрап, он же бутстрап остатков/невязок (_residual bootstrap_). Как и предполагает название, бутстрап проводится по остаткам, полученным в результате моделирования исходных данных. Новые временные ряды показывают ту же зависимость исходных данных, выявленную моделью, учитывая случайную составляющую, полученную в результате повторной выборки из остатков.

_Примечание: хотя есть вариации, где сначала обучается модель, а уже потом из неё генерируются новые синтетические данные, здесь мы рассмотрим именно бутстрапирование остатков. Для простоты мы так же возьмём в качестве модели линейную регрессию, хотя никто не запрещает нам использовать другую модель._

![Пайплайн Model-Based бутстрапа](https://habrastorage.org/r/w1560/getpro/habr/upload_files/388/727/111/3887271113f295a8bebbfac674f0a713.png "Пайплайн Model-Based бутстрапа")

Пайплайн Model-Based бутстрапа

Мы предполагаем, что существует линейная зависимость между вектором ![x](https://habrastorage.org/getpro/habr/upload_files/3ed/377/1a8/3ed3771a8e1aafd9247b6cec6804cb51.svg) и переменной отклика ![y](https://habrastorage.org/getpro/habr/upload_files/89f/753/042/89f7530421b447e5fedc8c6d813247ac.svg).

![\epsilon](https://habrastorage.org/getpro/habr/upload_files/30f/96d/352/30f96d352b9f60f7688d9c225755d730.svg)— последовательность независимых одинаково распределенных случайных величин (i.i.d.) нормально распределенных с нулевым средним и стандартным отклонением ![\sigma](https://habrastorage.org/getpro/habr/upload_files/8f7/9e8/975/8f79e89759139cb68aff0c85ba3fdea3.svg), т.ч. ![y = x\beta + \epsilon, \;\; \epsilon \sim N(0, \sigma^2)](https://habrastorage.org/getpro/habr/upload_files/e08/27b/e18/e0827be185025ea5a4fd8ceb13f07ea7.svg) . Обучая модель получим параметр ![\hat\beta](https://habrastorage.org/getpro/habr/upload_files/f80/090/2f6/f800902f69ee2e05a8b57024ca4852cf.svg)и остаток ![\epsilon](https://habrastorage.org/getpro/habr/upload_files/20e/a8c/c89/20ea8cc895eaf853dac404bb5523c482.svg):

![\begin{equation*} \begin{cases} \hat\beta = \underset{\beta}{argmin} \sum^n_{i=1} (y_i - x\beta)^2 \\ \epsilon = y - x\hat\beta \end{cases} \end{equation*}](https://habrastorage.org/getpro/habr/upload_files/df6/be8/548/df6be8548bc2605c1be899d60f5d079b.svg)

Мы получаем параметр ![\hat\beta](https://habrastorage.org/getpro/habr/upload_files/f01/3e8/28c/f013e828cc4f463ff69a1e689148ac6c.svg) путем выбора такого ![\beta](https://habrastorage.org/getpro/habr/upload_files/7cc/200/b86/7cc200b868d53c56c3f4ff65571453fc.svg), что квадрат разницы между наблюдаемыми и предсказанными значениями будет минимален. Далее вычитаем предсказание из значений, и таким образом получаем остатки. Исследуем данные остатки, чтобы убедиться, что они соответствуют нормальному распределению, и оценим дисперсию шума:

![\sigma^2 = \frac{RSS(\hat\beta)}{n - 1}](https://habrastorage.org/getpro/habr/upload_files/c72/08a/c3d/c7208ac3da8cf3cee024306e64b43198.svg)

Исходя из того, что модель адекватно описывает данные, мы создаём новые синтетические наборы данных ![y^{*}](https://habrastorage.org/getpro/habr/upload_files/174/462/28f/17446228f6dfd59c09931f3ff62a27f4.svg), используя параметры и результаты диагностики исходной модели. Далее, на этих синтетических данных обучаем модель, получая новые оценки параметров ![\hat\beta^{*}](https://habrastorage.org/getpro/habr/upload_files/c77/c0c/69c/c77c0c69c542e18f9dd4e7bdf7735dc0.svg). Этот процесс повторяется многократно, создавая бутстрап-выборки, что позволяет нам сформировать распределение оценок для каждого параметра модели. Таким образом, на этапе генерации синтетических данных и последующего их анализа осуществляется бутстрап.

Вариация этих оценок затем используется для аппроксимации стандартной ошибки ![SE](https://habrastorage.org/getpro/habr/upload_files/07d/794/faa/07d794faa3d2f1d34871afb0cb07c23c.svg) исходной оценки ( ![\hat{\beta}](https://habrastorage.org/getpro/habr/upload_files/3e3/93e/990/3e393e990380e44c834e5827180fa99f.svg)).

![SE(\hat\beta) = \sqrt{Var(\hat\beta^{*})}](https://habrastorage.org/getpro/habr/upload_files/533/d22/480/533d22480bc525441006974925352107.svg)

Это дает возможность оценить насколько хорошо мы подобрали параметры модели, что может быть особенно полезно в тех случаях, когда теоретическое распределение этих оценок является сложным или неизвестным.

Данный метод сравнительно прост для понимания и применим к широкому классу зависимостей и моделей (например, ARIMA и другие). Если наша модель хорошо соответствует структуре, которая лежит в основе данных, мы сможем получать более точные оценки.

Есть также и минусы: если модель плохо отражает структуру данных, то результатом будут неверные оценки параметров. Кроме того, для более сложных моделей данный метод будет вычислительно тяжёлым, а также всегда есть вероятность переобучить модель, которую мы используем для получения остатков.

![Оценка параметров с использованием MB из постановки задачи](https://habrastorage.org/r/w1560/getpro/habr/upload_files/8e8/6c9/bfc/8e86c9bfca68677450943936b6aa9983.png "Оценка параметров с использованием MB из постановки задачи")

Оценка параметров с использованием MB из постановки задачи

## Frequency Domain Bootstrap

Для этого метода перейдём от временного домена (точки во времени) к частотному домену при помощи _быстрого преобразования Фурье_:

Для справки:

![I_n(\lambda) = \frac{1}{2\pi n} \bigg | \sum_{t=1}^n X_t e^{-i\lambda t} \bigg | ^ 2, \;\; \lambda \in [-\pi, \pi]](https://habrastorage.org/getpro/habr/upload_files/8a7/192/2d2/8a71922d2b30f50d135aa3cea07fb5f0.svg)

Посмотрим на реальный пример такого преобразования:

![Пример преобразования Фурье временного ряда](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ebf/cb3/f81/ebfcb3f8118299f3afb2f721d75b7c98.png "Пример преобразования Фурье временного ряда")

Пример преобразования Фурье временного ряда

В данном подходе мы сможем определять паттерны в данных, которые сложно уловить во временной области, однако он требует от временного ряда хотя бы слабой стационарности, что ограничивает область его применения. Также этот метод может быть сложен для понимания людям с небольшим опытом в обработке сигналов. Кроме того, существенным недостатком является недостаточное количество качественных программных решений: хотя для обработки сигналов доступно множество реализаций, для бутстрапирования в частотном домене подходящих вариантов практически нет.

![Оценка параметров с использованием FD из постановки задачи](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6cf/83b/7f5/6cf83b7f5d81cf38e3ebe908d77e0c45.png "Оценка параметров с использованием FD из постановки задачи")

Оценка параметров с использованием FD из постановки задачи

### Сравнения методов

Однозначно сказать, что один бутстрап-метод превосходит другой, невозможно, поскольку каждый обладает своими особенностями и областью эффективности. Мы оценили ключевые характеристики каждого подхода и на графиках демонстрируем, как они влияют на точность параметрических оценок и ширину доверительных интервалов. Это сравнение выявляет преимущества и ограничения методов, помогая выбрать оптимальный для конкретных условий анализа временных рядов.

Мы сгенерировали данные при помощи авторегрессионного процесса второго порядка, взяв ![\phi_1 = 0.2](https://habrastorage.org/getpro/habr/upload_files/340/a32/444/340a3244406932f1e9221f216106bd8e.svg) и ![\phi_2 = 0.4](https://habrastorage.org/getpro/habr/upload_files/c50/4dd/832/c504dd8329b52a6bfd164593f206e55c.svg) при помощи библиотеки statsmodels.api, а основные методы бутстрапа были реализованы в библиотеке arch.bootstrap.

![Классический бутстрап метод не позволяет сделать оценку параметров, если у нас есть созависимость данных, поскольку он не учитывает структуру ряда при построении бутстрап семпла](https://habrastorage.org/r/w1560/getpro/habr/upload_files/8a1/e1f/cf7/8a1e1fcf76caf96d363abaa52d3ef8d4.png "Классический бутстрап метод не позволяет сделать оценку параметров, если у нас есть созависимость данных, поскольку он не учитывает структуру ряда при построении бутстрап семпла")

Классический бутстрап метод не позволяет сделать оценку параметров, если у нас есть созависимость данных, поскольку он не учитывает структуру ряда при построении бутстрап семпла

![При размере блока = 1 блочные методы равносильны обычному бутстрапу](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a9e/e7c/210/a9ee7c21029eef1b052dd4917e086da5.png "При размере блока = 1 блочные методы равносильны обычному бутстрапу")

При размере блока = 1 блочные методы равносильны обычному бутстрапу

![При низком значении автоковариации поведение методов и классического бустрапа совпадает](https://habrastorage.org/r/w1560/getpro/habr/upload_files/4bb/c2c/319/4bbc2c3198d108d82e48c3969937c21b.png "При низком значении автоковариации поведение методов и классического бустрапа совпадает")

При низком значении автоковариации поведение методов и классического бустрапа совпадает

![Усредненный MSE для различных методов бутстрапа](https://habrastorage.org/r/w1560/getpro/habr/upload_files/922/2b6/514/9222b65143dd17c13a229cb1aca55b61.png "Усредненный MSE для различных методов бутстрапа")

Усредненный MSE для различных методов бутстрапа

Для разных значений параметров ![\hat{\phi}_1](https://habrastorage.org/getpro/habr/upload_files/c75/d17/354/c75d17354686a476a6d1fca747e67836.svg) и ![\hat{\phi}_2](https://habrastorage.org/getpro/habr/upload_files/325/2e7/b05/3252e7b05b608d4896296cc67eec1e5d.svg) мы проведели серию из 500 симуляций для определения усредненной среднеквадратической ошибки (MSE) различных методов бутстрапа. Результаты показали, что методы _NBB_ и _CBB_ обеспечивают наиболее низкую MSE для обоих параметров модели, что указывает на их высокую эффективность в оценке. Однако результаты других четырех методов: _SB_, _ModelBased_, _MBB_, _FrequencyDomain_ не сильно хуже. А вот метод _BM_ показал значительно большие значения MSE, подчеркивая низкую точность в данной задаче оценки.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/83b/8b3/e11/83b8b3e112904a98596295d8317a2d4b.png)

![Распределение MSE для различных методов бутстрапа](https://habrastorage.org/r/w1560/getpro/habr/upload_files/06c/42a/a4a/06c42aa4afc478aa45349aab3d331bc9.png "Распределение MSE для различных методов бутстрапа")

Распределение MSE для различных методов бутстрапа

Методы _ModelBased_ и _FrequencyDomain_ демонстрируют меньшую дисперсию распределения MSE, что свидетельствует о их высокой точности и низкой вариативности оценок параметров модели.

NBB, MBB, SB и CBB показывают большую вариативность в оценках, с MSE, достигающими более высоких значений, особенно для параметра ![\phi_2](https://habrastorage.org/getpro/habr/upload_files/5eb/8f2/77c/5eb8f277c26d327c8711563ddc6db0b2.svg). Однако наиболее частое значение MSE этих методов находится ближе к 0.

BM показал себя как метод с наибольшей вариативностью и наибольшими значениями MSE, что делает его наименее подходящим для точной оценки параметров модели AR(2).

## Заключение

Вот и конец!

Мы рассмотрели основные методы для бутстрапа временных рядов. Выводы, к которым мы пришли по итогам работы:

- Когда временной ряд не соответствует предположению о независимости и одинаковом распределении наблюдений (i.i.d), становится актуальным использование блочных методов бутстрапа. Эти методы программно реализованы и позволяют учитывать структурные особенности данных, хотя они чувствительны к выбору размера окна.
    
- Можно рассмотреть Model-Based бутстрап для моделей, учитывающих структуру временного ряда, но быть внимательным к риску переобучения.
    
- Frequency Domain Bootstrap представляет собой экспериментальный подход, который позволит выявлять сложные паттерны, которые трудно определить во временной области, хотя его применение ограничивается из-за отсутствия эффективных программных реализаций.
    

Проведённые симуляции для MSE различных методов бутстрапа показали, что NBB и CBB наиболее эффективны, а методы ModelBased и FrequencyDomain более стабильны и точны в оценках параметров модели. Однако мы советуем опираться на свойства ваших данных, и подбирать метод исходя из характеристик конкретно вашей задачи.

Благодарим за внимание! На ваши вопросы с радостью ответим в комментариях.

Над статьёй работали члены команды Ad-Hoc X5 Tech: