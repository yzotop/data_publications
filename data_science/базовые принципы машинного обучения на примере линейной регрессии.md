---
tags:
  - data
link: https://habr.com/ru/companies/ods/articles/322076/
source: habr
author: Nesterov
data_type:
  - DS
---
Здравствуйте, коллеги! Это блог открытой русскоговорящей [дата саентологической ложи](http://ods.ai/). Нас уже легион, точнее 2500+ человек в слаке. За полтора года мы нагенерили 800к+ сообщений (ради этого слак выделил нам корпоративный аккаунт). Наши люди есть везде и, может, даже в вашей организации. Если вы интересуетесь машинным обучением, но по каким-то причинам не знаете про [Open Data Science](http://ods.ai/), то возможно вы в курсе мероприятий, которые организовывает сообщество. Самым масштабным из них является [DataFest](http://datafest.ru/), который проходил недавно в офисе [Mail.Ru Group](https://corp.mail.ru/ru/press/events/307/), за два дня его посетило 1700 человек. Мы растем, наши ложи открываются в городах России, а также в Нью-Йорке, Дубае и даже во Львове, да, мы не воюем, а иногда даже и употребляем горячительные напитки вместе. И да, мы некоммерческая организация, наша цель — просвещение. Мы делаем все ради искусства. (пс: на фотографии вы можете наблюдать заседание ложи в одном из тайных храмов в Москве).  
  
Мне выпала честь сделать первый пост, и я, пожалуй, отклонюсь от [своей привычной нейросетевой тематики](https://habrahabr.ru/users/mephistopheies/topics/) и сделаю пост о базовых понятиях машинного обучения на примере одной из самых простых и самых полезных моделей — линейной регрессии. Я буду использовать язык питон для демонстрации экспериментов и отрисовки графиков, все это вы с легкостью сможете повторить на своем компьютере. Поехали.  
  

## Формализмы

  

![](https://habrastorage.org/r/w1560/files/2d4/41b/4b6/2d441b4b680a4e83a48a90d25d593cac.png)

  
Машинное обучение — это подраздел искусственного интеллекта, в котором изучаются алгоритмы, способные обучаться без прямого программирования того, что нужно изучать. Линейная регрессия является типичным представителем алгоритмов машинного обучения. Для начала ответим на вопрос «а что вообще значит _обучаться_?». Ответ на этот вопрос мы возьмем из [книги 1997 года](http://www.cs.cmu.edu/~tom/mlbook.html) (стоит отметить, что оглавление этой книги не сильно отличается от современных книг по машинному обучению).  
  

> Говорят, что программа обучается на опыте ![$E$](https://habrastorage.org/getpro/habr/formulas/d4f/55a/37f/d4f55a37fb733b176d0ef014591e1b35.svg) относительно класса задач ![$T$](https://habrastorage.org/getpro/habr/formulas/175/f98/839/175f98839ab732db76d5f20cd6ce2ce9.svg) в смысле меры качества ![$L$](https://habrastorage.org/getpro/habr/formulas/a5a/4e0/afa/a5a4e0afaec84939dbfda220172b2be0.svg), если при решении задачи ![$T$](https://habrastorage.org/getpro/habr/formulas/175/f98/839/175f98839ab732db76d5f20cd6ce2ce9.svg) качество, измеряемое мерой ![$L$](https://habrastorage.org/getpro/habr/formulas/a5a/4e0/afa/a5a4e0afaec84939dbfda220172b2be0.svg), возрастает при демонстрации нового опыта ![$E$](https://habrastorage.org/getpro/habr/formulas/d4f/55a/37f/d4f55a37fb733b176d0ef014591e1b35.svg).

  
Можно выделить следующие задачи ![$T$](https://habrastorage.org/getpro/habr/formulas/175/f98/839/175f98839ab732db76d5f20cd6ce2ce9.svg), решаемые машинным обучением: [обучение с учителем](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D1%83%D1%87%D0%B8%D1%82%D0%B5%D0%BB%D0%B5%D0%BC), [обучение без учителя](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B1%D0%B5%D0%B7_%D1%83%D1%87%D0%B8%D1%82%D0%B5%D0%BB%D1%8F), [обучение с подкреплением](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BF%D0%BE%D0%B4%D0%BA%D1%80%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC), [активное обучение](https://en.wikipedia.org/wiki/Active_learning_(machine_learning)), [трансфер знаний](https://en.wikipedia.org/wiki/Inductive_transfer) и т.д. Регрессия (как и классификация) относится к классу задач обучения с учителем, когда по заданному набору признаков наблюдаемого объекта необходимо спрогнозировать некоторую целевую переменную. Как правило, в задачах обучения с учителем, опыт ![$E$](https://habrastorage.org/getpro/habr/formulas/d4f/55a/37f/d4f55a37fb733b176d0ef014591e1b35.svg) представляется в виде множества пар признаков и целевых переменных: ![$D=\left\{ (x_i, y_i) \right\}_{i=1, \ldots,n}$](https://habrastorage.org/getpro/habr/formulas/53c/5ad/f85/53c5adf850372652f577c2fa06fd1bcb.svg). В случае линейной регрессии признаковое описание объекта — это действительный вектор ![$\vec{x} \in \mathbb{R}^m$](https://habrastorage.org/getpro/habr/formulas/3c6/0da/93a/3c60da93abf81257456215b391e2764c.svg), а целевая переменная — это скаляр ![$y \in \mathbb{R}$](https://habrastorage.org/getpro/habr/formulas/707/b25/5eb/707b255eb289c06fb0054ac4cb407322.svg). Самой простой мерой качества ![$L$](https://habrastorage.org/getpro/habr/formulas/a5a/4e0/afa/a5a4e0afaec84939dbfda220172b2be0.svg) для задачи регрессии является ![$L(y, \hat{y}) = \left(y - \hat{y}\right)^2$](https://habrastorage.org/getpro/habr/formulas/b28/746/9f3/b287469f344f64ac7436b03ae9074ae5.svg), где ![$\hat{y}$](https://habrastorage.org/getpro/habr/formulas/a21/569/4e1/a215694e19c90e654ebb19cc35ac5601.svg) — это наша оценка реального значения целевой переменной.  
  
У нас есть задача, данные и способ оценки программы/модели. Давайте определим, что такое _модель_, и что значит _обучить модель_. _Предиктивная модель_ – это параметрическое семейство функций (семейство гипотез):  

![$\Large \mathcal{H} = \left\{ h\left(x, \theta\right) | \theta \in \Theta \right\}$](https://habrastorage.org/getpro/habr/formulas/4e3/3c9/a84/4e33c9a84df81cdab080c069214ac906.svg)

  
где  

- ![$h: X \times \Theta \rightarrow Y$](https://habrastorage.org/getpro/habr/formulas/30a/0af/cb0/30a0afcb0b54278d50dd57c03c4298ce.svg)
- ![$\Theta$](https://habrastorage.org/getpro/habr/formulas/93f/53e/26f/93f53e26f38494bae539083b743750ba.svg) — множество параметров

  
Таким образом, из большого семейства гипотез мы должны выбрать какую-то одну конкретную, которая с точки зрения меры ![$L$](https://habrastorage.org/getpro/habr/formulas/a5a/4e0/afa/a5a4e0afaec84939dbfda220172b2be0.svg) является лучшей. Процесс такого выбора назовем _алгоритмом обучения_:  

![$\Large \mathcal{M}: \left(X \times Y\right)^n \rightarrow \mathcal{H}$](https://habrastorage.org/getpro/habr/formulas/ca8/7e4/0c7/ca87e40c7bcd0f3079c80db0a0578a40.svg)

  
Получается, что алгоритм обучения — это отображение из набора данных в пространство гипотез. Обычно процесс обучения с учителем состоит из двух шагов:  
  

1. обучение: ![$h = \mathcal{M}\left(D\right)$](https://habrastorage.org/getpro/habr/formulas/0e0/9e9/0da/0e09e90da8fb6f3d55d535c5668f048c.svg);
2. применение: ![$\hat{y} = h\left(x\right)$](https://habrastorage.org/getpro/habr/formulas/4ff/d3a/0ae/4ffd3a0aea9a7cf36452fd87e01c0d14.svg).

  
Часто для обучения модели пользуются _принципом минимизации эмпирического риска_. Риском гипотезы ![$h$](https://habrastorage.org/getpro/habr/formulas/517/4f4/9cc/5174f49cc4f41fc5c4802c76f4c76c5a.svg) называют ожидаемое значение функции стоимости ![$L$](https://habrastorage.org/getpro/habr/formulas/a5a/4e0/afa/a5a4e0afaec84939dbfda220172b2be0.svg):  

![$\Large \begin{array}{rcl}Q\left(h\right) &=& \text{E}_{x, y \sim P\left(x, y\right)}\left[L\left(h\left(x\right), y\right)\right] \\ &=& \int L\left(h\left(x\right), y\right) d P\left(x, y\right) \end{array}$](https://habrastorage.org/getpro/habr/formulas/7bf/4e5/4d2/7bf4e54d2fec308d12eb64fc98c743b0.svg)

  
Но, к сожалению, такой интеграл не посчитать, т.к. распределение ![$P\left(x, y\right)$](https://habrastorage.org/getpro/habr/formulas/69c/2b9/0f3/69c2b90f361bc8ec49c8688bdc1f8c08.svg) неизвестно, иначе и задачи не было бы. Но мы можем посчитать эмпирическую оценку риска, как среднее значение функции стоимости:  

![$\Large Q_{\text{emp}}\left(h\right) = \frac{1}{n} \sum_{i=1}^n L\left(h\left(x_i\right), y_i\right)$](https://habrastorage.org/getpro/habr/formulas/416/7e6/7fa/4167e67fa3531b6d53b3a1ac782b6d68.svg)

  
Тогда, согласно принципу минимизации эмпирического риска, мы должны выбрать такую гипотезу ![$h \in \mathcal{H} $](https://habrastorage.org/getpro/habr/formulas/729/fe3/4f0/729fe34f0ecc04961ddc2d53e36559d6.svg), которая минимизирует ![$Q_{\text{emp}}$](https://habrastorage.org/getpro/habr/formulas/956/c9e/df7/956c9edf7727761836a1cc792f5e61b1.svg):  

![$\Large \hat{h} = \arg \min_{h \in \mathcal{H}} Q_{\text{emp}}\left(h\right)$](https://habrastorage.org/getpro/habr/formulas/110/ba2/357/110ba2357768c53127ba3ae67729013e.svg)

  
У данного принципа есть существенный недостаток, решения найденные таким путем будут склонны к _переобучению_. Мы говорим, что модель обладает _обобщающей способностью_, тогда, когда ошибка на новом (тестовом) наборе данных (взятом из того же распределения ![$P\left(x, y\right)$](https://habrastorage.org/getpro/habr/formulas/69c/2b9/0f3/69c2b90f361bc8ec49c8688bdc1f8c08.svg)) мала, или же предсказуема. Переобученная модель не обладает обобщающей способностью, т.е. на обучающем наборе данных ошибка мала, а на тестовом наборе данных ошибка существенно больше.  
  

## Линейная регрессия

  
Давайте ограничим пространство гипотез только линейными функциями от ![$m + 1$](https://habrastorage.org/getpro/habr/formulas/e82/54c/07a/e8254c07aebb8201257a2516929a78ec.svg) аргумента, будем считать, что нулевой признак для всех объектов равен единице ![$x_0 = 1$](https://habrastorage.org/getpro/habr/formulas/21b/56d/f08/21b56df08a760eb64bd7754c7e58e643.svg):  

![$\Large \begin{array}{rcl} \forall h \in \mathcal{H}, h\left(\vec{x}\right) &=& w_0 x_0 + w_1 x_1 + w_2 x_2 + \cdots + w_m x_m \\ &=& \sum_{i=0}^m w_i x_i \\ &=& \vec{x}^T \vec{w} \end{array}$](https://habrastorage.org/getpro/habr/formulas/44c/94e/8ff/44c94e8ff2672637c613ce60e51243cd.svg)

  
Эмпирический риск (функция стоимости) принимает форму среднеквадратичной ошибки:  

![$\Large \begin{array}{rcl}\mathcal{L}\left(X, \vec{y}, \vec{w} \right) &=& \frac{1}{2n} \sum_{i=1}^n \left(y_i - \vec{x}_i^T \vec{w}_i\right)^2 \\ &=& \frac{1}{2n} \left\| \vec{y} - X \vec{w} \right\|_2^2 \\ &=& \frac{1}{2n} \left(\vec{y} - X \vec{w}\right)^T \left(\vec{y} - X \vec{w}\right) \end{array}$](https://habrastorage.org/getpro/habr/formulas/ebd/55f/41c/ebd55f41ca4b70754f5bf77e34606ef3.svg)

  
строки матрицы ![$X$](https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg) — это признаковые описания наблюдаемых объектов. Один из алгоритмов обучения ![$\mathcal{M}$](https://habrastorage.org/getpro/habr/formulas/f17/0f1/699/f170f1699ad86d6240219fbb55acd1e5.svg) такой модели — это метод наименьших квадратов. Вычислим производную функции стоимости:  

![$\Large \begin{array}{rcl} \frac{\partial \mathcal{L}}{\partial \vec{w}} &=& \frac{\partial}{\partial \vec{w}} \frac{1}{2n} \left( \vec{y}^T \vec{y} -2\vec{y}^T X \vec{w} + \vec{w}^T X^T X \vec{w}\right) \\ &=& \frac{1}{2n} \left(-2 X^T \vec{y} + 2X^T X \vec{w}\right) \end{array}$](https://habrastorage.org/getpro/habr/formulas/bdc/7f6/ff8/bdc7f6ff82182fd1444ad6767c008e6a.svg)

  
приравняем к нулю и найдем решение в явном виде:  

![$\Large \begin{array}{rcl} \frac{\partial \mathcal{L}}{\partial \vec{w}} = 0 &\Leftrightarrow& \frac{1}{2n} \left(-2 X^T \vec{y} + 2X^T X \vec{w}\right) = 0 \\ &\Leftrightarrow& -X^T \vec{y} + X^T X \vec{w} = 0 \\ &\Leftrightarrow& X^T X \vec{w} = X^T \vec{y} \\ &\Leftrightarrow& \vec{w} = \left(X^T X\right)^{-1} X^T \vec{y} \end{array}$](https://habrastorage.org/getpro/habr/formulas/2cb/1bb/186/2cb1bb1867ef87946c57650f44ee0968.svg)

  
Поздравляю, дамы и господа, мы только что с вами вывели алгоритм машинного обучения. Реализуем же этот алгоритм. Начнем с датасета, состоящего всего из одного признака. Будем брать случайную точку на синусе и добавлять к ней шум — таким образом получим целевую переменную; признаком в этом случае будет координата ![$x$](https://habrastorage.org/getpro/habr/formulas/817/b92/407/817b92407f764f57af9226e50cc788fd.svg):  
  

```
def generate_wave_set(n_support=1000, n_train=25, std=0.3):    data = {}    # выберем некоторое количество точек из промежутка от 0 до 2*pi    data['support'] = np.linspace(0, 2*np.pi, num=n_support)    # для каждой посчитаем значение sin(x) + 1    # это будет ground truth    data['values'] = np.sin(data['support']) + 1    # из support посемплируем некоторое количество точек с возвратом, это будут признаки    data['x_train'] = np.sort(np.random.choice(data['support'], size=n_train, replace=True))    # опять посчитаем sin(x) + 1 и добавим шум, получим целевую переменную    data['y_train'] = np.sin(data['x_train']) + 1 + np.random.normal(0, std, size=data['x_train'].shape[0])    return datadata = generate_wave_set(1000, 250)
```

  

**Отрисовка графика**

  
![](https://habrastorage.org/r/w1560/files/e2e/f08/cee/e2ef08cee57a4320a24d39a94572f216.png)  
  
А теперь реализуем алгоритм обучения, используя магию NumPy:  
  

```
# добавим колонку единиц к единственному столбцу признаковX = np.array([np.ones(data['x_train'].shape[0]), data['x_train']]).T# перепишем, полученную выше формулу, используя numpy# шаг обучения - в этом шаге мы ищем лучшую гипотезу hw = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), data['y_train'])# шаг применения: посчитаем прогнозy_hat = np.dot(w, X.T)
```

  
  

**Отрисовка графика**

  
  
![](https://habrastorage.org/r/w1560/files/685/dce/978/685dce97812345db9fceaa834f19ee23.png)  
  
Как мы видим, линия не очень-то совпадает с настоящей кривой. Среднеквадратичная ошибка равна **0.26704** условных единиц. Очевидно, что если бы вместо линии мы использовали кривую третьего порядка, то результат был бы куда лучше. И, на самом деле, с помощью линейной регрессии мы можем обучать нелинейные модели.  
  

## Полиномиальная регрессия

  
В линейной регрессии мы ограничивали пространство гипотез только линейными функциями от признаков. Давайте теперь расширим пространство гипотез до всех полиномов степени ![$p$](https://habrastorage.org/getpro/habr/formulas/839/f25/c27/839f25c2746382debd4f08ea25ad5ecf.svg). Тогда в нашем случае, когда количество признаков равно одному ![$m=1$](https://habrastorage.org/getpro/habr/formulas/611/eaf/f9f/611eaff9f79818592a808fecea7db994.svg), пространство гипотез будет выглядеть следующим образом:  

![$\Large \begin{array}{rcl} \forall h \in \mathcal{H}, h\left(x\right) &=& w_0 + w_1 x + w_1 x^2 + \cdots + w_n x^p \\ &=& \sum_{i=0}^p w_i x^i \end{array}$](https://habrastorage.org/getpro/habr/formulas/c63/9a9/3bb/c639a93bbef0aa11c023ea7f6ea30cf6.svg)

  
Если заранее предрассчитать все степени признаков, то задача опять сводится к описанному выше алгоритму — методу наименьших квадратов. Попробуем отрисовать графики нескольких полиномов разных степеней.  
  

```
# список степеней p полиномов, который мы протестируемdegree_list = [1, 2, 3, 5, 7, 10, 13]cmap = plt.get_cmap('jet')colors = [cmap(i) for i in np.linspace(0, 1, len(degree_list))]margin = 0.3plt.plot(data['support'], data['values'], 'b--', alpha=0.5, label='manifold')plt.scatter(data['x_train'], data['y_train'], 40, 'g', 'o', alpha=0.8, label='data')w_list = []err = []for ix, degree in enumerate(degree_list):    # список с предрасчитанными степенями признака    dlist = [np.ones(data['x_train'].shape[0])] + \                map(lambda n: data['x_train']**n, range(1, degree + 1))    X = np.array(dlist).T    w = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), data['y_train'])    w_list.append((degree, w))    y_hat = np.dot(w, X.T)    err.append(np.mean((data['y_train'] - y_hat)**2))    plt.plot(data['x_train'], y_hat, color=colors[ix], label='poly degree: %i' % degree)
```

  

**Отрисовка графика**

  
![](https://habrastorage.org/r/w1560/files/cfa/f27/384/cfaf27384fe047c5948c76c2d2ac5cbf.png)  
  
На графике мы можем наблюдать сразу два феномена. Пока не обращайте внимание на 13-ую степень полинома. При увеличении степени полинома, средняя ошибка продолжает уменьшаться, хотя мы вроде были уверены, что именно кубический полином должен лучше всего описывать наши данные.  
  

|p|error|
|---|---|
|1|0.26704|
|2|0.22495|
|3|0.08217|
|5|0.05862|
|7|0.05749|
|10|0.0532|
|13|5.76155|

  
Это явный признак переобучения, который можно заметить по визуализации даже не используя тестовый набор данных: при увеличении степени полинома выше третьей модель начинает _интерполировать_ данные, вместо _экстраполяции_. Другими словами, график функции проходит точно через точки из тренировочного набора данных, причем чем выше степень полинома, тем через большее количество точек он проходит. Степень полинома отражает _сложность_ модели. Таким образом, сложные модели, у которых степеней свободы достаточно много, могут попросту запомнить весь тренировочный набор, полностью теряя обобщающую способность. Это и есть проявление негативной стороны принципа минимизации эмпирического риска.  
  
Вернемся к полиному 13-ой степени, с ним явно что-то не так. По идее, мы ожидаем, что полином 13-ой степени будет описывать тренировочный набор данных еще лучше, но результат показывает, что это не так. Из курса линейной алгебры мы помним, что обратная матрица существует только для несингулярных матриц, т.е. тех, у которых нет линейной зависимости колонок или строк. В методе наименьших квадратов нам необходимо инвертировать следующую матрицу: ![$\left(X^T X\right)^{-1}$](https://habrastorage.org/getpro/habr/formulas/fc6/c39/8be/fc6c398be320ab9788f5440c17094196.svg). Для тестирования на линейную зависимость или _мультиколлинеарность_ можно использовать _[число обусловленности матрицы](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%BE%D0%B1%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8)_. Один из способов оценки этого числа для матриц — это отношение модуля максимального собственного числа матрицы к модулю минимального собственного числа. Большое число обусловленности матрицы, или же наличие одного или нескольких собственных чисел близких к нулю свидетельствует о наличии мультиколлинеарности (или нечеткой мультиколлиниарности, когда ![$c_i \approx k c_j + b$](https://habrastorage.org/getpro/habr/formulas/bd5/f9a/220/bd5f9a2209e47933a97a3795b49061e4.svg)). Такие матрицы называются слабо обусловленными, а задача — некорректно поставленной. При инвертировании такой матрицы, решения имеют большую дисперсию. Это проявляется в том, что при небольшом изменении начальной матрицы, инвертированные будут сильно отличаться друг от друга. На практике это всплывет тогда, когда к 1000 семплов, вы добавите всего один, а решение МНК будет совсем другим. Посмотрим на собственные числа полученной матрицы, нас там ждет сюрприз:  
  

```
np.linalg.eigvals(np.cov(X[:, 1:].T))
```

  

```
Out[10]:
array([  
         9.29965299e+17+0.j        ,   4.04567033e+13+0.j        ,
         5.44657111e+09+0.j        ,   3.54104756e+06+0.j        ,
         8.36745166e+03+0.j        ,   6.82745279e+01+0.j        ,
         8.88434986e-01+0.j        ,   2.42827315e-02+0.00830052j,
         2.42827315e-02-0.00830052j,   1.17621840e-03+0.j        ,
         1.72254789e-04+0.j        ,  -5.68384880e-06+0.j        ,
         2.39611454e-07+0.j        ])
```

  

![](https://habrastorage.org/r/w1560/files/841/08d/82a/84108d82ab9e4955b42b68b81cf1ac05.jpg)

  
Все так, numpy вернул два комплекснозначных собственных значения, что идет вразрез с теорией. Для симметричных и положительно определенных матриц (каковой и является матрица ![$X^T X$](https://habrastorage.org/getpro/habr/formulas/702/7e7/3b9/7027e73b9ee54743fabd5cdaa6ba7ad8.svg)) все собственные значения должны быть действительные. Возможно, это произошло из-за того, что при работе с большими числами матрица стала слегка несимметричной, _но это не точно_ ¯\_(ツ)_/¯. Если вы вдруг найдете причину такого поведения нумпая, пожалуйста, напишите в комменте.  
  
**UPDATE** (один из членов ложи по имени Андрей Оськин, с ником в слаке skoffer, без аккаунта на хабре, подсказывает):  

> Есть только одно замечание — не надо пользоваться формулой `(X^T X^{-1}) X^T` для вычисления коэффициентов линейной регрессии. Проблема с расходящимися значениями хорошо известна и на практике используют `QR` или `SVD`.  
>   
> Ну, то есть вот такой кусок кода даст вполне приличный результат:  
> 
> ```
> degree = 13dlist = [np.ones(data['x_train'].shape[0])] + \                list(map(lambda n: data['x_train']**n, range(1, degree + 1)))X = np.array(dlist).Tq, r = np.linalg.qr(X)y_hat = np.dot(np.dot(q, q.T), data['y_train'])plt.plot(data['x_train'], y_hat, label='poly degree: %i' % degree)
> ```

  
Перед тем как перейти к следующему разделу, давайте посмотрим на амплитуду параметров полиномиальной регрессии. Мы увидим, что при увеличении степени полинома, размах значений коэффициентов растет чуть ли не экспоненциально. Да, они еще и скачут в разные стороны.  
  

**Визуализация коэффициентов**

  
  

## ![$L^2$](https://habrastorage.org/getpro/habr/formulas/8ce/fc8/a63/8cefc8a639986035a1d5321efd3e8492.svg) Регуляризация

  
Регуляризация — это способ уменьшить сложность модели чтобы предотвратить переобучение или исправить некорректно поставленную задачу. Обычно это достигается добавлением некоторой априорной информации к условию задачи. Например так:  

![$\Large \mathcal{L}_{reg} \left(X, \vec{y}, \vec{w}\right) = \mathcal{L}\left(X, \vec{y}, \vec{w}\right) + \lambda R\left(\vec{w}\right)$](https://habrastorage.org/getpro/habr/formulas/510/630/182/510630182d141c28278879574345e7f8.svg)

  

- ![$\lambda$](https://habrastorage.org/getpro/habr/formulas/b1b/c57/ea8/b1bc57ea859ea7d6505ec3a3ae9be2f6.svg) — это коэффициент регуляризации, то, насколько сильно мы хотим учитывать условие ![$R$](https://habrastorage.org/getpro/habr/formulas/b81/a7c/1e9/b81a7c1e9676b36cc02ddeea5d5f6e51.svg)

  
На графиках мы увидели, что амплитуда значений коэффициентов слишком большая, попробуем ее уменьшить, добавив ограничение на ![$L^2$](https://habrastorage.org/getpro/habr/formulas/8ce/fc8/a63/8cefc8a639986035a1d5321efd3e8492.svg) норму вектора параметров.  

![$\Large R\left(\vec{w}\right) = \frac{1}{2} \left\| \vec{w} \right\|_2^2 = \frac{1}{2} \sum_{j=1}^m w_j^2 = \frac{1}{2} \vec{w}^T \vec{w}$](https://habrastorage.org/getpro/habr/formulas/5dc/d7c/5be/5dcd7c5be9eb07d1e4505fe0ebe56eb6.svg)

  
Новая функция стоимости примет вид:  

![$\Large \mathcal{L}\left(X, \vec{y}, \vec{w} \right) = \frac{1}{2} \left(\vec{y} - X \vec{w}\right)^T \left(\vec{y} - X \vec{w}\right) + \frac{\lambda}{2} \vec{w}^T \vec{w}$](https://habrastorage.org/getpro/habr/formulas/2c1/bbb/697/2c1bbb6972ab056ba617efcff42db268.svg)

  
Вычислим производную по параметрам:  

![$\Large \begin{array}{rcl}\Large \frac{\partial \mathcal{L}}{\partial \vec{w}} &=& \frac{\partial}{\partial \vec{w}} \left(\frac{1}{2} \left(\vec{y} - X \vec{w}\right)^T \left(\vec{y} - X \vec{w}\right) + \frac{\lambda}{2} \vec{w}^T \vec{w}\right) \\ &=& \frac{\partial}{\partial \vec{w}}\left( \frac{1}{2} \left( \vec{y}^T \vec{y} -2\vec{y}^T X \vec{w} + \vec{w}^T X^T X \vec{w}\right) + \frac{\lambda}{2} \vec{w}^T \vec{w} \right) \\ &=& -X^T \vec{y} + X^T X \vec{w} + \lambda \vec{w} \end{array}$](https://habrastorage.org/getpro/habr/formulas/9f2/ffe/719/9f2ffe7195043a99304cf8e8d44ce9d3.svg)

  
И найдем решение в явном виде:  

![$\Large \begin{array}{rcl} \frac{\partial \mathcal{L}}{\partial \vec{w}} = 0 &\Leftrightarrow& -X^T \vec{y} + X^T X \vec{w} + \lambda \vec{w} = 0 \\ &\Leftrightarrow& X^T X \vec{w} + \lambda \vec{w} = X^T \vec{y} \\ &\Leftrightarrow& \left(X^T X + \lambda E\right) \vec{w} = X^T \vec{y} \\ &\Leftrightarrow& \vec{w} = \left(X^T X + \lambda E\right)^{-1} X^T \vec{y} \end{array}$](https://habrastorage.org/getpro/habr/formulas/be5/920/328/be5920328bf460d4fc003748dd9ffdb1.svg)

  

- ![$E$](https://habrastorage.org/getpro/habr/formulas/d4f/55a/37f/d4f55a37fb733b176d0ef014591e1b35.svg) — единичная диагональна матрица

  
Такая регрессия называется гребневой регрессией (ridge regression). А гребнем является как раз диагональная матрица которую мы прибавляем к матрице![$X^T X$](https://habrastorage.org/getpro/habr/formulas/702/7e7/3b9/7027e73b9ee54743fabd5cdaa6ba7ad8.svg) с линейнозависимыми колонками, в результате получаемая матрица не сингулярна.  
  
![](https://habrastorage.org/r/w1560/files/452/f36/c79/452f36c79d7843109993de219dde7cd5.png)  
  
Для такой матрицы число обусловленности будет равно: ![$\frac{e_\text{max} + \lambda}{e_\text{min} + \lambda}$](https://habrastorage.org/getpro/habr/formulas/9ba/df3/a5f/9badf3a5f9edb2bc2f0d2e7101150480.svg), где ![$e_x$](https://habrastorage.org/getpro/habr/formulas/fa0/aa8/948/fa0aa8948f880b8a2cf98d246ebff232.svg) — это собственные числа матрицы. Таким образом, увеличивая параметр регуляризации мы уменьшаем число обусловленности, а обусловленность задачи улучшается.  
  

```
# define regularization parameterlmbd = 0.1degree_list = [1, 2, 3, 10, 12, 13]cmap = plt.get_cmap('jet')colors = [cmap(i) for i in np.linspace(0, 1, len(degree_list))]margin = 0.3plt.plot(data['support'], data['values'], 'b--', alpha=0.5, label='manifold')plt.scatter(data['x_train'], data['y_train'], 40, 'g', 'o', alpha=0.8, label='data')w_list_l2 = []err = []for ix, degree in enumerate(degree_list):    dlist = [[1]*data['x_train'].shape[0]] + map(lambda n: data['x_train']**n, range(1, degree + 1))    X = np.array(dlist).T    w = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X) + lmbd*np.eye(X.shape[1])), X.T), data['y_train'])    w_list_l2.append((degree, w))    y_hat = np.dot(w, X.T)    plt.plot(data['x_train'], y_hat, color=colors[ix], label='poly degree: %i' % degree)    err.append(np.mean((data['y_train'] - y_hat)**2))
```

  

**Отрисовка графика**

  
![](https://habrastorage.org/r/w1560/files/ed9/1d8/040/ed91d804084046b9aa8f57fd3941f863.png)  
  

|p|error|
|---|---|
|1|0.26748|
|2|0.22546|
|3|0.08803|
|10|0.05833|
|12|0.05585|
|13|0.05638|

  
В результате даже 13-ая степень ведет себя так, как мы ожидаем. Графики немного сгладились, хотя мы все равно наблюдаем небольшое переобучение на степенях выше третьей, что выражается в интерполяции данных в правой части графика.  
  

**Визуализация коэффициентов**

  
Амплитуда коэффициентов также изменилась, хотя скакать в разные стороны они не перестали. Мы помним, что полином третьей степени должен лучше всего описывать наши данные, хотелось бы, чтобы в результате регуляризации все коэффициенты при полиномиальных признаках степени выше третьей были равны нулю. И, оказывается, есть и такой регуляризатор.  
  

## ![$L^1$](https://habrastorage.org/getpro/habr/formulas/49f/ce2/920/49fce2920ea650dbd2e75dc0afc3b40f.svg) регуляризация

  
Попробуем теперь ограничить вектор параметров модели, используя ![$L^1$](https://habrastorage.org/getpro/habr/formulas/49f/ce2/920/49fce2920ea650dbd2e75dc0afc3b40f.svg) норму:  

![$\Large R\left(\vec{w}\right) = \left\| \vec{w} \right\|_1 = \sum_{j=1}^m \left| w_j \right|$](https://habrastorage.org/getpro/habr/formulas/453/9f3/84a/4539f384a9821db3814efb237b676cbc.svg)

  
Тогда задача примет вид:  

![$\Large \mathcal{L}\left(X, \vec{y}, \vec{w} \right) = \frac{1}{2n} \sum_{i=1}^n \left(\vec{x_i}^T \vec{w} - y_i\right)^2 + \lambda \sum_{j=1}^m \left| w_j \right|$](https://habrastorage.org/getpro/habr/formulas/36e/8b3/26e/36e8b326e8638c2e80b6ee8f3b714dd9.svg)

  
Посчитаем производную по параметрам модели (надеюсь уважаемые господа не будут пинать меня, за то, что я вжух и взял производную по модулю):  

![$\Large \frac{\partial \mathcal{L}}{\partial w_j} = \frac{1}{n}\sum_{i=1}^n \left(\vec{x_i}^T \vec{w} - y_i\right) \vec{x_i} + \lambda \text{sign}(w_j)$](https://habrastorage.org/getpro/habr/formulas/ae4/2a0/e13/ae42a0e13125fa456763c3bf5811908f.svg)

  
К сожалению, такая задача не имеет решения в явном виде. Для поиска хорошего приближенного решения мы воспользуемся методом [градиентного спуска](https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D0%B4%D0%B8%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D1%83%D1%81%D0%BA), тогда формула обновления весов примет вид:  

![$\Large \vec{w}_{\text{new}} := \vec{w} - \alpha \frac{\partial \mathcal{L}}{\partial \vec{w}}$](https://habrastorage.org/getpro/habr/formulas/464/931/8ed/4649318ed24fee05ac207428a724a69f.svg)

  
а в задаче появляется еще один гиперпараметр ![$\alpha$](https://habrastorage.org/getpro/habr/formulas/723/4a5/2ba/7234a52ba041cdb09b9328a047048fb2.svg), отвечающий за скорость спуска, его в машинном обучении называют скоростью обучения (learning rate).  
Запрограммировать такой алгоритм не составит труда, но нас ждет еще один сюрприз:  
  

```
lmbd = 1degree = 13dlist = [[1]*data['x_train'].shape[0]] + map(lambda n: data['x_train']**n, range(1, degree + 1))X = np.array(dlist).T# функция для вычисления среднеквадратичное ошибкиdef mse(u, v):    return ((u - v)**2).sum()/u.shape[0]# начальное приближениеw = np.array([-1.0] * X.shape[1])# максимальное количество итерацийn_iter = 20# сделаем скорость обучения очень маленькой, на всякий случай lr = 0.00000001loss = []for ix in range(n_iter):    w -= lr*(np.dot(np.dot(X, w) - data['y_train'], X)/X.shape[0] + lmbd*np.sign(w))    y_hat = np.dot(X, w)    loss.append(mse(data['y_train'], y_hat))    print loss[-1]
```

  
Получим такую вот эволюцию ошибки:  
  

```
1.3051230958e+38
1.21979102398e+58
1.14003816725e+78
1.06549974318e+98
9.95834819687e+117
9.30724755635e+137
8.69871743413e+157
8.12997446782e+177
7.59841727794e+197
7.10161456943e+217
6.63729401109e+237
6.20333184222e+257
5.79774315864e+277
5.41867283397e+297
inf
inf
inf
inf
inf
inf
```

  
Даже при такой небольшой скорости обучения, ошибка все равно растет и очень даже стремительно. Причина в том, что каждый признак измеряется в разных масштабах, от небольших чисел у полиномиальных признаков 1-2 степени, до огромных при 12-13 степени. Для того чтобы итеративный процесс сошелся, необходимо либо выбрать экстремально мелкую скорость обучения, либо каким-то образом нормализовать признаки. Применим следующее преобразование к признакам и попробуем запустить процесс еще раз:  
  

![$\Large \begin{array}{rcl} \overline{\mu}_{\cdot j} &=& \frac{1}{n} \sum_{i=1}^n x_{ij} \\ \overline{\sigma}_{\cdot j} &=& \sqrt{\frac{1}{n} \sum_{i=1}^n \left( x_{ij} - \overline{\mu}_{\cdot j} \right)^2} \end{array}$](https://habrastorage.org/getpro/habr/formulas/bea/d22/aae/bead22aae03693f659197387cf0952f6.svg)

  

![$\Large \vec{x}_{\text{new}} = \frac{\vec{x} - \overline{\mu}}{\overline{\sigma}}$](https://habrastorage.org/getpro/habr/formulas/778/8a5/56e/7788a556e6bfad80fd02dce615a075a7.svg)

  
  
Такое преобразование называется стандартизацией, распределение каждого признака теперь имеет нулевое матожидание и единичную дисперсию.  
  

```
lmbd = 1degree = 13dlist = [[1]*data['x_train'].shape[0]] + map(lambda n: data['x_train']**n, range(1, degree + 1))X = np.array(dlist).T# вычислим выборочное среднее каждого признакаx_mean = X.mean(axis=0)# вычислим выборочное стандартное отклонение признаковx_std = X.std(axis=0)# применим преобразованиеX = (X - x_mean)/x_stdX[:, 0] = 1.0w = np.array([-1.0] * X.shape[1])n_iter = 100lr = 0.1loss = []for ix in range(n_iter):    w -= lr*(np.dot(np.dot(X, w) - data['y_train'], X)/X.shape[0] + lmbd*np.sign(w))    y_hat = np.dot(X, w)    loss.append(mse(data['y_train'], y_hat))plt.plot(loss)plt.title('Train error')plt.xlabel('Iteration')plt.ylabel('MSE')plt.show()
```

  
Все стало сильно лучше.  
![](https://habrastorage.org/r/w1560/files/9e7/ec4/164/9e7ec41641d74a9dbcb696eeb60c1ec2.png)  
  
Нарисуем теперь все графики:  
  

```
degree_list = [1, 2, 3, 10, 12, 13]cmap = plt.get_cmap('jet')colors = [cmap(i) for i in np.linspace(0, 1, len(degree_list))]margin = 0.3plt.plot(data['support'], data['values'], 'b--', alpha=0.5, label='manifold')plt.scatter(data['x_train'], data['y_train'], 40, 'g', 'o', alpha=0.8, label='data')def mse(u, v):    return ((u - v)**2).sum()/u.shape[0]def fit_lr_l1(X, y, lmbd, n_iter=100, lr=0.1):    w = np.array([-1.0] * X.shape[1])    loss = []    for ix_iter in range(n_iter):        w -= lr*(np.dot(np.dot(X, w) - y, X)/X.shape[0] +lmbd*np.sign(w))        y_hat = np.dot(X, w)        loss.append(mse(y, y_hat))    return w, y_hat, loss    w_list_l1 = []for ix, degree in enumerate(degree_list):    dlist = [[1]*data['x_train'].shape[0]] + map(lambda n: data['x_train']**n, range(1, degree + 1))    X = np.array(dlist).T    x_mean = X.mean(axis=0)    x_std = X.std(axis=0)    X = (X - x_mean)/x_std    X[:, 0] = 1.0    w, y_hat, loss = fit_lr_l1(X, data['y_train'], lmbd=0.05)    w_list_l1.append((degree, w))    plt.plot(data['x_train'], y_hat, color=colors[ix], label='poly degree: %i' % degree)
```

  

**Отрисовка графика**

  
![](https://habrastorage.org/r/w1560/files/bf0/025/160/bf0025160260474db10907412587d5a4.png)  

|p|error|
|---|---|
|1|0.27204|
|2|0.23794|
|3|0.24118|
|10|0.18083|
|12|0.16069|
|13|0.15425|

  
Если посмотреть на коэффициенты, мы увидим, что большая часть из них близка к нулю (то, что у 13-ой степени коэффициент совсем не нулевой, можно списать на шум и малое количество примеров в обучающей выборке; так же стоит помнить, что теперь все признаки измеряются в одинаковых шкалах).  
  

**Визуализация коэффициентов**

  
Описанный способ построения регрессии называется LASSO регрессия. Очень хотелось бы думать, что дядька на коне бросает веревку и ворует коэффициенты, а на их месте остается нуль. Но нет, LASSO = least absolute shrinkage and selection operator.  
  

## Байесовская интерпретация линейной регрессии

  
Две вышеописанные регуляризации, да и сама лининейная регрессия с квадратичной функцией ошибки, могут показаться какими-то грязными эмпирическими трюками. Но, оказывается, если взглянуть на эту модель с другой точки зрения, с точки зрения байесовой статистики, то все становится по местам. Грязные эмпирические трюки станут априорными предположениями. В основе байесовой статистики находится формула Байеса:  
  

![$\Large \color{green}{p\left(y \mid x\right)} = \dfrac{\color{orange}{p\left(x \mid y\right)} \color{blue}{p\left(y\right)}}{\color{red}{p\left(x\right)}}$](https://habrastorage.org/getpro/habr/formulas/0bc/53f/f40/0bc53ff4003c7c4e5f9666b7683ca669.svg)

  

- ![$\color{blue}{p\left(y\right)}$](https://habrastorage.org/getpro/habr/formulas/94c/da5/f96/94cda5f96ab5770ee91d279a9f57c3c8.svg) — априорные ожидания (prior): насколько правдоподобна гипотеза перед наблюдением данных;
- ![$\color{orange}{p\left(x \mid y\right)}$](https://habrastorage.org/getpro/habr/formulas/045/faf/236/045faf23600fccd723e8ce5674b744eb.svg) — правдоподобие (likelihood): насколько правдоподобны данные при условии того, что гипотеза верна;
- ![$\color{red}{p\left(x\right) = \sum_{z} p\left(x \mid z\right) p\left(z\right)}$](https://habrastorage.org/getpro/habr/formulas/90a/7c5/2d7/90a7c52d7408d439a0bd033107f407fc.svg) — маргинальная вероятность (marginal probability или evidence): вероятность данных, усредненная по всевозможным гипотезам;
- ![$\color{green}{p\left(y \mid x\right)}$](https://habrastorage.org/getpro/habr/formulas/926/75c/0a7/92675c0a7efa64f91b6d45b9f5a51bf5.svg) — апостериорное распределение (posterior): насколько правдоподобна гипотеза при наблюдаемых данных.

  
В статистике обычно ищут точечную оценку максимума правдоподобия (ML = maximum likelihood):  

![$\Large \theta_{\text{ML}} = \arg \max_{\theta} p\left(D \mid \theta\right)$](https://habrastorage.org/getpro/habr/formulas/b18/853/f0b/b18853f0bc2cbd2bca228eaa2a05a7ac.svg)

  
  
В то время как в байесовом подходе интересуются апостериорным распределением:  

![$\Large p\left(\theta \mid D \right) \propto p\left(D \mid \theta\right) p\left( \theta \right)$](https://habrastorage.org/getpro/habr/formulas/7ae/416/d61/7ae416d61a8e8f3edf6c7e2a92186468.svg)

  
  
Часто получается так, что интеграл, полученный в результате байесового вывода, крайне нетривиален (в случае линейной регрессии это, к счастью, не так), и тогда нужна точечная оценка. Тогда мы интересуемся максимумом апостериорного распределения (MAP = maximum a posteriori):  
  

![$\Large \theta_{\text{MAP}} = \arg \max_{\theta} p\left(\theta \mid D\right) = \arg \max_{\theta} p\left( D \mid \theta\right) p\left(\theta\right)$](https://habrastorage.org/getpro/habr/formulas/651/88d/4b2/65188d4b286771dbc27b4b856447bc08.svg)

  
  
Давайте сравним ML и MAP гипотезы для линейной регрессии, это даст нам четкое понимание смысла регуляризаций. Будем считать, что все объекты из обучающей выборки были взяты из общей популяции независимо и равномерно распределенно. Это позволит нам записать совместную вероятность данных (правдоподобие) в виде:  

![$\Large p(D) = \prod_{i=1}^n p(x_i)$](https://habrastorage.org/getpro/habr/formulas/75a/fe3/059/75afe3059f94c96cadf4d81768ab2c24.svg)

  
  
А также будем считать, что целевая переменная подчиняется следующему закону:  

![$\Large y = \vec{w}^T \vec{x} + \epsilon, \epsilon \sim \mathcal{N}\left(0, \sigma^2\right)$](https://habrastorage.org/getpro/habr/formulas/4c8/a06/0d7/4c8a060d72de3b8ce3c5aa174f90218d.svg)

  
или  

![$\Large p\left(y \mid \vec{x}, \vec{w}, \sigma^2\right) = \mathcal{N}\left(y \mid \vec{w}^T \vec{x}, \sigma^2\right)$](https://habrastorage.org/getpro/habr/formulas/f4d/921/91e/f4d92191e9f97d2483430809af760425.svg)

  
Т.е. верное значение целевой переменной складывается из значения детерминированной линейной функции и некоторой непрогнозируемой случайной ошибки, с нулевым матожиданием и некоторой дисперсией. Тогда, мы можем записать правдоподобие данных как:  

![$\Large p\left(\vec{y} \mid X, \vec{w}, \sigma^2\right) = \prod_{i=1}^n \mathcal{N}\left(y_i \mid \vec{w}^T \vec{x}_i, \sigma^2\right)$](https://habrastorage.org/getpro/habr/formulas/6a2/506/75c/6a250675c2dc62d1413fd501e1bef095.svg)

  
удобнее будет прологарифмировать это выражение:  

![$\Large \begin{array}{rcl}\mathcal{L} &=& \ln p\left(\vec{y} \mid X, \vec{w}, \sigma^2\right) \\ &=& \ln \prod_{i=1}^n \mathcal{N}\left(y_i \mid \vec{w}^T \vec{x}_i, \sigma^2\right) \\ &=& \ln \frac{1}{\left(\sigma \sqrt{2\pi}\right)^n} e^{-\frac{1}{2\sigma^2} \sum_{i=1}^n \left(y_i - \vec{w}^T \vec{x}_i\right)^2} \\ &=& -\frac{n}{2}\ln 2\pi\sigma^2 -\frac{1}{2\sigma^2} \sum_{i=1}^n \left(y_i - \vec{w}^T \vec{x}_i\right)^2 \end{array}$](https://habrastorage.org/getpro/habr/formulas/d59/77c/9fa/d5977c9fa42063cb6619a1ee0c67695b.svg)

  
И внезапно мы увидим, что оценка, полученная методом максимального правдоподобия, – это то же самое, что и оценка, полученная методом наименьших квадратов. Сгенерируем новый набор данных большего размера, найдем ML решение и визуализируем его.  
  

```
data = generate_wave_set(1000, 100)X = np.vstack((np.ones(data['x_train'].shape[0]), data['x_train'])).Tw = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), data['y_train'])
```

  

**Отрисовка графика**

  
![](https://habrastorage.org/r/w1560/files/1ce/60e/360/1ce60e36083c49a9ac211a3829d1789c.png)  
  
По оси абсцисс и ординат отложены различные значения всех двух параметров модели (решаем именно линейную регрессию, а не полиномиальную), цвет фона пропорционален значению правдоподобия в соответствующей точке значений параметров. ML решение находится на самом пике, где правдоподобие максимально.  
  
Найдем MAP оценку параметров линейной регрессии, для этого придется задать какое-нибудь априорное распределение на параметры модели. Пусть для начала это будет опять нормальное распределение: ![$p\left(\vec{w}\right) = \mathcal{N}\left(\vec{w} \mid 0, \sigma_0^2 E\right)$](https://habrastorage.org/getpro/habr/formulas/b9b/1ba/c7e/b9b1bac7e8d29be0d81af1bf0283957c.svg).  
  

**Нормальное распределение**

  
Тогда апостериорное распределение примет вид:  

![$\Large p\left(\vec{w} \mid \vec{y}, X, \sigma^2\right) \propto \mathcal{N}\left(\vec{w} \mid 0, \sigma_0^2 E\right) \prod_{i=1}^n \mathcal{N}\left(y_i \mid \vec{w}^T \vec{x}_i, \sigma^2\right)$](https://habrastorage.org/getpro/habr/formulas/8ce/fa2/2e5/8cefa22e5cec39251d787f58e0a9d3ec.svg)

  
Если расписать логарифм этого выражения, то вы легко увидите, что добавление нормального априорного распределения — это то же самое, что и добавление ![$L^2$](https://habrastorage.org/getpro/habr/formulas/8ce/fc8/a63/8cefc8a639986035a1d5321efd3e8492.svg) нормы к функции стоимости. Попробуйте сделать это сами. Также станет ясно, что варьируя регуляризационный параметр, мы изменяем дисперсию априорного распределения: ![$\lambda = \frac{1}{2\sigma_0^2}$](https://habrastorage.org/getpro/habr/formulas/844/a53/521/844a5352176bcee7c34ff749623c6bba.svg).  
  

**Отрисовка графика**

  
![](https://habrastorage.org/r/w1560/files/fe5/709/fe6/fe5709fe61fd4f3b8832a61f5fa05b9c.png)  
  
Теперь на график добавились круги, исходящие от центра — это плотность априорного распределения (круги, а не эллипсы из-за того, что матрица ковариации данного нормального распределения диагональна, а на диагонали находится одно и то же число). Точками обозначены различные решения MAP задачи. При увеличении параметра регуляризации (что эквивалентно уменьшению дисперсии), мы заставляем решение отдаляться от ML оценки и приближаться к центру априорного распределения. При большом значении параметра регуляризации, все параметры будут близки к нулю.  
  
Естественно мы можем наложить и другое априорное распределение на параметры модели, например распределение Лапласа, тогда получим то же самое, что и при ![$L^1$](https://habrastorage.org/getpro/habr/formulas/49f/ce2/920/49fce2920ea650dbd2e75dc0afc3b40f.svg) регуляризации.  
  

**Распределение Лапласа**

  
Тогда апостериорное распределение примет вид:  
  

![$\Large p\left(\vec{w} \mid \vec{y}, X, \sigma^2\right) \propto \text{Laplace}\left(\vec{w} \mid 0, \beta\right) \prod_{i=1}^n \mathcal{N}\left(y_i \mid \vec{w}^T \vec{x}_i, \sigma^2\right)$](https://habrastorage.org/getpro/habr/formulas/c4a/da3/863/c4ada3863008f55233c3759a84b5d37f.svg)

  
  

**Отрисовка графика**

  
![](https://habrastorage.org/r/w1560/files/3ba/9ce/14d/3ba9ce14de964e4fada77c2995af82be.png)  
  
Глобальная динамика не изменилась: увеличиваем параметр регуляризации — решение приближается к центру априорного распределения. Также мы можем наблюдать, что такая регуляризация способствует нахождению разреженных решений: вы можете видеть два участка, на которых сначала один параметр равен нулю, затем второй параметр (в конце оба равны нулю).  
  
И на самом деле два описанных регуляризатора — это частные случаи наложения [обобщенного нормального распределения](https://en.wikipedia.org/wiki/Generalized_normal_distribution) в качестве априорного распределения на параметры линейной регрессии:  

![$\Large p\left(x \mid \alpha, \beta, \mu\right) = \frac{\beta}{2\alpha \Gamma\left(\frac{1}{\beta}\right)} e^{-\left(\frac{\left|x - \mu\right|}{\alpha}\right)^\beta}$](https://habrastorage.org/getpro/habr/formulas/8d5/0a6/49c/8d50a649c1b8bc7a3d4689ea7c55b515.svg)

  
  

**Отрисовка графика**

  
  
![](https://habrastorage.org/r/w1560/files/135/1c9/f5c/1351c9f5c9dc472586e0af7df3422ba6.png)  
  
Или же мы можем смотреть на эти регуляризаторы с точки зрения ограничения ![$L^p$](https://habrastorage.org/getpro/habr/formulas/922/445/155/922445155f1792301972953e6ed1665e.svg) нормы, как в предыдущей части:  

![$\Large \left\|x\right\|_p = \left( \sum_{i=1}^\infty \left|x\right|^p \right)^{\frac{1}{p}}$](https://habrastorage.org/getpro/habr/formulas/d8c/7d0/83b/d8c7d083b0a9ad64a11ec87b2a65ed5a.svg)

  
  

**Отрисовка графика**

  
![](https://habrastorage.org/r/w1560/files/5a2/988/288/5a298828891046cab9b18cce196e0997.png)  
  

## Заключение

  
[Здесь](https://github.com/mephistopheies/dds/blob/master/lr_040117/ipy/lecture.ipynb) вы найдете jupyter notebook со всем вышеописанным и несколькими бонусами. Отдельное спасибо тем, кто осилил этот текст до конца.  
  
Желающим копнуть эту тему глубже, рекомендую:  
  

- [лекции Сергея Николенко](http://logic.pdmi.ras.ru/~sergey/teaching/mlkfu2014.html), откуда позаимствована идея этого jupyter notebook'a;
- [лекции Бориса Демешева](https://www.youtube.com/playlist?list=PL-U1Z5tJ1i-YA-GdNXmQ8TEB0jjeDrDb_) по эконометрике (со 146ого видео), и его же [курс на курсере](https://ru.coursera.org/learn/ekonometrika).

  
Понимание линейной регрессии является ключом к пониманию более сложных моделей, вплоть до глубоких нейронных сетей. Если мы возьмем сигмойд от линейной функции — получим логистическую регрессию. Состекаем несколько логрегрессоров в один слой — получим softmax regression/max entropy regression. А если состекать несколько слоев — будет неронная сеть. Такие дела.  
  
Вступайте в [ods.ai](http://ods.ai/), приходите на наши сходки, we will make ML great again!