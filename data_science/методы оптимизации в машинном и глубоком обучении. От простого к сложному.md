---
link: https://habr.com/ru/articles/813221/
tags:
  - data
source: habr
data_type:
  - DS
---
В данной статье представлен обзор различных популярных (и не только) оптимизаторов, которые применяются в машинном и глубоком обучении, в частности для обучения нейронных сетей. Мы рассмотрим их основную идею и ключевые особенности, переходя от простых к более сложным концепциям. Помимо этого, в самом конце вы сможете найти большое количество дополнительных источников для более детального ознакомления с материалом.

> _Ноутбук с данным материалом можно загрузить на_ [**_Kaggle_**](https://www.kaggle.com/code/egazakharenko/optimization-methods-in-deep-learning) _(eng) и_ [**_GitHub_**](https://github.com/egaoharu-kensei/ML-algorithms-from-scratch.-Course-for-beginners/blob/main/Notebooks%20%5Brus%5D/09%29%20%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B%20%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8%20%D0%B2%20ML%20%D0%B8%20DL.ipynb) _(rus)._

### Содержание

- [Пару слов про функции потерь](https://habr.com/ru/articles/813221/#loss_functions)
    
- [Классический градиентный спуск](https://habr.com/ru/articles/813221/#classic_gradient_descent)
    
- [Более быстрые и точные оптимизаторы](https://habr.com/ru/articles/813221/#faster_optimizers)
    
- [Обучение и визуализация оптимизаторов](https://habr.com/ru/articles/813221/#optimizers_visualization)
    
- [Нарушение работы адаптивных методов со скользящим средним](https://habr.com/ru/articles/813221/#work_disruption)
    
- [Стратегии изменения скорости обучения](https://habr.com/ru/articles/813221/#learning_rate_changing)
    
- [Работа с большими мини-пакетами](https://habr.com/ru/articles/813221/#big_mini-batches)
    
- [Проксимальные методы](https://habr.com/ru/articles/813221/#proximal_methods)
    
- [Методы второго порядка](https://habr.com/ru/articles/813221/#second-order_methods)
    
- [Дополнительные источники](https://habr.com/ru/articles/813221/#additional_sources)
    

### Пару слов про функции потерь

Функции потерь можно разделить на выпуклые и невыпуклые. Первый вариант чаще всего встречается в классическом машинном обучении из-за относительной простоты моделей, а также из-за того, что у выпуклых функций локальный минимум по определению является и глобальным (но не обязательно единственным). Невыпуклые функции, в свою очередь, чаще всего встречаются в нейронных сетях из-за их высокой сложности и в данном случае поиск глобального минимума является трудной задачей, поэтому на практике здесь также используются методы из случая с выпуклыми функциями из-за их способности хорошо аппроксимировать стационарные точки в невыпуклом случае. Проще говоря, методы для выпуклого случая могут хорошо сходиться в локальном оптимуме для невыпуклого случая за приемлемое время, значение которого близко к глобальному.

### Классический градиентный спуск

Начнём с того, что если градиент — это вектор наибыстрейшего возрастания функции, то антиградиент — вектор наибыстрейшего убывания, и именно при движении в данную сторону будет расположена минимальная ошибка модели. Тогда градиентный спуск можно определить как численный метод итеративной оптимизации для нахождения весов (коэффициентов) модели путём минимизации её ошибки, представленной в виде функции потерь. Пример работы данного алгоритма на линейной и логистической регрессий с нуля можно посмотреть [здесь](https://habr.com/ru/articles/804135/) и [здесь](https://habr.com/ru/articles/803397/).

![Градиентный спуск для выпуклого и невыпуклого случая](https://habrastorage.org/r/w1560/getpro/habr/upload_files/bec/607/9ab/bec6079ab5f639b4486ab5af7edc44ef.png "Градиентный спуск для выпуклого и невыпуклого случая")

**Градиентный спуск для выпуклого и невыпуклого случая**

**Алгоритм строится следующим образом:**

- 1) изначально происходит инициализация весов с нулевыми значениями;
    
- 2) далее на основе установленных весов модель делает прогноз;
    
- 3) на основе полученного прогноза рассчитывается градиент ошибки, после чего происходит обновление весов в сторону антиградиента функции потерь;
    
- 4) шаги 2-3 повторяются до тех пор, пока градиент не станет нулевым, то есть пока алгоритм не сойдётся в минимуме (как правило, в данном случае используется критерий останова, например, пока разность градиентов на текущей и предыдущей итерациях не станет меньше заранее установленного порогового значения).
    

Если для вычисления градиентов функции потерь используется полный обучающий набор, то такой градиентный спуск называется **пакетным**. Не смотря на то, что пакетный градиентный спуск (batch gradient descent) практически всегда хорошо масштабируется в отношении количества признаков, данный алгоритм работает очень медленно на больших наборах данных и требует значительных затрат в виде дополнительной памяти для хранения всех градиентов.

Для увеличения производительности на больших датасетах применяются 2 подхода:

- 1) **Мини-пакетный** градиентный спуск (mini-batch gradient descent), когда на каждом шаге вычисление градиентов происходит на небольших случайных поднаборах (мини-пакетах). Обычно размер мини-пакета берётся в виде ![2^n](https://habrastorage.org/getpro/habr/upload_files/599/976/8b2/5999768b2618a72e79523aff1d8da65a.svg) и может достигать нескольких десятков тысяч образцов: выбор размера зависит от особенностей задачи и применяемой модели.
    
- 2) **Стохастический** градиентный спуск (stochastic gradient descent), когда на каждом шаге из обучающего набора берётся лишь один образец. Очевидно, что такой вариант должен работать гораздо быстрее предыдущего, но с другой стороны, из-за ещё более стохастический природы данный алгоритм менее стабилен и может потребоваться больше итераций для сходимости, а также mini-batch дает прирост в производительности из-за аппаратной оптимизации матричных вычислений на GPU. Стоит также отметить, что на данный момент под стохастическим градиентный спуском очень часто подразумевается mini-batch.
    

В отличие от пакетного градиентного спуска, в данных случаях функция потерь будет снижаться скачками вверх-вниз, приближаясь к минимуму, но так и не достигнув его. В случае с мини-пакетным градиентным спуском функция потерь будет расположена чуть ближе к минимуму за счёт меньшего размера скачков. С другой стороны, в отличие от стохастического градиентного спуска, ему может быть труднее пройти локальные минимумы в невыпуклом случае.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ae4/f62/1ad/ae4f621adc3ed5b1c915cf31fa304169.png)

### Более быстрые и точные оптимизаторы

Помимо того, что градиентный спуск в своём классическом представлении плохо подходит для невыпуклых случаев из-за вышеописанных проблем, может также возникнуть проблема с "седловыми точками", когда на поверхности функции потерь в виде седла имеются точки, в которых значение функции максимально по одним направлениям и минимально по другим, то есть в данных точках будет практически нулевое снижение градиентов и они ошибочно могут быть приняты моделью за оптимум. Поэтому для быстрого поиска оптимального решения используются более интересные стохастические (mini-batch) оптимизации, про самые популярные из которых сейчас и пойдёт речь.

#### Momentum

Предположим, что со склона с кочками катится мяч, который сначала будет двигаться медленно, но по мере накопления кинетической энергии его скорость будет расти, что ему поможет преодолеть небольшие кочки и остановить своё движение в более глубокой. Именно данный принцип лежит в основе моментной оптимизации. Momentum принимает во внимание значения предыдущих градиентов, которые используются для определения направления и скорости перемещения в пространстве параметров ![v_t](https://habrastorage.org/getpro/habr/upload_files/1b6/c02/ade/1b6c02ade95db30b652947ff7533d98c.svg) (называется вектором первого момента, поскольку масса в данном случае равна 1), а для предотвращения её быстрого увеличения используется коэффициент ослабления импульса ![\beta](https://habrastorage.org/getpro/habr/upload_files/d3a/181/d8e/d3a181d8e91ba50c0c5966bd3082b399.svg), который отвечает за силу влияния предыдущего градиента на текущий, то есть выступает в качестве механизма трения мяча о поверхность: значение 0 означает высокое трение, а 1 его отсутствие. Обычно значение ![\beta](https://habrastorage.org/getpro/habr/upload_files/ab3/fda/4c0/ab3fda4c07fc1e66a1ce744f3c75a7ab.svg) устанавливается 0.9.

**Алгоритм обновления параметров моментной оптимизации**

![v_t \leftarrow \beta v_{t-1} - \alpha dw_{t-1}](https://habrastorage.org/getpro/habr/upload_files/a3c/511/811/a3c5118113216cc39c77e82083cc119b.svg)

![w_t \leftarrow w_{t-1} + v_t](https://habrastorage.org/getpro/habr/upload_files/2cd/fc9/9f3/2cdfc99f35c3c5d9ec83a58ca58c7623.svg)

Momentum способен решить сразу две проблемы: плохую обусловленность матрицы Гессе и дисперсию стохастического градиента. С другой стороны, из-за вычисления градиента функции потерь в локальной позиции модель может колебаться вокруг локальных минимумов, что в свою очередь увеличивает время схождения.

> _Хотя во многих статьях ![v_t](https://habrastorage.org/getpro/habr/upload_files/b8c/9b9/238/b8c9b9238234abb553b67fd0797f9621.svg) обозначается как ![m_t](https://habrastorage.org/getpro/habr/upload_files/ca9/7b0/60c/ca97b060cee4355e676d5a1316beb48d.svg), а ![s_t](https://habrastorage.org/getpro/habr/upload_files/051/57d/376/05157d37639b2dfe44939de357b27d61.svg) как ![v_t](https://habrastorage.org/getpro/habr/upload_files/ed8/f8b/415/ed8f8b41530835e86bb68ceb6e69436c.svg), на данный момент нет единого стандарта и в разных статьях можно встретить для них разные обозначения, но для унификации во всех примерах будут использоваться следующие обозначения: ![v_t](https://habrastorage.org/getpro/habr/upload_files/1b4/131/119/1b4131119fce6e03297f9e09a7bdca3e.svg) — это первый момент или ещё по-другому экспоненциально взвешенное скользящее среднее градиентов, а ![s_t](https://habrastorage.org/getpro/habr/upload_files/962/a31/6a3/962a316a35d03d3efebef250745fe2e5.svg) — второй момент или экспоненциально взвешенное скользящее среднее квадратов градиентов, однако в случае AdaGrad это просто квадрат градиентов._

#### Nesterov momentum

Для решения вышеописанной проблемы применяется небольшая оптимизация, суть которой заключается в вычислении градиентов не в локальной позиции, а чуть дальше в направлении момента. Другими словами, функция потерь будет снижаться не в текущей позиции, а в которой якобы должна оказаться в будущем, следуя направлению импульса.

**Алгоритм обновления параметров моментной оптимизации Нестерова**

![v_t \leftarrow \beta v_{t-1} - \alpha d(w_{t-1} + \beta v_{t-1} )](https://habrastorage.org/getpro/habr/upload_files/56b/d43/251/56bd43251f4a427faccd0805bd157ac5.svg)

![w_t \leftarrow w_{t-1} + v_t](https://habrastorage.org/getpro/habr/upload_files/45a/45b/d28/45a45bd28c12045c020d75e6fc4383b7.svg)

![Схема Momentum vs Nesterov momentum](https://habrastorage.org/r/w1560/getpro/habr/upload_files/035/63b/a65/03563ba65815c6dfec968c891330e812.png "Схема Momentum vs Nesterov momentum")

**Схема Momentum vs Nesterov momentum**

Такой подход позволяет сойтись гораздо быстрее и чуть ближе к оптимуму, однако он всё ещё может быть чувствительным в отношении одних направлений пространства параметров и нечувствительным в других из-за трудностей подбора оптимальной скорости обучения. Ниже будут представлены оптимизации градиентного спуска с адаптивной скоростью обучения.

#### AdaGrad

Adaptive Gradient является одной из первых оптимизаций градиентного спуска с адаптивным шагом, в которой снижается градиент вдоль самых крутых направлений. Проще говоря, на каждом шаге происходит обновление параметров модели с учётом значений как предыдущих градиентов, так и их квадратов.

**Алгоритм обновления параметров AdaGrad**

![s_t \leftarrow s_{t-1} + dw_{t-1}^2](https://habrastorage.org/getpro/habr/upload_files/4bd/97f/bc2/4bd97fbc25b75fefd329c1ce09b8126e.svg)

![w_t \leftarrow w_{t-1} - \frac{\alpha}{\sqrt{s_t + \epsilon}} dw_{t-1}](https://habrastorage.org/getpro/habr/upload_files/9e2/ec7/462/9e2ec7462d500efd2670433729c5a095.svg)

Где ![\epsilon = 1e-8](https://habrastorage.org/getpro/habr/upload_files/aaf/58c/0f8/aaf58c0f82223a093ef0059c7f17a78a.svg) — сглаживающий параметр для избегания деления на ноль.

Такой простой подход позволяет алгоритму быстро начать обучение, а затем замедлить его, когда градиент становится меньше или меняет знак. Однако на практике AdaGrad хорошо справляется с выпуклыми случаями, а вот при обучении нейронных сетей нередко останавливается слишком рано из-за быстрого снижения скорости обучения, так и не достигнув глобального оптимума.

#### RMSProp

RMSProp (Root Mean Square Propagation) — модификация AdaGrad, адаптированная для лучшей работы в невыпуклом случае. Основная идея заключается в изменении способа агрегирования градиента на экспоненциально взвешенное скользящее среднее. Другими словами, вместо накопления всех квадратов градиента с начала обучения, накапливаются квадраты градиента только из самых последних итераций.

**Алгоритм обновления параметров RMSProp**

![s_t \leftarrow \beta s_{t-1} + (1 - \beta) dw_{t-1}^2](https://habrastorage.org/getpro/habr/upload_files/f3a/006/0c8/f3a0060c8217d2d97898defbe68bb24f.svg)

![w_t \leftarrow w_{t-1} - \frac{\alpha}{\sqrt s_t + \epsilon} dw_{t-1}](https://habrastorage.org/getpro/habr/upload_files/5fa/815/0a9/5fa8150a95be84bded970bdcd39e8609.svg)

В целом, RMSProp является крайне эффективной оптимизацией, но не самой лучшей. Например, могут возникнуть трудности обучения в многомерных пространствах из-за проблем с масштабированием градиентов в разных направлениях.

#### Adam и его модификации

Adam (Adaptive Moment Estimation) объединяет в себе концепции Momentum и RMSProp, практически являясь серебряной пулей в задачах стохастической оптимизации. Как можно заметить, расчёт моментов в Adam очень схож с Momentum и RMSProp за исключением того, что к ним применяется поправка на смещение. В целом, благодаря таким улучшениям Adam сходится быстрее и лучше предшественников, а также более устойчив к подбору гиперпараметров, что делает его более стабильным решением в большинстве случаев.

**Алгоритм обновления параметров Adam**

![v_t \leftarrow \beta_1 v_{t-1} + (1 - \beta_1) dw_{t-1}](https://habrastorage.org/getpro/habr/upload_files/525/f29/3ff/525f293ffb71f760d0ea730e686f5053.svg)

![s_t \leftarrow \beta_2 s_{t-1} + (1 - \beta_2) dw_{t-1}^2](https://habrastorage.org/getpro/habr/upload_files/7b5/1a9/fc4/7b51a9fc4fdd3a4a4b0b56f32f437d82.svg)

![w_t \leftarrow w_{t-1}  - \alpha \frac{v_t}{\sqrt s_t + \epsilon}](https://habrastorage.org/getpro/habr/upload_files/1bf/1b5/3c8/1bf1b53c80e71e7de646d2a816b4a888.svg)

Поправка на смещение:

![v_t \leftarrow \frac{v_t}{1 - \beta_1^t}](https://habrastorage.org/getpro/habr/upload_files/bf4/e48/b29/bf4e48b29a6988392622e9b41ffe7ade.svg)

![s_t \leftarrow \frac{s_t}{1 - \beta_2^t}](https://habrastorage.org/getpro/habr/upload_files/4ff/e1f/be4/4ffe1fbe4936c003276f7e567320fdff.svg)

Где ![\beta_1 = 0.9, \ \ \beta_2 = 0.99](https://habrastorage.org/getpro/habr/upload_files/dde/e2b/b68/ddee2bb6836cf055849042210cad9b5c.svg) используются по умолчанию.

С другой стороны, данный алгоритм более сложен в анализе и может быть чувствителен к шуму, что может привести к проблемам со сходимостью, а также он требует больших объемов памяти, поскольку хранит не только параметры модели, но а также информацию о градиентах и накопленном импульсе. Помимо этого, у Adam и всех предыдущих алгоритмов есть ещё один неприятный недостаток: если продолжить обучение модели после прерывания в некоторой точке, придётся восстанавливать не только веса модели из данной точки, но а также и всю информацию о накопленных параметрах.

Однако время не стоит на месте и были разработаны модификации Adam, призванные устранить в той или иной степени недостатки, описанные выше. К наиболее популярным и интересным модификациям можно отнести следующие:

- **AdaMax** использует экспоненциально взвешенную норму бесконечности для обновления вектора второго момента, то есть скорость обучения изменяется, основываясь максимальной величине градиента в истории:
    

![s_t \leftarrow max(\beta_2 s_{t-1} |dw_{t-1}|)](https://habrastorage.org/getpro/habr/upload_files/95c/fe5/bcd/95cfe5bcd8c2ac5ed372b5d85863cf75.svg)

- **Nadam** (Nesterov-accelerated Adaptive Moment Estimation) использует другую поправку на смещение для вектора первого момента:
    

![\hat v_t \leftarrow \frac{(1 - \beta_1^t) dw_{t-1}}{1 - \Pi_{i=1}^{t} \beta_1^i} + \frac{\beta_1^{t+1} v_t}{1 - \Pi_{i=1}^{t+1} \beta_1^i}](https://habrastorage.org/getpro/habr/upload_files/53a/814/ff8/53a814ff833d43733e8dec05e3185c42.svg)

- **AdamW** добавляет L2-регуляризацию к функции потерь и при обновлении весов:
    

![w_t \leftarrow w_{t-1}  - \frac{\alpha v_t}{\sqrt s_t + \epsilon} + \lambda w_{t-1}](https://habrastorage.org/getpro/habr/upload_files/5b5/2ae/38b/5b52ae38b25a4a4ac968f3387d771a8e.svg)

- **Yogi** обновляет вектор второго момента с учётом разности второго момента и квадрата градиента:
    

![s_t \leftarrow  s_{t-1} - (1 - \beta_2) sign(s_{t-1} - dw_{t-1}^2) dw_{t-1}^2](https://habrastorage.org/getpro/habr/upload_files/e84/44d/eab/e8444deab22df912d5cca43d3ceefb69.svg)

- **Adan** (Adaptive Nesterov Momentum) использует модифицированный New Nesterov Momentum (NME позволяет избежать дополнительных затрат на вычисление градиента в точке экстраполяции) для оценки первого и второго моментов, что позволяет значительно ускорить сходимость и найти приближённую точку первого порядка с заданной точностью ϵ. Схема работы алгоритма выглядит следующим образом:
    

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a71/f3f/93f/a71f3f93f9ae182cb2378caf175c6b36.png)

#### Обучение и визуализация оптимизаторов

Для наглядности рассмотрим небольшой пример работы различных оптимизаторов на данных [Boston Housing](https://www.kaggle.com/datasets/arunjangir245/boston-housing-dataset). Сначала мы создадим простую нейросеть в Pytorch и обучим её на всех тренировочных данных, на которых после же оценим снижение потерь оптимизаторов на каждой итерации. Также для любителей Keras мы обучим простую нейросеть на мини-пакетах, но уже оценим снижение потерь на тестовом наборе.

**Загрузка и подготовка датасета**

```
import pandas as pdimport matplotlib.pyplot as pltfrom sklearn.preprocessing import StandardScalerfrom sklearn.model_selection import train_test_splitdf_path = "/content/drive/MyDrive/BostonHousing.csv"boston = pd.read_csv(df_path)print(boston)        crim    zn  indus  chas    nox     rm   age     dis  rad  tax  \0    0.00632  18.0   2.31     0  0.538  6.575  65.2  4.0900    1  296   1    0.02731   0.0   7.07     0  0.469  6.421  78.9  4.9671    2  242   2    0.02729   0.0   7.07     0  0.469  7.185  61.1  4.9671    2  242   3    0.03237   0.0   2.18     0  0.458  6.998  45.8  6.0622    3  222   4    0.06905   0.0   2.18     0  0.458  7.147  54.2  6.0622    3  222   ..       ...   ...    ...   ...    ...    ...   ...     ...  ...  ...   501  0.06263   0.0  11.93     0  0.573  6.593  69.1  2.4786    1  273   502  0.04527   0.0  11.93     0  0.573  6.120  76.7  2.2875    1  273   503  0.06076   0.0  11.93     0  0.573  6.976  91.0  2.1675    1  273   504  0.10959   0.0  11.93     0  0.573  6.794  89.3  2.3889    1  273   505  0.04741   0.0  11.93     0  0.573  6.030  80.8  2.5050    1  273        ptratio       b  lstat  medv  0       15.3  396.90   4.98  24.0  1       17.8  396.90   9.14  21.6  2       17.8  392.83   4.03  34.7  3       18.7  394.63   2.94  33.4  4       18.7  396.90   5.33  36.2  ..       ...     ...    ...   ...  501     21.0  391.99   9.67  22.4  502     21.0  396.90   9.08  20.6  503     21.0  396.90   5.64  23.9  504     21.0  393.45   6.48  22.0  505     21.0  396.90   7.88  11.9  [506 rows x 14 columns]
```

```
print(boston.isna().sum())crim       0zn         0indus      0chas       0nox        0rm         5age        0dis        0rad        0tax        0ptratio    0b          0lstat      0medv       0dtype: int64
```

```
boston.dropna(inplace=True)X, y = boston.iloc[:, :-1].values, boston.iloc[:, -1].valuesX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)X_train_s = StandardScaler().fit_transform(X_train)X_test_s = StandardScaler().fit_transform(X_test)
```

**Параметры нейросети**

```
nn_params = {'in_features': X.shape[1], 'h1': 16, 'h2': 8, 'out': 1}
```

**Сравнение оптимизаторов Pytorch на тренировочных данных**

```
from torch import nn, optim, FloatTensor, relu, manual_seedclass TorchNN(nn.Module):    def __init__(self, in_features, h1, h2, out):        super(TorchNN, self).__init__()        self.fc1 = nn.Linear(in_features, h1)        self.fc2 = nn.Linear(h1, h2)        self.fc3 = nn.Linear(h2, out)    def forward(self, x):        x = relu(self.fc1(x))        x = relu(self.fc2(x))        x = self.fc3(x)        return xdef torch_losses(data, model, optim_cls, optim_params, num_epochs=100):    losses = []    X_train, y_train = data    criterion = nn.MSELoss()    optimizer = optim_cls(model.parameters(), **optim_params)    for epoch in range(num_epochs):        y_pred = model.forward(X_train)        loss = criterion(y_pred, y_train)        losses.append(loss.item())        optimizer.zero_grad()        loss.backward()        optimizer.step()    return lossesmanual_seed(0)X_train_s_tensor = FloatTensor(X_train_s)y_train_tensor = FloatTensor(y_train).view(-1, 1)torch_optimizers = [    (optim.SGD, 'SGD', {'lr': 0.001}),    (optim.SGD, 'Momentum', {'lr': 0.001, 'momentum': 0.9}),    (optim.SGD, 'Nesterov Momentum', {'lr': 0.001, 'momentum': 0.9, 'nesterov': True}),    (optim.Adagrad, 'Adagrad', {'lr': 0.01}),    (optim.RMSprop, 'RMSprop', {'lr': 0.01}),    (optim.Adam, 'Adam', {'lr': 0.01}),    (optim.Adamax, 'Adamax', {'lr': 0.01}),    (optim.AdamW, 'AdamW', {'lr': 0.01}),    (optim.NAdam, 'NAdam', {'lr': 0.01})    ]# Visualizationplt.figure(figsize=(14, 6))for optim_cls, optim_name, optim_params in torch_optimizers:    nn_model = TorchNN(**nn_params)    t_losses = torch_losses((X_train_s_tensor, y_train_tensor), nn_model, optim_cls, optim_params)    plt.plot(range(len(t_losses)), t_losses, label=f'{optim_name}')plt.title('Pytorch optimizers comparison on train data')plt.xlabel('Epoch')plt.ylabel('Loss')plt.legend()plt.show()
```

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/117/91a/8d3/11791a8d3b5afc26b7f62d02cd62f169.png)

**Сравнение оптимизаторов Keras на тестовых данных**

```
from keras import optimizersfrom keras.layers import Densefrom keras.models import Sequentialfrom keras.utils import set_random_seeddef create_keras_nn(optimizer, in_features, h1, h2, out):    model = Sequential()    model.add(Dense(input_shape=(in_features,), units=h1, activation='relu'))    model.add(Dense(input_shape=(h1,), units=h2, activation='relu'))    model.add(Dense(units=out))    model.compile(optimizer=optimizer, loss='mse', metrics=['mse'])    return modeldef keras_losses(train_data, test_data, optimizers, nn_params, num_epochs=10):    losses = []    X_train, y_train = train_data    X_test, y_test = test_data    for name, optimizer in optimizers:        model = create_keras_nn(optimizer, **nn_params)        model_history = model.fit(X_train, y_train, batch_size=32, epochs=num_epochs,                                  verbose=0, validation_data=(X_test, y_test))        losses.append((name, model_history.history['val_loss']))    return lossesset_random_seed(0)keras_optimizers = [    ('SGD', optimizers.SGD(learning_rate=0.001)),    ('Momentum', optimizers.SGD(learning_rate=0.001, momentum=0.9)),    ('Nesterov Momentum', optimizers.SGD(learning_rate=0.001, momentum=0.9, nesterov=True)),    ('Adagrad', optimizers.Adagrad(learning_rate=0.01)),    ('RMSprop', optimizers.RMSprop(learning_rate=0.01)),    ('Adam', optimizers.Adam(learning_rate=0.01)),    ('Adamax', optimizers.Adamax(learning_rate=0.01)),    ('AdamW', optimizers.AdamW(learning_rate=0.01)),    ('Nadam', optimizers.Nadam(learning_rate=0.01))    ]plt.figure(figsize=(14, 6))k_losses = keras_losses((X_train_s, y_train), (X_test_s, y_test), keras_optimizers, nn_params)for name, k_loss in k_losses:    plt.plot(k_loss, label=name + ' test Loss')plt.title('Keras optimizers comparison on test data')plt.xlabel('Epoch')plt.ylabel('Loss')plt.legend()plt.show()
```

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/059/770/9bb/0597709bb5c7475a8b62bf698d60c6fc.png)

#### Промежуточные выводы

Поскольку SDG, Momentum и Nesterov momentum являются менее стабильными алгоритмами и больше всего зависят от начальных значений learning rate, для них была задана меньшая скорость обучения, чем для остальных методов. На первом графике видно, что даже в таком случае эти алгоритмы немного подвержены колебаниям, хотя и быстро сошлись. Второй же график хорошо демонстрирует как обучение на мини-пакетах значительно ускоряет сходимость алгоритмов. В случае с AdaGrad возникла классическая проблема резкого снижения скорости обучения, которую в данном случае можно легко решить, установив изначально более высокое значение. А вот RMSprop хорошо сработал в обоих случаях и даже лучше Adam-подобных оптимизаторов.

Отсюда следует интересный вывод, что адаптивные методы могут сходиться быстрее предшественников далеко не в каждой ситуации, но зато они гораздо стабильнее минимизируют функцию потерь. Конкретно в данном случае это означает, что если мы установим одинаковые произвольные значения learning rate для всех оптимизаторов, то неадаптивные методы зачастую будут снижаться с очень большими рывками и могут не сойтись вообще, в то время как адаптивные методы будут более плавно сходиться, хоть и медленно.

Стоит добавить, что данный пример лишь в очередной раз доказывает, что нет универсального оптимизатора, который являлся бы лучшим выбором для всех задач машинного обучения, поскольку многое зависит от самых разных факторов, включая природу данных, сложность модели и цели обучения. Однако это не отменяет тот факт, что в случае со сложными ландшафтами потерь адаптивные методы практически всегда будут превосходить простые стохастические оптимизаторы не только в плане стабильности, но и конечно же в скорости. Поэтому в большинстве ситуаций RMSprop и особенно семейство оптимизаторов Adam можно рассматривать в качестве хорошего стартового решения.

### Нарушение работы адаптивных методов со скользящим средним

Поскольку работа всех диагональных адаптивных методов в той или иной степени основана на использовании покоординатного learning rate, то в случае, когда последовательность  ![s_t](https://habrastorage.org/getpro/habr/upload_files/c2f/fbb/a31/c2ffbba31630980ccc6a2959a71caee7.svg) перестаёт монотонно не убывать, алгоритм не может нормально сойтись к локальным минимумам. Как правило, такая ситуация означает приближение к критическим точкам и происходит при уменьшении ![dw_{t-1}^2](https://habrastorage.org/getpro/habr/upload_files/e6c/949/a7f/e6c949a7f72551fad8ec6d5de5ba298a.svg) в сравнении с предыдущей накопленной историей с точностью до некоторой константы.

Данную проблему можно устранить путём наделения таких алгоритмов долговременной памятью о прошлых градиентах для исключения отрицательных регуляризаторов подобно тому, как это реализовано в **AMSGrad**. Проще говоря, выполняется условие ![s_t >= s_{t-1}](https://habrastorage.org/getpro/habr/upload_files/077/1ce/a2b/0771cea2bb4324673c84da3ebac3c4a6.svg), что возможно благодаря простому трюку:

![\hat s_0 = 0, \ \hat s_t = max(\hat s_{t-1}, s_t) \ and \ \hat S_t = \ diag(\hat s_t)](https://habrastorage.org/getpro/habr/upload_files/eec/ab7/ef4/eecab7ef4605d0f144ac7f873dbf1fd7.svg)

Однако стоит иметь в виду, что в таком случае требуются дополнительные расходы памяти, что может быть особенно проблематично для моделей с разреженными параметрами. Решить данную проблему можно за счёт использования непостоянных ![\beta_1^t](https://habrastorage.org/getpro/habr/upload_files/7f3/64e/bbf/7f364ebbf4a90774e28ff390147be806.svg) и ![\beta_2^t](https://habrastorage.org/getpro/habr/upload_files/abc/111/dfb/abc111dfb78d60c080ca82a8ae6e69c9.svg), что было предложено в алгоритме **AdamNC**:

![v_t \leftarrow \beta_1^t v_{t-1} + (1 - \beta_1^t) dw_{t-1} \\  s_t \leftarrow \beta_2^t s_{t-1} + (1 - \beta_2^t) dw_{t-1}^2](https://habrastorage.org/getpro/habr/upload_files/23b/272/afe/23b272afef72055552c2d5e6f04e023c.svg)

Помимо того, что такой подход не требует изменения структуры оригинального Adam, он также позволяет достичь хороших показателей сходимости.

Однако в работе Tran Thi Phuong и Le Trieu Phong было показано, что проблема в доказательстве сходимости AMSGrad заключается в обработке гиперпараметров, рассматривая их как равные, в то время как это не совсем верно. Так авторами был представлен контрпример в контексте простой задачи выпуклой оптимизации, который показывает эту проблему. Алгоритм должен сходиться согласно следующей лемме:

![R(T) \leq \sum_{i=1}^{d} \sum_{t=1}^{T} \frac{\sqrt{\hat{s}_{t,i}}}{2\alpha_t(1 - \beta_1^t)} ((w_{t,i} - w^*_{i})^2 - (w_{t+1,i} - w^*_{i})^2) + \\ + \sum_{i=1}^{d} \sum_{t=1}^{T} \frac{\alpha_t}{1 - \beta_1} \frac{v^2_{t,i}}{\sqrt{\hat{s}_{t,i}}} + \sum_{i=1}^{d} \sum_{t=2}^{T} \frac{\beta_1^t \sqrt{\hat{s}_{t-1,i}}}{2\alpha_{t-1}(1 - \beta_1)} (w_{t,i} - w^*_{i})^2](https://habrastorage.org/getpro/habr/upload_files/4a7/575/83b/4a757583bf2b02799d476269ca6986d0.svg)

Однако проблема заключается в равенстве, которое на самом деле может быть как положительным, так и отрицательным:

![(w_{t,i} - w^*_{i})^2 - (w_{t+1,i} - w^*_{i})^2](https://habrastorage.org/getpro/habr/upload_files/3e6/463/8af/3e64638af1529702fc469239d5fddf91.svg)

Поэтому авторы представили новое доказательство сходимости для AMSGrad, а также алгоритм **AdamX** на его основе, который учитывает различия в гиперпараметрах и позволяет избежать проблемы выше. Решение выглядит следующим образом:

![\hat s_1 = s_1, \ \hat s_t = max \left(\frac{(1 - \beta_1^t)^2}{(1 - \beta_1^{t-1})^2} \hat s_{t-1}, s_t \right) \ \ if \ \ t \geq 2, \ and \ \hat S_t = diag(\hat s_t)](https://habrastorage.org/getpro/habr/upload_files/469/173/019/469173019a68c5bf45c9b48d4fd97e21.svg)

Но стоит иметь в виду, что как и в случае с AMSGrad, AdamX также требует дополнительных расходов памяти.

### Стратегии изменения скорости обучения

Как можно было заметить, скорость обучения является одним из ключевых параметров в градиентном спуске, которая может оказывать значительное влияние на сходимость и конечную ошибку модели. Помимо вышеописанных стратегий сокращения скорости обучения, ещё одними из самых популярных являются следующие:

- 1) ![\alpha = \frac{1}{1 + decay \_ rate * t} \alpha_0 \ - \](https://habrastorage.org/getpro/habr/upload_files/f11/2cf/7be/f112cf7be4f43faf825ea6495a83d4ae.svg)плавное затухание;
    
- 2) ![\alpha = k^t \alpha_0 \ - \](https://habrastorage.org/getpro/habr/upload_files/306/87f/753/30687f753c3c004f298738ccfb80fe15.svg)экспоненциальное затухание;
    
- 3) ![\alpha = \frac{k}{\sqrt{t}} \alpha_0](https://habrastorage.org/getpro/habr/upload_files/765/b6c/fde/765b6cfde9a11d53d7b1b54c9530af8e.svg), где ![k \ -](https://habrastorage.org/getpro/habr/upload_files/1a3/39e/d33/1a339ed33be378d2394468396624db38.svg) константа, а ![t \ -](https://habrastorage.org/getpro/habr/upload_files/ac0/85c/47e/ac085c47ee8ff49cdb7c6ade37c5ff61.svg) число итераций;
    
- 4) дискретное сокращение, когда после заданного количества итераций шаг уменьшается с определённым размером.
    

Не смотря на то, что на сегодняшний день в алгоритмах на основе градиентного спуска используется автоматическое снижение скорости обучения как в библиотеке sckit-learn, так и в библиотеках глубокого обучения, подбор learning rate всё ещё нужно выполнять аккуратно: алгоритм может преждевременно выйти на плато либо вовсе разойтись. Пример приведён на графике ниже.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c9f/b83/26c/c9fb8326c6192505e6d9f344215a36f8.png)

Другим подходом в изменении скорости обучения является её резкое увеличение, чтобы "вытолкнуть" модель из возможных локальных минимумов, в которых она может застрять в процессе обучения. Такой подход называется **Warm Restart** и включает в себя циклическое изменение скорости обучения: начиная с высокого значения, скорость постепенно снижается по определённому правилу, а затем после достижения минимального значения она снова повышается. Это особенно полезно, когда модель сходится к неоптимальному решению из-за плохой инициализации или когда пространство параметров содержит множество локальных минимумов.

Одним из популярных методов, использующий такой подход, является [CosineAnnealingWarmRestarts](https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.CosineAnnealingWarmRestarts.html#torch.optim.lr_scheduler.CosineAnnealingWarmRestarts), в котором скорость обучения регулируется на основе "косинусного отжига" с перезапусками, возвращаясь к своему начальному значению:

![η_t = η_{min} + \frac{1}{2}(η_{max} - η_{min})(1 + \cos(\frac{T_{cur}}{T_{i}}\pi))](https://habrastorage.org/getpro/habr/upload_files/4c7/754/784/4c7754784aa2cc7e494618be9a4f1bec.svg)

Где:

- ![\eta_t](https://habrastorage.org/getpro/habr/upload_files/de7/6c6/6b9/de76c66b9524c5184c8956e3b61d4b00.svg) — скорость обучения в момент времени ![t](https://habrastorage.org/getpro/habr/upload_files/d77/bef/c36/d77befc36bf8863129d7fabe48720fe8.svg);
    
- ![\eta_{\text{max}}](https://habrastorage.org/getpro/habr/upload_files/649/069/94c/64906994c20869d5ac238132b020f807.svg) — начальная скорость обучения;
    
- ![\eta_{\text{min}}](https://habrastorage.org/getpro/habr/upload_files/0f8/9a6/0ce/0f89a60cea7f63d186f4cbac5e596838.svg) — минимальная скорость обучения;
    
- ![T_{\text{cur}}](https://habrastorage.org/getpro/habr/upload_files/f9d/76d/e28/f9d76de28af7fd3ca276dddd542ba8fc.svg) — количество эпох с момента последнего перезапуска;
    
- ![T_i](https://habrastorage.org/getpro/habr/upload_files/596/204/0d5/5962040d5f486d90da8795c6bb0ad156.svg) — количество эпох между двумя перезапусками.
    

С полным списком "планировщиков" скорости обучения можно ознакомиться [здесь](https://pytorch.org/docs/stable/optim.html#how-to-adjust-learning-rate) и [здесь](https://(https//www.tensorflow.org/api_docs/python/tfm/optimization/lr_schedule).

### Работа с большими мини-пакетами

Рассмотрим ситуацию, когда нам необходимо обучить сложную нейронную сеть на больших данных с использованием нескольких графических процессоров (GPU). Одно из самых простых решений будет заключаться в вычислении стохастических градиентов для каждого батча отдельно на разных GPU с их последующим усреднением по всем GPU на каждом этапе обновления параметров модели.

По сути, такой подход равносилен обучению с одним огромным батчем и на первый взгляд может показаться оптимальным, но не всё так просто, поскольку это может привести к такому явлению как generalization gap, при котором возникает ухудшение обобщающей способности модели (иногда значительное). Почему так происходит? При использовании батча большого размера оптимизатор начинает лучше распознавать ландшафт функции потерь для определённой выборки, что увеличивает шансы скатиться в узкие локальные минимумы с низкой обобщающей способностью. Тогда даже при незначительном сдвиге ландшафта (при так называемом distributional shift, когда происходит переход от тренировочной выборки к тестовой) значение функции потерь может резко увеличиться. Проще говоря, большие батчи могут приводить к переобучению.

С другой стороны широкие локальные минимумы более устойчивы к изменениям в ландшафте функции потерь и способны обеспечить лучшую обобщающую способность, а для того чтобы в них попадать можно использовать оптимизаторы с более точным динамическим подбором learning rate, про которые далее пойдёт речь. Однако перед этим стоит добавить, что использование маленьких батчей в оптимизации также является не самой хорошей идеей, поскольку это может привести к более шумным оценкам градиента и в конечном счёте к недообучению модели.

#### LARS

Первым на очереди будет Layer-wise Adaptive Rate Scaling (LARS), использующий momentum в качестве базового алгоритма. Его основная идея заключается в подборе скорости обучения не для каждого нейрона или всей нейросети, а для каждого слоя отдельно. Проще говоря, обновление весов происходит с учётом локального learning rate, рассчитанного как отношение нормы весов к сумме нормы весов и градиентов. Работа алгоритма показана ниже:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c94/e51/941/c94e51941728de845a0b097bbc1946d3.png)

Не смотря на то, что такой метод позволяет использовать батчи большого размера для обучения без потери качества, он плохо справляется со сложными моделями, где каждый слой имеет важное значение для общей производительности, например, с моделями внимания, такими как BERT. Это связано с тем, что если в одном из слоёв сети наблюдается нестабильное снижение градиентов, то к этому слою будет применяться меньшая скорость обучения, а поскольку LARS стремится синхронизировать обновления по всем слоям, то скорости обучения для более "стабильных" слоёв также будут снижены для предотвращения расхождения в обучении. Следовательно, более "стабильные" слои будут обновляться не так быстро, как могли бы, что в итоге значительно замедлит обучение всей модели и окажет негативное влияние на конечный результат.

#### LAMB

В ответ на это был разработан более продвинутый оптимизатор, известный как Layer-wise Adaptive Moments Based optimizer (LAMB), который можно рассматривать как применение LARS к оптимизатору Adam. Основное различие заключается в использовании двойной стратегии нормализации:

- 1) Нормализация каждого измерения (или параметра модели) относительно квадратного корня из второго момента, используемого в Adam. Это означает, что каждый параметр модели обновляется с учётом его собственной истории изменений, что помогает более точно настраивать веса модели.
    
- 2) Применение послойной нормализации. Другими словами, обновления параметров модели происходят с учётом масштаба каждого слоя в нейронной сети. Это помогает предотвратить слишком большие изменения в весах слоёв и избежать нестабильности в процессе обучения.
    

Алгоритм работает следующим образом:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/db7/2b0/188/db72b0188b811ea37cf4067348c8f00a.png)

Такой подход позволил значительно улучшить процесс обучения модели BERT даже на батчах большого размера без потери точности. Так команде Google Brain удалось сократить время обучения с 3 дней до всего лишь 76 минут, увеличив размер пакета до предела памяти модуля TPUv3. Более того, как и другие оптимизаторы, LAMB имеет ряд модификаций, способных не только ускорить обучение (как в NVLAMB благодаря предварительной нормализации градиентов), но и сделать его ещё более стабильным в плане сходимости (как в N-LAMB и NN-LAMB).

### Прокcимальные методы

Проксимальные методы — это класс алгоритмов, предназначенных для решения задач выпуклой оптимизации негладких функций. Основная идея таких методов заключается в замене исходной сложной задачи оптимизации на серию более простых подзадач, аппроксимируя новое решение к текущему. Другими словами, данные методы представляют собой обобщение проективных градиентных методов.

#### Метод проксимальной минимизации

Может быть полезен в тех случаях, когда трудно минимизировать функцию потерь ![f](https://habrastorage.org/getpro/habr/upload_files/475/40e/544/47540e544cc172cacd1c421d77b5948e.svg), но легко (или хотя бы проще) минимизировать её регуляризованную версию, то есть ![f](https://habrastorage.org/getpro/habr/upload_files/6ab/c86/db8/6abc86db88baac23d128329c7fef3988.svg) плюс квадратичная величина. Данный алгоритм имеет множество разных интерпретаций в зависимости от целей использования. Наиболее популярными являются следующие:

- 1) **Регуляризация Тихонова** позволяет находиться ![w_{k+1}](https://habrastorage.org/getpro/habr/upload_files/81b/082/902/81b0829025afb8b0ff49c43e89c581db.svg) недалеко от ![w_k](https://habrastorage.org/getpro/habr/upload_files/8c8/2d4/2ad/8c82d42add1baecab74bdfd2fd7202f8.svg) и ускоряет сходимость, особенно при использовании метода сопряжённого градиента. Это обусловлено тем, что наличие регуляризации обеспечивает сильную выпуклость задачи:
    

![w_{k+1} = \text{argmin} \left\{ f(w) + \frac{1}{2\alpha_k} \| w - w_k \|^2 \right\} = prox_{\alpha_k f}(w_k)](https://habrastorage.org/getpro/habr/upload_files/e59/6e5/1a4/e596e51a4cf47be87a1365e236f8fe59.svg)

- 2) **Градиентный поток** обеспечивает сходимость в точке минимума из любой начальной точки при ![t \to \infty](https://habrastorage.org/getpro/habr/upload_files/8d4/0b9/5eb/8d40b95eb7d2722937472380124715b5.svg):
    

![\frac {d}{dt} w(t) = - \nabla f(w(t))](https://habrastorage.org/getpro/habr/upload_files/3ba/24e/eee/3ba24eeee911e45df5508537eb4130cb.svg)

Решив данное дифференциальное уравнение с помощью прямой схемы Эйлера, получим:

![w_{k+1} = w_k - \alpha \nabla f(w_k)](https://habrastorage.org/getpro/habr/upload_files/67b/dce/307/67bdce307095fabd631cffc43bb17ace.svg)

Однако такое решение менее стабильно, чем с использованием обратной схемы Эйлера. Тогда задача приобретает вид:

![\frac{w_{k+1} - w_k}{\alpha} = - \nabla f(w_{k+1})](https://habrastorage.org/getpro/habr/upload_files/26c/a81/50e/26ca8150e3403458f7eb64be38d0ffcc.svg)

Поскольку уравнение представлено в неявном виде, а его левая часть является по сути градиентом функции ![g(w^*)](https://habrastorage.org/getpro/habr/upload_files/ce1/a39/753/ce1a39753aad0dcf500043f42caa1970.svg) в точке ![w_{k+1}](https://habrastorage.org/getpro/habr/upload_files/aaa/5f8/cb3/aaa5f8cb30b0ee730f6fff13961e049c.svg), тогда для выпуклого случая:

![\nabla (f(w^*) + g(w^*))(w_{k+1}) = 0 \Rightarrow \\ \Rightarrow w_{k+1} = \text{argmin} \left\{ f(w^*) + \frac{1}{2\alpha_k} \| w^* - w_k \|^2 \right\} = prox_{\alpha_k f}(w_k)](https://habrastorage.org/getpro/habr/upload_files/b39/707/30a/b3970730a6e75ef5c79545cd288c2356.svg)

Также стоит отметить, что идея градиентного потока может быть обобщена на случаи, когда ![f](https://habrastorage.org/getpro/habr/upload_files/b1c/836/812/b1c8368121da4362c2f644ebd4f0166b.svg) не дифференцируется с помощью субградиентного дифференциального включения:

![\frac {d}{dt} w(t) \in - \partial f(w(t))](https://habrastorage.org/getpro/habr/upload_files/568/f72/bb5/568f72bb56e405e9d1f750b59d8c4bb5.svg)

- 3) **Итеративное уточнение** основано на идее асимптотически исчезающей регуляризации Тихонова и используется для решения линейных уравнений вида ![Xw = y](https://habrastorage.org/getpro/habr/upload_files/662/ba0/5c7/662ba05c713ee5e10f144554850e828e.svg) с использованием факторизации Холецкого для ![X + \frac{1}{\alpha} I](https://habrastorage.org/getpro/habr/upload_files/a3a/dcd/e03/a3adcde0347917f87482e8624b9f2a6d.svg).
    

Рассмотрим задачу минимизации квадратичной функции:

![f(w) = \frac{1}{2} w^T X w - y^T w](https://habrastorage.org/getpro/habr/upload_files/444/b24/45f/444b2445f813c15d28e2c6088ff33f6f.svg)

где ![X \in S_+^n](https://habrastorage.org/getpro/habr/upload_files/8a6/168/b4b/8a6168b4be073e4fcde148d035c3d5ee.svg) (множество симметричных положительных полуопределённых ![n](https://habrastorage.org/getpro/habr/upload_files/4eb/ef8/719/4ebef8719b05e4a9ab5bbf518f0239c5.svg) x ![n](https://habrastorage.org/getpro/habr/upload_files/7e2/6f9/e38/7e26f9e381b25f095fc61770aba51bf2.svg) матриц). Такая задача эквивалентна решению системы линейных уравнений ![Xw = y](https://habrastorage.org/getpro/habr/upload_files/805/630/c8b/805630c8b6616af9a23a18f68d15da2c.svg). Когда ![X](https://habrastorage.org/getpro/habr/upload_files/255/4b6/443/2554b644315d992a91c973cb4efaa2b2.svg) несингулярно, то единственным решением является ![w = X^{-1} y](https://habrastorage.org/getpro/habr/upload_files/efd/c1f/dac/efdc1fdacc5c96b668c3479dde851c45.svg) . Такую же проблему можно заметить в методе наименьших квадратов. Проксимальный оператор для ![f](https://habrastorage.org/getpro/habr/upload_files/56f/413/6a1/56f4136a19cc2a741c158046b8a72d0b.svg) при ![w_k](https://habrastorage.org/getpro/habr/upload_files/989/d78/ab8/989d78ab8c2f7672b226eaf71de9461d.svg) можно выразить аналитически:

![prox_{\alpha_k f}(w_k) = \text{argmin} \left\{ \frac{1}{2} w^T X w - y^T w + \frac{1}{2} \| w - w_k \|^2   \right\} = \\ = \left(X + \frac{1}{\alpha} I \right)^{-1} \left(y + \frac{1}{\alpha} w_k \right)](https://habrastorage.org/getpro/habr/upload_files/3d0/d58/1a1/3d0d581a1fb98c89c0158d2e39d57156.svg)

Переписав данное выражение, получим:

![w_{k+1} = w_k + \left(X + \frac{1}{\alpha} I \right)^{-1} (y - X w_k)](https://habrastorage.org/getpro/habr/upload_files/be7/6f5/94d/be76f594d10a9702e35fc849adf5a6c7.svg)

#### Проксимальный градиентный метод (PGM)

Применяется для решения проблемы вида ![min \rightarrow f(w) + g(w)](https://habrastorage.org/getpro/habr/upload_files/7de/93f/ecd/7de93fecd951cffbb329753891ee985e.svg), где ![f](https://habrastorage.org/getpro/habr/upload_files/b59/0a4/5a0/b590a45a05740865e07ccca227562daf.svg) является гладкой (дифференцируемой), а ![g](https://habrastorage.org/getpro/habr/upload_files/6e3/f4a/337/6e3f4a33756283505ab418d8a383a3b6.svg) негладкой функцией, для которой существует быстрый проксимальный оператор. Тогда, выполнив градиентный шаг по ![f](https://habrastorage.org/getpro/habr/upload_files/d68/6d1/ebc/d686d1ebc226404d9c6b5250e2d03e4b.svg) и проксимальный по ![g](https://habrastorage.org/getpro/habr/upload_files/2a2/64c/2dc/2a264c2dc4e350b72f01451286b08724.svg), получим итеративный процесс вида:

![w_{k+1} = prox_{\alpha_k g} (w_k - \alpha_k \nabla f(w_k))](https://habrastorage.org/getpro/habr/upload_files/e54/63d/67d/e5463d67df412553181bee41b28567dc.svg)

Ещё такой процесс называется forward-backward splitting, где forward относится к шагу градиента, а backward — к проксимальному шагу.

PGM также имеет различные интерпретации:

- 1) **Majorization-minimization** используется для решения проблемы вида:
    

![min \rightarrow q_{\alpha}(w, w_k) = \frac{1}{2} \| w - (w_k \ - \alpha_k \nabla f(w_k)) \|^2  + \alpha g(w)](https://habrastorage.org/getpro/habr/upload_files/207/442/e5e/207442e5e452d941e6169e52cffcce68.svg)

А процесс обновления ![w_{k+1}](https://habrastorage.org/getpro/habr/upload_files/8e6/4d9/55e/8e64d955eb82ac60cb4e0b71f491a06c.svg) выглядит следующим образом:

![w_{k+1} = \text{argmin} \ q_{\alpha}(w, w_k)](https://habrastorage.org/getpro/habr/upload_files/ad0/d95/859/ad0d9585928b0662e11978b72600504d.svg)

- 2) **Fixed point iteration** основано на идее, что существует фиксированная точка ![w^*](https://habrastorage.org/getpro/habr/upload_files/e42/56e/df5/e4256edf595635579825e37cade90904.svg), которая является решением ![min \rightarrow f(w) + g(w)](https://habrastorage.org/getpro/habr/upload_files/745/0cd/181/7450cd181b2ff863b112031cddb84cac.svg) лишь в том случае, когда она является точкой оператора forward-backward:
    

![(I + \alpha \partial g)^{-1} (I - \alpha \nabla f)](https://habrastorage.org/getpro/habr/upload_files/ac4/17f/a39/ac417fa39f76e6a6126ea2a8e4b5f675.svg)

Тогда решение приобретает вид:

![w^* = (I + \alpha \partial g)^{-1} (I - \alpha \nabla f) (w^*) = prox_{\alpha g} (w^* - \alpha_k \nabla f(w^*))](https://habrastorage.org/getpro/habr/upload_files/ac2/5ab/6d9/ac25ab6d96ae61ca610bfbb792e3ae2e.svg)

- 3) **Forward-backward интегрирование градиентного потока** представляет собой метод численного интегрирования дифференциального уравнения градиентного потока, в котором используется прямой Шаг Эйлера для дифференцируемой части ![f](https://habrastorage.org/getpro/habr/upload_files/ce6/0f6/e4d/ce60f6e4d70e22b5a61d5983bf8d01c0.svg) и обратный шаг Эйлера для возможно недифференцируемой части ![g](https://habrastorage.org/getpro/habr/upload_files/336/b17/89a/336b1789a85814fb76496ba416677eb7.svg). Если исходить предположения, что ![g](https://habrastorage.org/getpro/habr/upload_files/c18/755/67b/c1875567b48001db0f6be91ecff98316.svg) является также дифференцируемой, то систему градиентного потока можно представить в виде:
    

![\frac {d}{dt} w(t) = - \nabla f(w(t)) - \nabla g(w(t))](https://habrastorage.org/getpro/habr/upload_files/f26/616/a00/f26616a00a3e6a6766fbb51eea2b50db.svg)

Тогда получим процесс обновления, называемый forward-backward splitting:

![w_{k+1} = (I + \alpha \nabla g)^{-1} (I - \alpha \nabla f) w_k](https://habrastorage.org/getpro/habr/upload_files/0ea/d5a/f22/0ead5af2212074622d4bcc869fe7c082.svg)

Также стоит добавить, что существует вариант **ускоренного проксимального градиентного метода**, который включает в себя этап экстраполяции:

![z_{k+1} = w_k + p_k (w_k - w_{k-1}) \\ w_{k+1} = prox_{\alpha_k g} (z_{k+1} - \alpha_k \nabla f(z_{k+1}))](https://habrastorage.org/getpro/habr/upload_files/8f7/f6f/f69/8f7f6ff69d9c4553c127a6225a09e38e.svg)

где ![p_k](https://habrastorage.org/getpro/habr/upload_files/db7/b20/f11/db7b20f1104987abd4482d690802aba5.svg) — параметр экстраполяции, а одна из самых простых схем его расчёта выглядит следующим образом:

![p_k = \frac {k}{k + 3}](https://habrastorage.org/getpro/habr/upload_files/967/7b1/3f7/9677b13f78a745f6e2f97776bf5c8b0b.svg)

#### ISTA (Iterative Shrinkage(Soft)-Thresholding Algorithm)

Данный метод можно рассматривать как обновление проксимального градиента, применяемое к L1-регуляризованной задаче наименьших квадратов:

![\|Xw - y\|^2 + \lambda \|w\| \rightarrow min](https://habrastorage.org/getpro/habr/upload_files/cdf/5a0/623/cdf5a062381b4a23b6099128b6f0dca4.svg)

Тогда прокс-оператор для l1-нормы будет выглядеть следующим образом:

![prox_{\lambda \alpha} (w) = argmin \left\{\frac{1}{2 \alpha} \|w - w^* \|^2 + \lambda \|w^* \| \right\} = \\ = argmin \left\{\sum_{i=1}^d  \left[ \frac{1}{2 \alpha} (w_i - w_i^*) + \lambda |w_i^*| \right] \right\} = T_{\lambda \alpha} (w)](https://habrastorage.org/getpro/habr/upload_files/f57/b6b/a56/f57b6ba562476ce322e3ced847300216.svg)

где ![T_{\lambda \alpha} (w)](https://habrastorage.org/getpro/habr/upload_files/b5e/3a4/59c/b5e3a459c92e0f3f1a2151bdfc288c4d.svg) — оператор с плавным установлением порога, который для одномерной задачи является решением со следующим правилом:

![T_{\lambda \alpha} (w_i) = \begin{cases}     w_i - \lambda \alpha, \ \ w_i \geq \lambda \alpha \\     0, \ \ \ \ \ \ \ \ \ \ \ \ \  |w_i| \leq \lambda \alpha \\     w_i + \lambda \alpha, \ \ w_i \leq - \lambda \alpha  \\ \end{cases}](https://habrastorage.org/getpro/habr/upload_files/ef8/54b/935/ef854b93592c1417bf081770fc34eafe.svg)

Отсюда получим градиентный шаг обновления:

![w_{k+1} = T_{\lambda \alpha_k} (w_k - \alpha_k X^T (Xw_k- y))](https://habrastorage.org/getpro/habr/upload_files/698/1a3/b28/6981a3b28ba23c4fe80219340bbdeec9.svg)

Как можно заметить, данный метод позволяет получить разреженную модель, поскольку часть координат будет зануляться в случае ![|w_i| \leq \alpha](https://habrastorage.org/getpro/habr/upload_files/772/132/38e/77213238eb83ad1688c4a4122236430a.svg), что особенно полезно в задачах компьютерного зрения и обработки сигналов. Однако ISTA в чистом виде имеет низкую скорости сходимости, поэтому на практике используются его различные модификации. Например, **FISTA** (от слова Fast), основанное на ускорении Нестерова, где используется дополнительный шаг экстраполяции:

![t_{k+1} = \frac{1 + \sqrt{1 + 4t_k^2}}{2} \\ z_{k+1} = w_k + \frac{t_k - 1}{t_{k+1}} (w_k - w_{k-1}) \\ w_{k+1} = prox_{\lambda \alpha} (z_{k+1}) = T_{\lambda \alpha_k}(z_{k+1} - \alpha_k \nabla f(z_{k+1}))](https://habrastorage.org/getpro/habr/upload_files/55a/5a2/0cf/55a5a20cfc05c96f7cbeba66cf080342.svg)

Такой подход позволил достичь скорости сходимости ![O(1/k^2)](https://habrastorage.org/getpro/habr/upload_files/4af/581/8d2/4af5818d2301fbf3d79b3d7d23b34dca.svg) вместо ![O(1/k)](https://habrastorage.org/getpro/habr/upload_files/9e4/0e8/891/9e40e88915b3106f1d2e6d57297c9925.svg) как в ISTA. К слову, на сегодняшний день FISTA также имеет ряд модификаций, делающих его работу более стабильной и быстрой в ряде случаев.

### Методы второго порядка

Методы оптимизации второго порядка — это алгоритмы, которые используют информацию о вторых производных (гессиане) функции потерь для более быстрого и точного нахождения точек минимума с очень неровным и сложным ландшафтом потерь.

Вторая производная характеризует скорость изменения градиента функции потерь за счёт измерения её кривизны, то есть позволяет оценить ожидаемое улучшение от шага градиентного спуска. На примере квадратичной функции это будет означать следующее:

- 1) Если кривизна отрицательная (отрицательное значение второй производной), то функция потерь снижается быстрее, чем ожидалось на основе прогноза градиента. Это может привести к более быстрому достижению минимума, но также увеличивает риск его перепрыгнуть при использовании больших шагов.
    
- 2) Если кривизна нулевая (нулевое значение второй производной), то градиент точно указывает на изменение функции потерь. В этом случае, градиентный спуск будет эффективно минимизировать функцию потерь, поскольку нет ни ускорения, ни замедления в изменении её значений.
    
- 3) Если кривизна положительная (положительное значение второй производной), то функция потерь снижается медленнее, чем ожидалось на основе прогноза градиента. Это говорит о том, что при использовании слишком больших шагов можно не только замедлить процесс сходимости, но и увеличить значение функции потерь, отдаляясь от оптимального решения.
    

#### Метод Ньютона

Использует разложение в ряд Тейлора второго порядка для приближения функции ![f(w)](https://habrastorage.org/getpro/habr/upload_files/fbe/a68/350/fbea68350da479a8de4a3926b2441161.svg) в окрестностях точки ![t](https://habrastorage.org/getpro/habr/upload_files/8b0/c46/a0a/8b0c46a0adc91b343e342938c9c517e4.svg):

![f(w + t) \approx f(w) + \nabla f(w)t + \frac{1}{2} \nabla ^ 2 (w) t^2](https://habrastorage.org/getpro/habr/upload_files/d2b/8f0/04c/d2b8f004c0c318db5350b050bc9f4b84.svg)

Приравняв к нулю ![\nabla f(w + t)](https://habrastorage.org/getpro/habr/upload_files/501/d92/3e8/501d923e80a881243fb98ab7ee12d2fa.svg), получим оптимальное решение, то есть направление спуска:

![0 = \frac{d f(w + t)}{dt} = \nabla f(w) + \nabla ^ 2 f(w) \Rightarrow \\ \Rightarrow t = - \frac {\nabla f(w)}{\nabla ^ 2 f(w)} = - H^{-1}(w) \nabla f(w)](https://habrastorage.org/getpro/habr/upload_files/035/b07/b3b/035b07b3b81147c0ad1f8a6ce04df583.svg)

Тогда получим итеративный процесс обновления параметров следующего вида:

![w_{k+1} = w_k + t_k = w_k - \alpha_k H^{-1} (w_k) \nabla f (w_k)](https://habrastorage.org/getpro/habr/upload_files/477/a5a/3a5/477a5a3a57b20cc30126dc4e8d3e63ec.svg)

Если шаг ![\alpha_k = 1](https://habrastorage.org/getpro/habr/upload_files/61d/33f/8f5/61d33f8f50c04d87b338746cf0c7dfd8.svg), то это классический метод Ньютона, а при другом размере шага ![\alpha_k \in (0, 1)](https://habrastorage.org/getpro/habr/upload_files/5f9/177/9c7/5f91779c7d251dc91a08dbd6e669e28c.svg) получим дэмпированный (damped) метод Ньютона.

Такой подход обеспечивает квадратичную скорость сходимости в окрестностях оптимума за счёт более правильного оценивания кривизны линий уровня функции потерь, что делает его также устойчивым к плохо обусловленным задачам (задачам, в которых небольшое изменение в начальных данных может привести к значительным ошибкам в решении).

Однако метод Ньютона применим только в случае положительно определённой матрицы ![H](https://habrastorage.org/getpro/habr/upload_files/879/6ed/fd6/8796edfd6c7c7875a9151643d3fffd52.svg) , иначе говоря, если не все собственные значения гессиана положительны вблизи седловой точки, то обновление параметров может произойти в неверном направлении. Одно из самых простых решений данной проблемы заключается в регуляризации гессиана через прибавление константы ![\lambda](https://habrastorage.org/getpro/habr/upload_files/862/5dd/733/8625dd733f67c9117351083f723792bb.svg):

![w_{k+1} = w_k + t = w_k - \alpha_k [H^{-1} (w_k) + \lambda I] \nabla f (w_k)](https://habrastorage.org/getpro/habr/upload_files/68b/fbe/466/68bfbe466e0ec3eac1f8919da47afaca.svg)

Помимо этого, у метода Ньютона есть ещё 2 серьёзных недостатка, которые делают его неприменимым к нейронным сетям с большим количеством параметров:

- 1) Чувствительность к выбору начальной точки. Квадратичная скорость сходимости обеспечивается лишь в близи оптимума, поэтому если начальная точка расположена далеко от него, то алгоритм будет сходиться медленней и может не сойтись вообще. Отсюда следует необходимость в подборе шага ![\alpha_k](https://habrastorage.org/getpro/habr/upload_files/a99/553/67c/a9955367cb502de280f49de3ea4930cb.svg) как и в случае с градиентным спуском. Частично данную проблему можно решить также с применением различных видов регуляризацией, например, такой как кубической.
    
- 2) Высокая требовательность к вычислительным ресурсам. Поскольку число элементов гессиана равно квадрату числа параметров ![d](https://habrastorage.org/getpro/habr/upload_files/419/38b/5cb/41938b5cbe8b67f8dc1a8ad3a49de25a.svg), затраты памяти для их хранения составят ![O(d^2)](https://habrastorage.org/getpro/habr/upload_files/2d7/164/8d9/2d71648d9c1be471672cf488c626a7d2.svg), а вычислительная сложность алгоритма будет ![O(d^3)](https://habrastorage.org/getpro/habr/upload_files/cea/a55/255/ceaa552550704b77100f79fe985fe22e.svg).
    

Далее будут рассмотрены альтернативы, использующие некоторые преимущества метода Ньютона, но при этом не требующие таких больших вычислительных затрат.

#### Метод сопряжённых градиентов

В отличие от метода наискорейшего спуска, в данном методе используется спуск в сопряжённых направлениях. Это означает, что в отличие от метода наискорейшего спуска, где направление спуска всегда совпадает с антиградиентом текущей точки и может привести к зигзагообразным траекториям, в данном случае направления спуска ![d](https://habrastorage.org/getpro/habr/upload_files/df9/795/891/df97958915353c250e51997a75fa7f64.svg) выбираются таким образом, чтобы они были сопряжёнными (ортогональными) относительно гессиана функции потерь, то есть текущее направление выбирается с учётом предыдущего значения:

![d_k = \nabla f(w) + \beta_k d_{t-1}](https://habrastorage.org/getpro/habr/upload_files/6f8/9ed/4e2/6f89ed4e28f0b3b731fc8f082bba8fc1.svg)

Направления ![d_k](https://habrastorage.org/getpro/habr/upload_files/fb1/ce5/882/fb1ce5882ca3bfb1c981c2bba5e77d08.svg) и ![d_{k-1}](https://habrastorage.org/getpro/habr/upload_files/65e/7ba/b25/65e7bab25a444cf4bafb8655b900f280.svg) являются сопряжёнными, если выполняется условие ![d_k^T H d_{k-1}=0](https://habrastorage.org/getpro/habr/upload_files/e51/b40/21c/e51b4021c704680789238a7e9b6b461f.svg), а коэффициент ![\beta_k](https://habrastorage.org/getpro/habr/upload_files/617/6fb/231/6176fb231bd9b0b9be28dd76e9710a7a.svg) определяет какую часть направления ![d_{k-1}](https://habrastorage.org/getpro/habr/upload_files/198/46d/8b0/19846d8b0560c3ad72e84e6c0d6bd77a.svg) следует прибавить к текущему направлению поиска.

Найти сопряжённые направления можно, просто получив собственные вектора ![H](https://habrastorage.org/getpro/habr/upload_files/ac2/9f2/702/ac29f270219adabcf3b731dbc0d6de2e.svg) для ![\beta_k](https://habrastorage.org/getpro/habr/upload_files/71f/a65/bc9/71fa65bc94bb5aea0965bf8f3fc754ae.svg), однако это вычислительно неэффективно, поэтому для расчёта ![\beta_k](https://habrastorage.org/getpro/habr/upload_files/1b7/a49/d3d/1b7a49d3d3f114e943684c1a4cb0fd2b.svg) обычно используются следующие методы:

- 1) Метод Флетчера-Ривса:
    

![\beta_k = \frac{\nabla f(w_k)^T \nabla f(w_k)}{\nabla f(w_{k-1})^T \nabla f(w_{k-1})}](https://habrastorage.org/getpro/habr/upload_files/59d/ea6/fef/59dea6fef97e9e5b948f38baead3d6c6.svg)

- 2) Метод Полака-Рибьера:
    

![\beta_k = \frac{(\nabla f(w_k) - \nabla f(w_{k-1}))^T \nabla f(w_k)}{\nabla f(w_{k-1})^T \nabla f(w_{k-1})}](https://habrastorage.org/getpro/habr/upload_files/659/8ca/8bc/6598ca8bc05f67e09db5ca2c31ec64b6.svg)

Отсюда следует, что для квадратичной поверхности сопряжённость направлений гарантирует поиск минимума не более чем за ![d](https://habrastorage.org/getpro/habr/upload_files/63a/ecd/d10/63aecdd101de3e8a2320e48ca88ae0b0.svg) поисков в ![d](https://habrastorage.org/getpro/habr/upload_files/90e/497/7c9/90e4977c909f5e34d8976b9c39518542.svg)-мерном пространстве. Если же функция потерь выходит за рамки простой квадратичной формы и становится более сложной, то не всегда возможно обеспечить сохранение минимума вдоль ранее определённых сопряжённых направлений. Поэтому в нелинейном случае сопряжённых градиентов периодически выполняется процедура рестарта, когда алгоритм заново начинает поиск вдоль направления неизменённого градиента, что в итоге позволяет лучше адаптироваться к изменениям в ландшафте функции потерь и более эффективно находить точки минимума.

#### BFGS (Broyden–Fletcher–Goldfarb–Shanno)

Является одним из самых известных квазиньютоновских методов и основан на аппроксимации обратного гессиана матрицей ![M](https://habrastorage.org/getpro/habr/upload_files/ef8/c2f/8d5/ef8c2f8d5e288581a2afc7cc29f12bb4.svg), которая итеративно уточняется в ходе обновлений низкого ранга. Обозначив приближение гессиана симметричной положительно определённой матрицей ![B_k](https://habrastorage.org/getpro/habr/upload_files/2a7/256/5fc/2a72565fc7ce2317a99cda56a5cd30b6.svg) размера ![d \ \text{x} \ d](https://habrastorage.org/getpro/habr/upload_files/27a/2a2/b32/27a2a2b320c661aa82d902d57a401848.svg), получим функцию потерь аналогичную в методе Ньютона:

![m(w_{k+1}) \approx f(w_{k+1}) + \nabla f(w_{k+1})t + \frac{1}{2} \nabla ^ 2 (w_{k+1}) t^2](https://habrastorage.org/getpro/habr/upload_files/6e2/70c/29b/6e270c29bf4355ab2ef596942e354453.svg)

Основываясь на информации из последнего шага, ![B_{k+1}](https://habrastorage.org/getpro/habr/upload_files/d7d/e53/4dc/d7de534dc3249e7eb5d6d425bc990aac.svg) должен удовлетворять условию, при котором градиент ![m(w_{k+1})](https://habrastorage.org/getpro/habr/upload_files/d0a/680/1ce/d0a6801ce691d6cc00aecf7639e6ccf2.svg) соответствует градиенту ![f](https://habrastorage.org/getpro/habr/upload_files/d8b/0ce/e93/d8b0cee93f67bac77ea91bd1d13fab3a.svg) на двух последних итерациях ![w_k](https://habrastorage.org/getpro/habr/upload_files/626/580/6fe/6265806fe098be6ba5334080129108d2.svg) и ![w_{k+1}](https://habrastorage.org/getpro/habr/upload_files/1ce/208/4f1/1ce2084f110418059cfa1813be08ad73.svg):

![\nabla m(w_k - w_{k+1}) = \nabla m(- \alpha_k d_k) = \nabla f(w_{k+1}) - B_{k+1} \alpha_k  d_k = \nabla f(w_k)](https://habrastorage.org/getpro/habr/upload_files/04a/d9e/fa1/04ad9efa1129f56a7fc6c89e0891632a.svg)

Отсюда получаем уравнение секущей, которое ещё известно как квазиньютоновское условие:

![B_{k+1} \alpha_k  d_k = \nabla f(w_{k+1}) - \nabla f(w_k)](https://habrastorage.org/getpro/habr/upload_files/03e/7be/d08/03e7bed08eb46063abb219f6f1d81773.svg)

Перепишем данное уравнение в более удобной форме, сделав несколько упрощений:

![B_{k+1} s_k = y_k \\ s_k = (w_{k+1} - w_k) = \alpha_k d_k \\ y_k = \nabla f(w_{k+1}) - \nabla f(w_k)](https://habrastorage.org/getpro/habr/upload_files/cd6/9eb/9f7/cd69eb9f7c43ad70704b59bb3b7c820d.svg)

Согласно данному уравнению, матрица ![B_{k+1}](https://habrastorage.org/getpro/habr/upload_files/61a/f7e/703/61af7e703525c249f2a2b89a66d2462c.svg) может преобразовать ![s_k](https://habrastorage.org/getpro/habr/upload_files/d6e/e2f/2d4/d6ee2f2d4ff17fd630fada97b6c6d80d.svg) в ![y_k](https://habrastorage.org/getpro/habr/upload_files/539/c1c/fdb/539c1cfdbc8f51b0eca151ce7f83ed55.svg) только в случае, если они будут удовлетворять условию кривизны:

![s_k^T y_k > 0](https://habrastorage.org/getpro/habr/upload_files/d80/144/c4f/d80144c4f9e5d979cac1c24b5cbc29a9.svg)

Когда выполняется данное условие, уравнение секущей всегда имеет решение, а для однозначного определения ![B_{k+1}](https://habrastorage.org/getpro/habr/upload_files/483/2ff/162/4832ff162f58649c0d17e76d982e8dc4.svg) вводится дополнительное условие, что среди всех симметричных матриц, удовлетворяющих уравнению секущей, ![B_{k+1}](https://habrastorage.org/getpro/habr/upload_files/76e/455/191/76e45519137ba1d07887c49249de8b7c.svg) будет расположено наиболее близко к текущей матрице ![B_k](https://habrastorage.org/getpro/habr/upload_files/653/b66/451/653b66451b80e457ea62b078b43f0797.svg). Другими словами, мы получим задачу вида:

![min \rightarrow \|B - B_k \|](https://habrastorage.org/getpro/habr/upload_files/0a1/22a/889/0a122a8890c4a5ca23581e252f6e1099.svg)

Которую можно решить достаточно просто с использованием взвешенной нормы Фробениуса:

![\|A \|_W = \|W^{1/2} A W^{1/2} \|_F](https://habrastorage.org/getpro/habr/upload_files/f37/28f/d44/f3728fd440528fd8ad1d0dd118340436.svg)

Где ![\|\cdot \|_F](https://habrastorage.org/getpro/habr/upload_files/c9e/5e1/08c/c9e5e108c037933aef5c2c39287c5a51.svg) определяется через ![\|C \|^2_F = \sum_{i=1}^n \sum_{j=1}^n c^2_{ij}](https://habrastorage.org/getpro/habr/upload_files/776/842/c8f/776842c8fc45a80932602c2c80ecd34d.svg), а матрица весов ![W](https://habrastorage.org/getpro/habr/upload_files/f92/69b/058/f9269b058da5834e5d4f01594ceba5b0.svg) может быть выбрана в качестве любой при выполнении условия ![W y_k = s_k](https://habrastorage.org/getpro/habr/upload_files/6d3/5b9/3fb/6d35b93fb87e177d0073edbd7498af5e.svg). Определим ![W](https://habrastorage.org/getpro/habr/upload_files/b84/301/9b9/b843019b98f533d3d66197f989467e78.svg) как обратный усреднённый гессиан ![\overline G_k^{-1}](https://habrastorage.org/getpro/habr/upload_files/a5d/f75/682/a5df75682adaae498a6175d2a3214611.svg), где:

![\overline G_k = \int_{0}^{1} \nabla^2 f(w_k + \alpha_k d_k) d \lambda](https://habrastorage.org/getpro/habr/upload_files/d57/225/b69/d57225b692e2b277d9b206ec7a8b5ee1.svg)

С помощью теоремы Тейлора можно показать, что:

![y_k = \overline G_k \alpha_k d_k = \overline G_k s_k](https://habrastorage.org/getpro/habr/upload_files/d07/c45/aad/d07c45aad0f35069bfde995c86f6f78f.svg)

При таком выборе матрицы ![W](https://habrastorage.org/getpro/habr/upload_files/838/f00/0b1/838f000b1c5ca959f61cfbb4e1033580.svg) взвешенная норма Фробениуса является безразмерной, что является желательным свойством, поскольку позволяет избежать зависимости от единиц измерения при решении задачи минимизации. Тогда получим решение, которое называется методом **DFP (Davidon-Fletcher-Powell)**:

![B_{k+1} = (I - \frac{y_k s_k^T}{y_k^T s_k}) B_k (I - \frac{s_k y_k^T}{y_k^T s_k}) + \frac{y_k y_k^T}{y_k^T s_k}](https://habrastorage.org/getpro/habr/upload_files/6cf/7b4/087/6cf7b40876086ccac411a41f221182f4.svg)

Поскольку в квазиньютоновских методах нас больше интересует обратный гессиан, перепишем данную формулу в более удобном виде. Для этого определим ![M=B_k^{-1}](https://habrastorage.org/getpro/habr/upload_files/1c3/175/5c9/1c31755c913f18f06ca1b4613d4a4ea9.svg) и воспользуемся обобщением формулы Шермана–Моррисона–Вудбери:

![B^{-1} = A^{-1} - A^{-1} U (I + V^T A^{-1} U) V^T A^{-1}](https://habrastorage.org/getpro/habr/upload_files/cf3/fd3/c04/cf3fd3c0466416edb1448ab66434eb51.svg)

В таком случае решение DFP приобретает следующий вид:

![M_{k+1} = M_k - \frac{M_k y_k y_k^T M_k}{y_k^T M_k y_k} + \frac{s_k s_k^T}{y_k^T s_k}](https://habrastorage.org/getpro/habr/upload_files/af4/089/602/af40896025c2373b0d3c9630b69eef59.svg)

В этом и заключается фундаментальная идея квазиньютоновского обновления: вместо того, чтобы пересчитывать приближённые гессианы (или обратные гессианы) с нуля на каждой итерации, мы применяем простую модификацию, которая объединяет самую последнюю наблюдаемую информацию о  функции потерь с информацией из текущего приближения гессиана.

Однако формулу обновления из алгоритма DFP можно сделать ещё более эффективной, проделав аналогичные процедуры с ![M_k](https://habrastorage.org/getpro/habr/upload_files/136/257/5ee/1362575ee5e83a3a553032482cd152f8.svg) вместо ![B_k](https://habrastorage.org/getpro/habr/upload_files/af2/0d6/2cc/af20d62cc7e10a54352f1d114fa376c7.svg). В итоге получим обновление **BFGS**:

![M_{k+1} = (I - \frac{s_k y_k^T}{y_k^T s_k}) M_k (I - \frac{y_k s_k^T}{y_k^T s_k}) + \frac{s_k s_k^T}{y_k^T s_k}](https://habrastorage.org/getpro/habr/upload_files/ace/a56/4dd/acea564dd3c3be16a9f5b17bd26fcf3a.svg)

Мы также можем вывести версию алгоритма BFGS, которая работает с аппроксимацией гессиана ![B_k](https://habrastorage.org/getpro/habr/upload_files/d14/bce/24c/d14bce24c4667b5b7d008bc6a9a180d5.svg), а не ![M_k](https://habrastorage.org/getpro/habr/upload_files/5a7/904/7bf/5a79047bf3c983308eac91ef90d27232.svg), если снова воспользуемся обобщением формулы Шермана–Моррисона–Вудбери:

![B_{k+1} = B_k - \frac{B_k s_k s_k^T B_k}{s_k^T B_k s_k} + \frac{y_k y_k^T}{y_k^T s_k}](https://habrastorage.org/getpro/habr/upload_files/c43/88d/e64/c4388de649ad8deaf91981652749ece3.svg)

Тогда направление спуска будет выглядеть следующим образом:

![d_k = - M_k \nabla f(w_k)](https://habrastorage.org/getpro/habr/upload_files/b81/a8f/6ec/b81a8f6ecab6c4e5bdb49ddcfbfb314a.svg)

А параметры будут обновляться по следующему правилу:

![w_{k+1} = w_k + \alpha_k d_k](https://habrastorage.org/getpro/habr/upload_files/bc7/92d/549/bc792d549ae35a2c5bef05be027e47e8.svg)

Подобно методу сопряжённых градиентов, в алгоритме BFGS создаётся серия линейных поисков на основе информации о кривизне функции, однако важное отличие заключается в том, что в данном случае достижение точки, максимально приближённой к истинному минимуму вдоль заданного направления, не так критично. Это делает данный алгоритм более эффективным, поскольку не требуется тратить дополнительное время на уточнение результатов каждого линейного поиска, однако для хранения матрицы ![M](https://habrastorage.org/getpro/habr/upload_files/468/ca0/6f5/468ca06f50077e8f2c2a1de3d72b46be.svg) требуется ![O(d^2)](https://habrastorage.org/getpro/habr/upload_files/09e/791/1b6/09e7911b6b61234360c0b86123b3e0a3.svg) памяти из-за чего данный алгоритм также малопригоден для моделей с большим количеством параметров.

#### SR1 (Symmetric Rank-1)

Представляет собой более простое обновление ранга 1, которое сохраняет симметрию матрицы и удовлетворяет уравнению секущей, но при этом исчезают гарантии, что обновлённая матрица ![B_k](https://habrastorage.org/getpro/habr/upload_files/ccc/ca7/4b1/cccca74b1c23d155c66f2ad698720c02.svg) (или ![M_k](https://habrastorage.org/getpro/habr/upload_files/b3e/045/71c/b3e04571c8ec7505c8d43eb4c48a9104.svg)) будет положительно определённой. Тем не менее, данный метод может быть полезен, когда стандартные предположения BFGS не выполняются или когда необходимо использовать методы определения доверительной области.

Симметричное обновление ранга 1, которое также известно как формула Бройдена, имеет общий вид:

![B_{k+1} = B_k + \sigma v v^T](https://habrastorage.org/getpro/habr/upload_files/ddd/c23/bdc/dddc23bdcb950628be10184e108050e6.svg)

Где ![\sigma \in \{-1, 1 \}](https://habrastorage.org/getpro/habr/upload_files/7e7/421/e28/7e7421e2812871645be211a07592663c.svg), а также выбирается вместе с ![B_{k+1}](https://habrastorage.org/getpro/habr/upload_files/a90/998/19a/a9099819ab7ad658c38f57abd54a6583.svg) таким образом, чтобы удовлетворять уравнению секущей. Подставляя обновление выше в данное уравнение, получим:

![y_k = B_k s_k + [\sigma v v^T] s_k](https://habrastorage.org/getpro/habr/upload_files/410/d00/a90/410d00a90074321937fa456731ef418e.svg)

Поскольку член в скобках является скалярным, ![v](https://habrastorage.org/getpro/habr/upload_files/a5f/df1/b46/a5fdf1b46fb783b8a8a06eab3a45a921.svg) должно быть кратно ![y_k - B_k s_k](https://habrastorage.org/getpro/habr/upload_files/0b4/f30/824/0b4f30824bd6c7334adca642e61a3a81.svg) для некоторого скалярного значения ![\delta](https://habrastorage.org/getpro/habr/upload_files/d5a/bac/91a/d5abac91a3fc3bd4dac1f7bd4cd21caf.svg):

![y_k - B_k s_k = \sigma \delta^2 [s_k^T (y_k - B_k s_k)] (y_k - B_k s_k)](https://habrastorage.org/getpro/habr/upload_files/565/af5/3c8/565af53c82e4ed708e797ee4d866e10e.svg)

Данное уравнение выполняется только в том случае, когда:

![\sigma = sign [s_k^T (y_k - B_k s_k)] \\ \delta = \pm |s_k^T (y_k - B_k s_k)|^{-1/2}](https://habrastorage.org/getpro/habr/upload_files/357/f73/d0c/357f73d0ce59f21b16b44edfd48ce35d.svg)

Следовательно, формула обновления для ![B_k](https://habrastorage.org/getpro/habr/upload_files/e41/bc4/d98/e41bc4d98564eb7cfeac03d1b1d5f58a.svg) приобретает следующий вид:

![B_{k+1} = B_k + \frac{(y_k - B_k s_k) (y_k - B_k s_k)^T}{(y_k - B_k s_k)^T s_k}](https://habrastorage.org/getpro/habr/upload_files/a95/c5e/a9d/a95c5ea9d7fa3d13161ac34024264bc0.svg)

Применив обобщение формулы Шермана–Моррисона–Вудбери, получим соответствующее обновление для обратной аппроксимации гессиана ![M_k](https://habrastorage.org/getpro/habr/upload_files/37f/5fa/ee1/37f5faee12ea156261bdce5b96a94912.svg):

![M_{k+1} = M_k + \frac{(s_k - M_k y_k) (s_k - M_k y_k)^T}{(s_k - M_k y_k)^T y_k}](https://habrastorage.org/getpro/habr/upload_files/3d9/ecb/595/3d9ecb5952696345eaddae603c6d9a61.svg)

Не смотря на менее стабильную работу в сравнении с DFP и BFGS, преимущество SR1 заключается в создании неопределённых аппроксимаций гессиана, что позволяет получить больше информации о локальной кривизне функции потерь и лучше исследовать пространство для поиска направлений, которые могут привести к лучшему решению.

#### L-BFGS (Limited-memory BFGS)

Данная модификация использует только последние ![m](https://habrastorage.org/getpro/habr/upload_files/e5f/936/9c3/e5f9369c3fc2e9b9c432265a43dbdf70.svg) (обычно от 3 до 20) пар векторов ![\{s_i, y_i \}](https://habrastorage.org/getpro/habr/upload_files/889/cc8/666/889cc86661fdf0a7c0dd8d7ed996c8d1.svg) и начальное приближение ![M_0](https://habrastorage.org/getpro/habr/upload_files/369/59e/42f/36959e42f50a8f2a95985d99890806f1.svg) для аппроксимации ![M_k](https://habrastorage.org/getpro/habr/upload_files/09c/117/8af/09c1178af773a3caf6c41bb4800e42b4.svg), что позволяет иметь линейные затраты ![O(md)](https://habrastorage.org/getpro/habr/upload_files/4b0/b6a/86a/4b0b6a86aa5dac296c9b69d3846bedc3.svg) не только на память, но и на итерацию. Чтобы лучше разобраться как это происходит, сначала перепишем формулы обновления BFGS в упрощённом виде:

![w_{k+1} = w_k + \alpha_k M_k \nabla f (w_k) \\ M_{k+1} = V_k^T M_k V_k + \rho_k s_k s_k^T \\ V_k = I - \rho_k y_k s_k^T, \ \rho_k = \frac{1}{y_k^T s_k}](https://habrastorage.org/getpro/habr/upload_files/71e/3c2/35b/71e3c235bb0a69f59bc0e222c2bf39db.svg)

Тогда приближение ![M_k](https://habrastorage.org/getpro/habr/upload_files/464/a7b/749/464a7b749f080249980712dc80f0dbcc.svg) можно представить в следующем виде:

![\begin{align} M_k &= (V_{k-1}^{T} ... V_{k-m}^{T}) M_0 (V_{k-m} ... V_{k-1}) + \\ &+ \rho_{k-m} (V_{k-1}^T ... V_{k-m+1}^{T}) s_{k-m} s_{k-m}^T (V_{k-m+1} ... V_{k-1}) + \\ &+ \ ... \\ &+ \rho_{k-1} s_{k-1} s_{k-1}^T \end{align}](https://habrastorage.org/getpro/habr/upload_files/88d/524/7b2/88d5247b21a7e33aff250e3561c5f64d.svg)

Из этого выражения можно вывести рекурсивный алгоритм для эффективного вычисления произведения ![M_k \nabla f(w_k)](https://habrastorage.org/getpro/habr/upload_files/46e/17c/a0f/46e17ca0fcee2cc88c94f6d2c621574a.svg), который называется **L-BFGS two-loop recursion**:

![\begin{align*} & q \leftarrow \nabla f(w_k) \\ & \textbf{for } i \ = \ k - 1, \ k - 2, ..., \ k - m \\ & \hspace{1.3cm} \alpha_i \leftarrow \rho_i s_i^T q \\ & \hspace{1.3cm} q \leftarrow q - \alpha_i y_i \\ \\ & r \leftarrow M_0 q \\ & \textbf{for } i \ = \ k - m, \ k - m + 1, ..., \ k - 1 \\ & \hspace{1.3cm} \beta \leftarrow \rho_i y_i^T r \\ & \hspace{1.3cm} r \leftarrow r + s_i (\alpha_i - \beta) \\ \\ & M_k \nabla f(w_k) = r \end{align*}](https://habrastorage.org/getpro/habr/upload_files/af1/bba/6c3/af1bba6c36c1d2a05d0bae0e2e336249.svg)

Преимущество данной рекурсии заключается в том, что умножение на исходную матрицу ![M_0](https://habrastorage.org/getpro/habr/upload_files/e1d/5f8/456/e1d5f845614bb794d2ad32f3ec406e12.svg) изолировано от остальных вычислений, что позволяет свободно выбирать эту матрицу и изменять её между итерациями. Методом выбора ![M_0](https://habrastorage.org/getpro/habr/upload_files/9d4/71f/13a/9d471f13a5281fb8e67543adb27e273b.svg), показавшим себя хорошо на практике, является установка ![M_0 = \gamma_k I](https://habrastorage.org/getpro/habr/upload_files/022/606/b4a/022606b4a1c1b0d419e8e26bea35f731.svg), где:

![\gamma_k = \frac{s_{k-1}^T y_{k-1}}{y_{k-1}^T y_{k-1}}](https://habrastorage.org/getpro/habr/upload_files/b1e/676/08b/b1e67608b8b2282745ea7317d181cf6b.svg)

В данном случае ![\gamma_k](https://habrastorage.org/getpro/habr/upload_files/28d/ccc/514/28dccc5143886a97dea30ca4555fe9c9.svg) позволяет произвести оценку размера истинного гессиана по последнему направлению поиска. Это гарантирует хорошую масштабируемость направления поиска ![d_k](https://habrastorage.org/getpro/habr/upload_files/61a/44f/431/61a44f431e70a3cf53e70e7881111218.svg), в результате чего на большинстве итераций ![\alpha_k = 1](https://habrastorage.org/getpro/habr/upload_files/487/55d/bab/48755dbabdd64bc6f0e3b270e41b0fd9.svg). Теперь можно сделать формальное определение алгоритма **L-BFGS** следующим образом:

![\begin{align*} & \text{Choose starting point } w_0 \\ & m > 0, \ k \leftarrow 0 \\ & \textbf{repeat until convergence} \\ & \hspace{1.3cm} M_0 = \gamma_k I \\ & \hspace{1.3cm} d_k = - M_k \nabla f(w_k) \hspace{0.4cm} \text{from algorithm above} \\ \\ & \hspace{1.3cm} w_{k+1} = w_k + \alpha_k d_k, \hspace{0.3cm} \text{where} \ \alpha_k \ \text{satisfies the Wolfe's conditions} \\ & \hspace{1.3cm} r \leftarrow r + s_i (\alpha_i - \beta) \\ & \hspace{1.3cm} \textbf{if } k > m: \\ & \hspace{2.6cm} \text{Discard the vector pair } \{s_{k-m}, y_{k-m} \} \ \text{from storage} \\ & \hspace{1.3cm} s_k \leftarrow w_{k+1} - w_k \\ & \hspace{1.3cm} y_k = \nabla f(w_{k+1}) - \nabla f(w_k) \\ & \hspace{1.3cm} k \leftarrow k + 1 \end{align*}](https://habrastorage.org/getpro/habr/upload_files/d41/712/e78/d41712e7846b37e10a21f15b60050ba9.svg)

#### Shampoo

Вышеописанные методы всё ещё уступают в скорости и потреблении памяти обычным градиентным методам, особенно при обучении больших глубоких нейросетей. Отчасти это связано с тем, что они требуют точного, а не стохастического вычисления градиентов. В идеале нам хотелось бы иметь такой алгоритм, который совмещает в себе точность алгоритмов второго порядка и скорость алгоритмов первого порядка. В попытке приблизиться к этой цели появился алгоритм Shampoo, который применяется для стохастической оптимизации не только в матричных, но и в тензорных пространствах. Рассмотрим его основную идею.

Начнём с того, что данный алгоритм относится к так называемым предобусловленным методам (в контексте машинного обучения предобуславливание можно рассматривать как процесс изменения условий задачи таким образом, чтобы алгоритмы могли работать с ней более точно и эффективно). Вместо использования обратного гессиана явным образом в Shampoo используется произведение градиентов для формирования предобусловленной матрицы, которая выполняет роль, схожую с гессианом, храня информацию о кривизне поверхности функции потерь. По сути, данный алгоритм представляет собой многомерный аналог AdaGrad, а для матричного случая его принцип работы выглядит следующим образом:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/02b/408/f1c/02b408f1ce89cc1fa1f382e0992adbed.png)

На каждой итерации из матриц ![L_t](https://habrastorage.org/getpro/habr/upload_files/85b/0ec/3ba/85b0ec3ba01ac541fbe69b879bb2dafb.svg) размера ![m](https://habrastorage.org/getpro/habr/upload_files/0ea/a6f/3b1/0eaa6f3b12257ce34162d5e3d2523ff5.svg) x ![m](https://habrastorage.org/getpro/habr/upload_files/078/f5a/194/078f5a194d898be7166752f79eb8e930.svg) и ![R_t](https://habrastorage.org/getpro/habr/upload_files/0bb/7fb/28d/0bb7fb28d13b8d753dcefaf4a9959be3.svg) размера ![n](https://habrastorage.org/getpro/habr/upload_files/0f3/aef/1b9/0f3aef1b974984f4fc7600d4a3706472.svg) x ![n](https://habrastorage.org/getpro/habr/upload_files/44f/819/eb9/44f819eb961329dcffb151d6e4852739.svg) , содержащих информацию о втором моменте из накопленных градиентов, формируются две предобусловленные матрицы, которые потом умножаются на градиентную матрицу слева направо соответственно. Каждая из предобусловленных матриц работает только с одним измерением градиента, сокращаясь по остальным, что позволяет неплохо ускорить процесс обучения. Объём пространства, который Shampoo использует в данном случае, составляет ![O(m^2 + n^2)](https://habrastorage.org/getpro/habr/upload_files/a4f/942/784/a4f9427844ffddff4c9526cb10f2685a.svg) вместо ![O(m^2 n^2)](https://habrastorage.org/getpro/habr/upload_files/1c4/d5c/31f/1c4d5c31f318dd750067d7e5b846e00e.svg) в сравнении с полноматричными методами. Более того, поскольку предобуславливание включает в себя обращение матрицы (и чаще всего спектральное разложение), объём вычислений для построения левого и правого предобуславливателей также сокращается с ![O(m^3 n^3)](https://habrastorage.org/getpro/habr/upload_files/bd9/5cf/5db/bd95cf5dba0be797a8b1c5d3630bd7dd.svg) до ![O(m^3 + n^3)](https://habrastorage.org/getpro/habr/upload_files/5be/62c/fff/5be62cfff9de9f6e60a82f93c264fb9f.svg).

Однако shampoo всё ещё требует больших вычислительных затрат, что особенно выделяется при работе с полносвязными и эмбэддинг слоями. Основная сложность возникает при вычислении p-х корней матриц ![L_t^{-1/4}](https://habrastorage.org/getpro/habr/upload_files/eec/237/675/eec2376752a3d2b939f649de41191d87.svg) и ![R_t^{-1/4}](https://habrastorage.org/getpro/habr/upload_files/ebf/4e0/6e9/ebf4e06e9be44818e5dc77ccf761e53f.svg), которые были реализованы с использованием спектрального разложения (например, SVD), что может занимать много времени. Поэтому для ускоренной работы Shampoo было разработано несколько улучшений:

- 1) Вычисление предобуславливателей раз в несколько сотен шагов. Поскольку в большинстве случаев структура функции потерь не изменяется существенно с каждым шагом, то и особого эффекта на снижение точности произойти не должно.
    
- 2) Использование эффективных итерационных методов для вычисления p-х корней вместо SVD, например, применение модификаций на основе метода Шура-Ньютона.
    
- 3) Использование одного из предобуславливателей ![L_t^{-1/2p}](https://habrastorage.org/getpro/habr/upload_files/1af/e9c/434/1afe9c43459d9e7fdfc3ec04222f7933.svg) или ![R_t^{-1/2q}](https://habrastorage.org/getpro/habr/upload_files/c9b/d5c/021/c9bd5c021eca4c360a8ec8214aaeb000.svg), где ![p, q > 0](https://habrastorage.org/getpro/habr/upload_files/818/44a/583/81844a5833eb3975210e295fe93ad0e9.svg).
    
- 4) Применение параллельного обучения на GPU.
    

Стоит отметить, что данные улучшения без проблем можно использовать для Shampoo в его общей форме, который применим к тензорам произвольной размерности. В фреймворках глубокого обучения реализована именно тензорная форма данного алгоритма, а его принцип работы выглядит следующим образом:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6d9/9c3/969/6d99c3969b9476565b752d0db86ace5a.png)

Проследив историю развития методов второго порядка, становится очевидно, что с появлением таких алгоритмов как Shampoo, их применение становится всё более привлекательным с практической точки зрения. На мой скромный взгляд, в будущем их популярность будет расти и они будут играть значимую роль не только в глубоком обучении, но и в других областях инженерии и науки.

### Дополнительные источники

Статьи:

- «Adam: A Method for Stochastic Optimization», Diederik P. Kingma, Jimmy Ba;
    
- «Decoupled Weight Decay Regularization», Ilya Loshchilov, Frank Hutter;
    
- «Incorporating Nesterov Momentum into Adam», Timothy Dozat;
    
- «Adaptive Methods for Nonconvex Optimization», Manzil Zaheer, Sashank J. Reddi, Devendra Sachan, Satyen Kale, Sanjiv Kumar;
    
- «Adan: Adaptive Nesterov Momentum Algorithm for Faster Optimizing Deep Models», Xingyu Xie, Pan Zhou, Huan Li, Zhouchen Lin, Shuicheng Yan;
    
- «On the Convergence of Adam and Beyond», Sashank J. Reddi, Satyen Kale, Sanjiv Kumar;
    
- «On the Convergence Proof of AMSGrad and a New Version», Tran Thi Phuong, Le Trieu Phong;
    
- «SGDR: Stochastic Gradient Descent with Warm Restarts», Ilya Loshchilov, Frank Hutter;
    
- «Optimization for deep learning: theory and algorithms», Ruoyu Sun;
    
- «Large Batch Training of Convolutional Networks», Yang You, Igor Gitman, Boris Ginsburg;
    
- «Large Batch Optimization for Deep Learning: Training BERT in 76 minutes», Yang You, Jing Li, Sashank Reddi, Jonathan Hseu, Sanjiv Kumar, Srinadh Bhojanapalli, Xiaodan Song, James Demmel, Kurt Keutzer, Cho-Jui Hsieh;
    
- «Proximal Algorithms», Neal Parikh, Stephen Boyd;
    
- «A Fast Iterative Shrinkage-Thresholding Algorithm», for Linear Inverse Problems, Amir Beck, and Marc Teboulle;
    
- «Improving Fast Iterative Shrinkage-Thresholding Algorithm: Faster, Smarter and Greedier», Jingwei Liang, Tao Luo, Carola-Bibiane Schönlieb;
    
- «Resurrecting the sigmoid in deep learning through dynamical isometry: theory and practice», Jeffrey Pennington, Samuel S. Schoenholz, Surya Ganguli;
    
- «Numerical Optimization», Jorge Nocedal, Stephen J. Wright;
    
- «A regularized limited-memory BFGS method for unconstrained minimization problems», Shinji SUGIMOTO and Nobuo YAMASHITA;
    
- «Shampoo: Preconditioned Stochastic Tensor Optimization», Vineet Gupta, Tomer Koren, Yoram Singer;
    
- «Scalable Second Order Optimization for Deep Learning», Rohan Anil, Vineet Gupta, Tomer Koren, Kevin Regan, Yoram Singer;
    
- «A Schur-Newton method for the matrix p'th root and its inverse», C.-H. Guo and N. J. Higham.
    

Видео:

- [пакетный градиентный спуск](https://www.youtube.com/watch?v=sDv4f4s2SB8);
    
- [стохастический и мини-пакетный градиентные спуски](https://www.youtube.com/watch?v=vMh0zPT0tLI);
    
- [оптимизации градиентного спуска](https://www.youtube.com/playlist?list=PLRznHSqUb86uuNA4eT96lk9_Y_CTwJlkK).
    

---

[**Обзор и реализация популярных ML-алгоритмов 🡆**](https://habr.com/ru/articles/804605/)