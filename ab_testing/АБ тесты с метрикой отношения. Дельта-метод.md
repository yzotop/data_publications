---
tags:
  - data
link: https://habr.com/ru/companies/X5Tech/articles/740476/
data_type:
  - AB tests
source: habr
author: Nazarov
---



Привет, Хабр! В этой статье разберём, что такое метрики отношения. Узнаем, почему критерий Стьюдента не работает. Попробуем применить бутстреп к зависимым данным. Изучим дельта-метод — способ оценки А/Б тестов с метрикой отношения.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ce7/477/58b/ce747758b607cb5024e2a4364bf815c4.png)

Меня зовут [Коля](http://www.linkedin.com/in/nazarovn), я работаю аналитиком данных в X5 Tech. Мы с [Сашей](http://www.linkedin.com/in/amsakhnov) продолжаем писать серию статей по А/Б тестированию, это наша четвёртая статья. Первые три можно посмотреть тут:

- [Стратификация. Как разбиение выборки повышает чувствительность А/Б теста](https://habr.com/ru/company/X5Tech/blog/596279/);    
- [Бутстреп и А/Б тестирование](https://habr.com/ru/company/X5Tech/blog/679842/);    
- [Проверка корректности А/Б тестов](https://habr.com/ru/company/X5Tech/blog/706388/).
    

### Метрики отношения

Для проведения А/Б эксперимента мы выделяем две группы объектов: контрольную и экспериментальную. К объектам экспериментальной группы применяем тестируемое изменение, а объекты контрольной группы оставляем без изменений. 

Объект — это то, на что направлено действие. Объектами могут быть покупатели магазина, пользователи социальной сети или клубни картофеля.

С одного объекта в течение эксперимента можно получить много значений. Покупатель сделает несколько покупок. Пользователь социальной сети просмотрит десятки реклам. Из одного клубня картофеля вырастут другие клубни.

Мы сталкиваемся с метриками отношения, когда хотим анализировать данные эксперимента на более детальном уровне, чем уровень объектов, по которым проводилось разбиение на группы. Примеры метрик отношения:

1. Средний чек. Для вычисления среднего чека нужно взять все стоимости покупок группы и вычислить среднее. Если в группе два пользователя, первый сделал покупку на 500 рублей, а второй сделал две покупки на 400 и 300 рублей, то средний чек равен 400 рублей.
    
2. CTR (click-through rate) — это соотношение кликов по рекламе к числу её показов. Если в группе два пользователя, первый кликнул на 1 рекламу из 7 показанных, а второй кликнул на 2 рекламы из 3 показанных, то CTR равен 0.3.
    
3. Средний вес клубня. Если в группе 2 клубня, из первого выросло три клубня весом 4, 5 и 6 килограмм, а из второго выросло два клубня весом по 10 килограмм, то средний вес клубня равен 7 килограммам.
    

Формально метрики отношения можно представить формулой, как отношения двух сумм:

![\mathcal{R} = \dfrac{X_1 + \ldots + X_N}{Y_1 + \ldots + Y_N}](https://habrastorage.org/getpro/habr/upload_files/115/c0e/8ca/115c0e8ca5fb0ab136ff43fb3b3ff6ec.svg)

где N — размер группы, ![X_i](https://habrastorage.org/getpro/habr/upload_files/6c3/009/a18/6c3009a181010b63290e68b44d1d095c.svg) и ![Y_i](https://habrastorage.org/getpro/habr/upload_files/d1a/f17/94d/d1af1794dd4ffa24756b2282e285e9d3.svg) — метрики i-го объекта. Например, для среднего чека ![X_i](https://habrastorage.org/getpro/habr/upload_files/5b1/772/982/5b1772982af26f09affc3555b9202725.svg) — суммарная стоимость покупок i-го покупателя, ![Y_i](https://habrastorage.org/getpro/habr/upload_files/c4a/ff3/024/c4aff3024220188fc8e969109fab4576.svg) — количество покупок i-го покупателя.

Значения от одного объекта обычно являются зависимыми. Если пользователь онлайн-магазина всегда делает большие заказы, то следующий его заказ, скорее всего, тоже будет большим.

Значения от разных объектов обычно являются независимыми, или их зависимость настолько мала, что ей можно пренебречь. Информация о заказах одного пользователя не помогает нам понять, какие заказы у другого пользователя.

### Тест Стьюдента не работает

Допустим, нам нужно проверить значимость отличия среднего чека у двух групп. Средний чек — это среднее от стоимостей чеков. Получается, нужно проверить гипотезу о равенстве средних. Для этой гипотезы подходит тест Стьюдента.

Однако, выше мы писали, что данные от одного объекта могут быть зависимыми, а тест Стьюдента предполагает независимость данных. Давайте проверим, будет ли критерий работать корректно. Подробнее про проверку корректности можно прочитать в статье [Проверка корректности А/Б тестов](https://habr.com/ru/company/X5Tech/blog/706388/).

Будем генерировать данные для двух групп покупателей размером по 1000 человек. Каждый покупатель совершает от 1 до 4 покупок. Значения среднего чека у покупателей отличаются. Применим тест Стьюдента к сгенерированным данным и запомним значение p-value. Повторим эту процедуру 1000 раз и построим эмпирическую функцию распределения p-value. Для корректного критерия распределение p-value должно быть близко к равномерному распределению от 0 до 1.

```
import numpy as npimport matplotlib.pyplot as pltfrom scipy import statsdef plot_pvalue_distribution(dict_pvalues):    """Рисует графики распределения p-value."""    X = np.linspace(0, 1, 1000)    for name, pvalues in dict_pvalues.items():        Y = [np.mean(pvalues < x) for x in X]        plt.plot(X, Y, label=name)    plt.plot([0, 1], [0, 1], '--k', alpha=0.8)    plt.title('Оценка распределения p-value', size=16)    plt.xlabel('p-value', size=12)    plt.legend(fontsize=12)    plt.grid()    plt.show()def generate_data(sample_size, effect):    """Генерирует данные со стоимостью покупок.    Возвращает два списка с данными контрольной и экспериментальной групп.    Элементы списков - множества со стоимостями покупок пользователей.     """    result = []    for group_effect in [0, effect]:        n_purchases = np.random.randint(1, 5, sample_size)        mean_costs = np.random.uniform(1000, 2000, sample_size)        data = [            np.random.normal(mean + group_effect, 200, n)            for n, mean in zip(n_purchases, mean_costs)        ]        result.append(data)    return resultalpha = 0.05              # допустимая вероятность ошибки I родаsample_size = 1000        # размер группpvalues = []for _ in range(1000):    a, b = generate_data(sample_size, 0)    a_values = np.hstack(a)    b_values = np.hstack(b)    pvalue = stats.ttest_ind(a_values, b_values).pvalue    pvalues.append(pvalue)error_rate = np.mean(np.array(pvalues) < alpha)print(f'Доля ошибок первого рода: {error_rate:0.2f}')plot_pvalue_distribution({'A/A': pvalues})
```

```
Доля ошибок первого рода: 0.20
```

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/93d/b24/c53/93db24c534071bdd474bfa6d98ae4a58.png)

Распределение p-value получилось неравномерным. Доля ошибок первого рода 0.2, это значительно больше ожидаемых 0.05. При проверке гипотезы о равенстве метрик отношения тест Стьюдента работает некорректно.

### Среднее средних

Тест Стьюдента в прошлом примере работал некорректно из-за зависимых данных. Покупки одного клиента зависимы, а покупки разных клиентов независимы. Давайте избавимся от зависимых данных, объединив покупки по клиентам. Для каждого клиента посчитаем его средний чек и по этим данным проверим гипотезу о равенстве средних.

Проверим, будет ли тест Стьюдента корректно работать на таких данных.

```
pvalues = []for _ in range(1000):    a, b = generate_data(sample_size, 0)    a_means = [np.mean(x) for x in a]    b_means = [np.mean(x) for x in b]    pvalue = stats.ttest_ind(a_means, b_means).pvalue    pvalues.append(pvalue)plot_pvalue_distribution({'A/A': pvalues})
```

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/142/c5d/e32/142c5de32dd8208c157b085db2f1abd6.png)

Распределение p-value получилось равномерным. Тест Стьюдента работает корректно.

Мы перешли от проверки гипотезы о равенстве метрик отношения к проверке гипотезы о равенстве среднего средних. Можно ли результаты, полученные при проверке одной гипотезы, обобщать на другую гипотезу?

Рассмотрим пример. Есть две группы по два покупателя в каждой. В первой группе один покупатель сделал две покупки по 2000 рублей, а другой совершил одну покупку на 1000 рублей. Во второй группе один покупатель сделал две покупки по 1000 рублей, а другой совершил одну покупку на 2700 рублей.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/980/6ae/946/9806ae946d78abfda893cb110c78dd69.png)

Вычислим разность метрик отношения между группами:

(1000 + 1000 + 2700) / 3 - (2000 + 2000 + 1000) / 3 = -100

Вычислим разность среднего средних между группами:

(1000 + 2700) / 2 - (2000 + 1000) / 2 = 350

В нашем примере средний чек больше в первой группе, а среднее средних больше во второй группе. Легко придумать обратный пример, когда обе метрики будут больше в одной группе. Получается, между метрикой отношения и средним средних нет однозначной связи. Использовать среднее средних для проверки гипотезы о равенстве метрик отношения нельзя.

### Бутстреп

Проверить гипотезу о равенстве метрик отношения можно с помощью бутстрепа, который мы разбирали в одной из прошлых статей [Бутстреп и А/Б тестирование](https://habr.com/ru/company/X5Tech/blog/679842/).

Основная особенность применение бутстрепа для метрик отношения — данные необходимо семплировать по объектам, а не по наблюдениям. Если объект оказался в определённой группе, то и все его действия будут в этой группе.

Не будем долго останавливаться на бутстрепе, так как мы его уже разбирали. Перейдём сразу к примеру его применения.

```
def get_percentile_ci(bootstrap_stats, alpha):    """Строит перцентильный доверительный интервал."""    left, right = np.quantile(bootstrap_stats, [alpha / 2, 1 - alpha / 2])    return left, rightdef check_bootsrtap(a, b, n_iter, alpha):    """Оценивает значимость отличий с помощью бутстрепа.    Если отличия значимые, то возвращает 1, иначе 0.    """    # вычисляем стоимость и количество покупок клиентов    xy_a = np.array([[sum(values), len(values)] for values in a])    xy_b = np.array([[sum(values), len(values)] for values in b])    # генерируем случайные индексы для выбора подмножеств данных    len_a = len(a)    len_b = len(b)    indexes_a = np.random.choice(        np.arange(len_a), size=(n_iter, len_a), replace=True    )    indexes_b = np.random.choice(        np.arange(len_b), size=(n_iter, len_b), replace=True    )    bootstrap_stats = []    for idx_a, idx_b in zip(indexes_a, indexes_b):        bootstrap_xy_a = xy_a[idx_a]        bootstrap_xy_b = xy_b[idx_b]        # считаем разницу метрик отношения        bootstrap_stat = (            bootstrap_xy_b[:, 0].sum() / bootstrap_xy_b[:, 1].sum()            - bootstrap_xy_a[:, 0].sum() / bootstrap_xy_a[:, 1].sum()        )        bootstrap_stats.append(bootstrap_stat)    # строим доверительный интервал и оцениваем значимость отличий    ci = get_percentile_ci(bootstrap_stats, alpha)    has_effect = 1 - (ci[0] < 0 < ci[1])    return has_effectalpha = 0.05               # допустимая вероятность ошибки I родаsample_size = 1000         # размер группn_iter = 1000              # количество итераций бутстрепаeffects = []for _ in range(1000):    a, b = generate_data(sample_size, 0)    has_effect = check_bootsrtap(a, b, n_iter, alpha)    effects.append(has_effect)error_rate = np.mean(np.array(effects) == 1)print(f'Доля ошибок первого рода: {error_rate:0.3f}')
```

```
Доля ошибок первого рода: 0.053
```

Приведённая реализация бутстрепа не вычисляет p-value, поэтому построить распределение мы не сможем. Доля ошибок первого рода находится в районе заданного уровня значимости. Можно изменять значение уровня значимости и проверить, что бутстреп работает корректно при всех ![\alpha \in [0, 1]](https://habrastorage.org/getpro/habr/upload_files/302/72a/3e4/30272a3e4724d77fb9e6ddcc0a5bd832.svg).

Мы нашли способ, который корректно проверяет гипотезу о равенстве метрик отношения. Однако, этот способ имеет существенный недостаток. Бутстреп является вычислительно трудоёмким подходом. Если вам нужно оценивать эксперименты с большими объёмами данных, то применение бутстрепа может занимать часы или даже дни.

### Дельта-метод

Ранее мы говорили, что тест Стьюдента не работает для метрик отношения из-за зависимых данных. Если копнуть глубже, то окажется, что тест Стьюдента не работает из-за неправильной оценки дисперсии. Для оценки дисперсии зависимых данных недостаточно просто вычислить выборочную дисперсию.

Существует формула для оценки дисперсии отношения двух случайных величин:

![\mathbb{V}\left(\dfrac{X}{Y}\right) \approx \dfrac{1}{\mu_y^2} \mathbb{V}(X) - 2 \dfrac{\mu_x}{\mu_y^3} cov(X, Y) + \dfrac{\mu_x^2}{\mu_y^4} \mathbb{V}(Y)](https://habrastorage.org/getpro/habr/upload_files/38b/56b/c96/38b56bc9667f7bb208e4c5b602a3c462.svg)

где X и Y — случайные величины, а ![\mu_x](https://habrastorage.org/getpro/habr/upload_files/c89/a76/56f/c89a7656fa4b0bcc5345805feaa338db.svg) и ![\mu_y](https://habrastorage.org/getpro/habr/upload_files/0b4/0f2/2e3/0b40f22e3cb165e63d6a47d4ab1d43c9.svg) — их математические ожидания.

Воспользуемся этой формулой для оценки дисперсии метрики отношения:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/164/709/8b8/1647098b8e9ffb14c5c250cb0c376d89.png)

Теперь мы можем использовать новые оценки дисперсий для вычисления статистики теста Стьюдента:

![t = \frac{\mathcal{R}_B - \mathcal{R}_A}{\sqrt{\mathbb{V}(\mathcal{R}_A) + \mathbb{V}(\mathcal{R}_B)}} \xrightarrow{N\to\inf} \mathcal{N}(0, 1)](https://habrastorage.org/getpro/habr/upload_files/a05/378/c91/a05378c91eee426dbde1453c438a0c21.svg)

Реализуем алгоритм проверки гипотез, используя новые оценки дисперсии. Проверим корректность работы на наших данных.

```
def check_delta_method(a, b):    """Проверка гипотезы с помощью дельта-метода.    Возвращает p-value.    """    dict_ = {}    for data, group_name in [(a, 'a',), (b, 'b',)]:        n_user = len(data)        array_x = np.array([np.sum(row) for row in data])        array_y = np.array([len(row) for row in data])        mean_x, mean_y = np.mean(array_x), np.mean(array_y)        var_x, var_y = np.var(array_x), np.var(array_y)        cov_xy = np.cov(array_x, array_y)[0, 1]        # точечная оценка метрики        pe_metric = np.sum(array_x) / np.sum(array_y)        # оценка дисперсии метрики        var_metric = (            var_x / mean_y ** 2            - 2 * (mean_x / mean_y ** 3) * cov_xy            + (mean_x ** 2 / mean_y ** 4) * var_y        ) / n_user        dict_[f'pe_metric_{group_name}'] = pe_metric        dict_[f'var_metric_{group_name}'] = var_metric    var = dict_['var_metric_a'] + dict_['var_metric_b']    delta = dict_['pe_metric_b'] - dict_['pe_metric_a']    t = delta / np.sqrt(var)    pvalue = (1 - stats.norm.cdf(np.abs(t))) * 2    return pvaluealpha = 0.05           # допустимая вероятность ошибки I родаsample_size = 1000     # размер группeffect = 50            # размер эффектаpvalues_aa = []pvalues_ab = []for _ in range(1000):    a, b = generate_data(sample_size, 0)    pvalues_aa.append(check_delta_method(a, b))    a, b = generate_data(sample_size, effect)    pvalues_ab.append(check_delta_method(a, b))plot_pvalue_distribution({'A/A': pvalues_aa, 'A/B': pvalues_ab})
```

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e06/961/aff/e06961aff39835e6a4d1f4afd4dad360.png)

В этот раз мы провели и А/А и А/Б эксперименты. Дельта-метод контролирует вероятность ошибки первого рода на уровне значимости, когда эффекта нет, и находит эффект, когда он есть. Критерий работает корректно.

### Итоги

Мы разобрались, что такое метрики отношения и как их оценивать в экспериментах.

Вспомним подходы, которые рассмотрели:

- **Критерий Стьюдента**, применённый в лоб к исходным данным, работает некорректно, так как данные зависимы.
    
- Если заменить метрику отношения на **среднее средних**, то проблема зависимых данных исчезнет, но новая метрика может быть не сонаправлена с исходной. Если увеличилась одна, то другая могла как увеличиться, так и уменьшиться.
    
- Оценить значимость изменения метрики отношения можно с помощью **бутстрепа**. Основной недостаток — требует много вычислительных ресурсов.
    
- **Дельта-метод** — способ оценки А/Б тестов с метрикой отношения, который основан на вычислении дисперсии зависимых данных.