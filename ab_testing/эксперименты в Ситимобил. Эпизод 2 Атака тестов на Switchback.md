---
tags:
  - data
data_type:
  - AB tests
source: habr
link: https://habr.com/ru/companies/citymobil/articles/575218/
---
[[Switchback-эксперименты в Ситимобил. Эпизод 1 Скрытая сила switchback]]

## Введение

Всем привет! На линию выходит команда динамического ценообразования Маркетплейса Ситимобил.

В [прошлый раз](https://habr.com/ru/company/citymobil/blog/560426/) мы начали вести длинный рассказ о том, как правильно проводить эксперименты в многосторонних маркетплейсах. Мы рассуждали о смысле происходящего; о предпосылках, почему вообще стоит задуматься над этой темой, и почему эксперименты не классическими рандомизированными подходами едины.

Сегодня мы расскажем о практических шагах и ответим на главные, волнующие всех экспериментаторов вопросы: **какими статистическими методами можно проверить switchback-тест и как выбрать подходящий.**

## Воспоминания

Прежде чем погружаться в теорию и более специфичные выкладки, давайте кратко вспомним основные термины и идеи. Они будут активно использоваться далее. А если вы встретили эту статью первой и вспоминать пока особо нечего, но очень хочется разобраться, то можно нырнуть в увлекательный мир Switchback прямо вот [тут](https://habr.com/ru/company/citymobil/blog/560426/).

В многосторонних маркетплейсах в эксперименты может вторгаться **_сетевой (социальный) эффект_.**

> **Сетевой эффект** — это ситуация в экспериментах, когда поведение одного участника изменяет поведение другого.

Сетевой эффект нарушает предпосылки, на которых базируется «верность» рандомизированного эксперимента — **_Stable Unit Treatment Value Assumption (SUTVA)_.**

> **SUTVA** — условие валидности А/В-теста, которое гласит, что измененные условия воздействуют только на группу, к которой они были применены, и не воздействуют на пользователей из других групп.

Чтобы дальше проводить со спокойной душой корректные эксперименты, необходимо избавиться от сетевого эффекта или хотя бы снизить его. Один из эффективных способов сделать это — **_Switchback_**.

> **Switchback** — это способ разделения участников на пилотные и контрольные группы по временным промежуткам и географическим зонам.

И последнее, что мы будем использовать для простоты, это обозначение **_Unit_**.

> **Unit** — единица разбиения на группы в Switchback-эксперименте, которая включает в себя геозону и некоторый промежуток времени.

Кажется всё, пора переходить к основной части, в которой нам нужно будет запастись терпением и любовью к математике.

## Что по тестам, ребят?

На примере одной из важных метрик для нашего маркетплейса мы хотим сравнить несколько статистических тестов, использующих **разную агрегацию данных**, а также **разные интересные математические идеи** и выбрать победителя. Мы надеемся, что после этого "пути" каждый желающий сможет переиспользовать эти идеи для собственных экспериментов и даже усовершенствовать их.​

### Ride-level и unit-level

Отдельный важный вопрос заключается в том, **как мы агрегируем наши данные**, полученные в эксперименте.

Первый и самый простой способ: смотреть на данные «как прометились» — не важно, в каком unit'е было наблюдение (клиентская сессия), важно, что оно оказалось в группе А или В. Такой уровень агрегации мы назовём **_ride-level_**.

Второй способ — это агрегировать данные до unit'ов. Его мы назовём **_unit-level_**.

Я всё ещё не понял(а), что такое unit, объясните, пожалуйста.

[](https://habr.com/ru/company/citymobil/blog/560426/)

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/69c/ce9/352/69cce935270597067918ca5732450a91.png)

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/dd9/247/e8d/dd9247e8db74d98ffefd3ff981ced2a6.png)

Оба подхода, конечно, «грешны», и важно понимать, чем.

В **ride-level** мы не учитываем, что один и тот же клиент (тут может быть и пассажир, и водитель) может оказаться и в группе А, и в группе В, поэтому **выборки независимыми не будут**. Но зато при таком подходе у нас **много наблюдений**, а это хорошо для получения статистически значимых результатов.

В **unit-level** же ситуация как-будто зеркальная. Используя такую агрегацию мы резко **сокращаем количество доступных нам наблюдений**. Например, в некотором unite'е совершилось ![N](https://habrastorage.org/getpro/habr/upload_files/ca5/977/3a7/ca59773a767632ac18ee5603c5c48eb8.svg) поездок, но посчитаем мы его как одно наблюдение. Это напрямую будет влиять на мощность наших тестов. Вторая проблема — это **не полностью равнозначные между собой unit'ы**. Так, наши изменения будут по-разному влиять на unit'ы, полученные ночью, когда мало наблюдений, и днем, когда наблюдений в unit'ах много. Это, в целом, может затруднять понимание эксперимента и формулирование выводов, так как результаты могут получиться противоречивые.

Чтобы нивелировать эти проблемные моменты, мы улучшим подход unit-level всякими интересными фишками, которые обсудим ниже в разделе [**«Проверка экспериментов»**](https://habr.com/ru/companies/citymobil/articles/575218/#4check).

### Как будем сравнивать

Ну и ещё небольшая остановка перед самым интересным.

#### Применимость тестов

Обычно под описанием статистического теста приведена инструкция по применению мелким шрифтом, в которой очень часто есть фраза «данные должны быть нормальными», хотя ещё чаще этот фрагмент никто не читает​. И казалось бы, в чём проблема, можно рассуждать так: «Ну будут у меня немного не такие данные, будет тест менее мощный, ну подержу эксперимент подольше, может, эффект найдётся, ничего плохого же не случилось». Но, к сожалению, это работает не так. И несоблюдение требований к данным может нарушать одно важное условие, на которое мы незаметно для себя опираемся, применяя тесты — **FPR контролируется пороговым значением p-value**. Если это условие вдруг нарушается, то мы не можем глядя на p-value, который выдал нам тест, делать выводы об FPR. Классно и подробно написано об этой взаимосвязи, например, ещё вот [тут](https://vkteam.medium.com/practitioners-guide-to-statistical-tests-ed2d580ef04f#1e3b).

**Куда же смотреть, чтобы понять, что у нас всё хорошо и какие графики построить, чтобы быть спокойными**? Ответом на вопрос будут графики с распределением p-value, которые получены, например, на некотором наборе сгенерированных А/А-тестов (как можно сгенерировать себе данные, мы расскажем ниже). Если распределение p-value равномерное, то у нас всё хорошо, и можно дальше спокойно применять наши тесты, если это не так, то **FPR НЕ контролируется p-value.**

В целом хорошая картинка должна выглядеть примерно так:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/991/a3f/095/991a3f095ec76f7d29ff00b963b6a4c5.png)

#### Сравнение тестов между собой

Нам необходимо понять, по каким критериям мы скажем, что один статистический тест, который мы будем применять, лучше другого. В нашем случае мы не сильно отошли от классики и будем смотреть на **_false positive rate (FPR)_** и **_sensitivity (true positive rate)_**.

Здесь мы предполагаем, что вы в принципе знакомы с классической терминологией, связанной с проверкой гипотез, но если нет, то можно пойти [сюда](https://www.ozon.ru/product/2017-statistika-i-kotiki-143299729/) или [сюда](https://vkteam.medium.com/practitioners-guide-to-statistical-tests-ed2d580ef04f).

Если кратко, то результаты применения статистического теста можно описать следующей таблицей.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/4a7/3b6/15f/4a73b615ff90de2ba96bfae60495b587.png)

> **FPR** — это вероятность сказать, что эффект был, когда на самом деле его не было (чем меньше, тем лучше).

> **Sensitivity (1 − False Negative)** — это вероятность того, что мы почувствуем/различим эффект, если он правда есть (чем больше, тем лучше).

На практике **эти два понятия взаимообратны**. Мы можем получить нулевой FPR, просто всегда говоря, что эффекта нет, при этом будем иметь нулевую Sensitivity. И наоборот, всегда говоря, что эффект есть, мы получим 100 % Sensitivity и FPR в 100%. Зависимость FPR от Sensitivity выглядит следующим образом:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5d1/afd/2c0/5d1afd2c0858110982343a878e1c6c6f.png)

Чем больше кривая «вжата» в левый верхний угол, тем мы счастливее.

> Наша задача — найти тест, который даст для наших данных лучшую пару FPR-Sensitivity.

Для знакомых с машинным обучением это выглядит совсем как кривая ROC-AUC, а если переписать табличку в таком виде (как будто решаем задачу бинарной классификации), то аналогия совсем очевидна.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f8f/7b8/515/f8f7b85157158a37145d632848b1f30d.png)

Тогда наши метрики перепишутся в совсем знакомом виде:

![FPR = \frac{FP}{FP + TN}](https://habrastorage.org/getpro/habr/upload_files/8e8/820/c69/8e8820c69ac06be8f6f8bb0b00c5a98e.svg)![Sensitivity (TPR)= 1- FNR = 1 - \frac{FN}{FN+TP} = \frac{TP}{FN + TP}](https://habrastorage.org/getpro/habr/upload_files/453/0bc/c0a/4530bcc0a7c3f5d54838914d4b7e5724.svg)

На практике мы будем симулировать много экспериментов для проверки одного статистического теста (об этом ниже), и наши FPR и Sensitivity перепишутся в представленном ниже виде. Для FPR в случае А/А-теста (аналогично для Sensitivity в случае А/В−теста):

![\text{FPR} = { {1\over{N_{sim}}} {\sum^{N{sim}}_{n=1}}I\{P_{(n)}\leq \alpha\} } ,](https://habrastorage.org/getpro/habr/upload_files/237/ebc/12b/237ebc12ba3f702ad0c6da88432d5322.svg)

где![P_n](https://habrastorage.org/getpro/habr/upload_files/dcf/e16/466/dcfe16466621aa4f87777cdfed13827a.svg)— p-value в эксперименте с номером![n](https://habrastorage.org/getpro/habr/upload_files/600/446/59f/60044659fb539500ec0a96387070676f.svg), ![\alpha](https://habrastorage.org/getpro/habr/upload_files/6e4/1b2/082/6e41b2082ba8cca1920c051fb194bdb0.svg)— уровень значимости.

### Что будем сравнивать

И наконец, нам необходимо немного поговорить о метриках. Работу маркетплейса такси упрощенно можно представить следующей цепочкой действий:

> Клиентская сессия → заказ → назначение водителя → поездка

Одной из метрик качества сервиса является отношение назначенных водителей к заказам. Будем называть эту метрику **_назначаемостью_**, или ![O2DA](https://habrastorage.org/getpro/habr/upload_files/d7b/866/f3a/d7b866f3a9e3ed6c79cb92b5e0505b71.svg), что означает Orders to Drivers Assigned (да, название и расчёт перевернуты, но такова сила традиций).

В реальных экспериментах влияние эксперимента не стоит оценивать только по изменению ![O2DA](https://habrastorage.org/getpro/habr/upload_files/45e/702/030/45e70203044500b481f3d5e4cb66025c.svg), так как легко можно привести пример, когда назначаемость растёт, а количество совершаемых поездок при этом сильно уменьшается. Но сейчас будем работать только с ней.

### Тесты для сравнения

После выбора метрики посмотрим на статистические тесты, с помощью которых можно проверить, отличаются ли метрики в тестовой и контрольной группах. Будем рассматривать следующие варианты:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/9e4/846/087/9e48460876501448e0e57ad67f581173.png)

На **z-test для пропорций** и **t-test** мы останавливаться не будем, потому что по этой теме уже много публикаций, например, можно почитать вот [эту](https://habr.com/ru/post/556852/). А вот о **Multi Level Modelling (MLM)** информации мало (особенно в применении к А/В−тестированию), поэтому его стоит обсудить! Такой подход был навеян нам [статьей](https://doordash.engineering/2019/02/20/experiment-rigor-for-switchback-experiment-analysis/) компании DoorDash, которая уже сталкивалась с оценкой эффектов в экспериментах Switchback.

**MLM** позволяет строить модели на данных, которые могут быть кластеризованы по тому или иному признаку. Вероятно, здесь нужно на пару минут остановиться и осознать эту фразу, но на самом деле за ней скрывается очень простая идея. Часто мы работаем с данными, имеющими вложенную структуру, например, мы сравниваем пользователей, которые могут жить в разных городах или иметь разное образование. Эти особенности пользователей (даже скорее групп пользователей, объединённых по какому−то признаку) оказывают эффект на нашу целевую метрику. Поэтому если мы сможем их учесть, то это позволит снизить волатильность целевой метрики и потенциально повысит мощность нашего теста. Другая важная мысль заключается в том, что метрики внутри групп, как правило, более выражено коррелируют друг с другом. А это значит, что нарушается стандартное предположение, которое используется в статистических тестах, о том, что данные, с которыми мы работаем, независимы между собой. Этого тоже хотелось бы избежать.

На практике информацию о вложенности на примере пользователей из разных городов можно записать следующим образом:

![y_i = \alpha_{j[i]} + \beta \cdot x_i + \varepsilon_i, \text{ user } i = 1,\dots, n \\ \alpha_{j} = a + b\cdot u_j + \eta_j, \text{ city } j = 1,\dots, k](https://habrastorage.org/getpro/habr/upload_files/9f9/4cc/0c6/9f94cc0c64710e53fe55fe33677353ee.svg)

Первое — это регрессия на пользователей, второе — на города. Учитывать и записать вложенность можно не только так, другие способы можно найти [тут](http://www.stat.columbia.edu/~gelman/arm/). Конечно, для учёта вложенной структуры данных можно было бы использовать и классические дамми-переменные соответствующих кластеров, однако здесь возникают свои сложности, например, кластеры могут быть несбалансированы (у нас именно такие) по объёму наблюдений. Из-за чего может случиться неоправданный overfit.

Как мы записали MLM для себя? В нашем случае верхний уровень — это заказы, а второй уровень — это unit'ы по гео и времени, которые мы обговорили ранее. То есть MLM нам необходимо было применить для переменной ![is\_driver\_assigned](https://habrastorage.org/getpro/habr/upload_files/4da/a6b/46f/4daa6b46f10703c9312b5b7d81436468.svg), которая для каждого конкретного заказа принимает значение 0 либо 1. Поэтому мы обучали логистическую регрессию следующего вида:

![is\_driver\_assigned= c + b*is\_test+effect_{geo}+effect_{time}+\varepsilon,](https://habrastorage.org/getpro/habr/upload_files/3f3/334/130/3f3334130265f3eb44d38868165e79bc.svg)

где переменная ![is\_test](https://habrastorage.org/getpro/habr/upload_files/f20/562/678/f20562678c08724c0c6cdaa49df2a8f8.svg) — это индикатор, применяется ли для данного наблюдения тестовая модель или нет.

При этом

![effect_{geo}\sim \mathcal{N}(0, \tau_{geo}) \\ effect_{time}\sim \mathcal{N}(0, \tau_{time})](https://habrastorage.org/getpro/habr/upload_files/9ce/190/62d/9ce19062daddbbe04fb8ea2daaa78eff.svg)

Таким образом, можно переписать наше уравнение:

![is\_driver\_assigned=(c+effect_{geo}+effect_{time})+b*is\_test+\varepsilon \\ is\_driver\_assigned=c_{time+geo}+b*is\_test+\varepsilon  \\ \text{ где } c_{time+geo}\sim\mathcal{N}(c, \sigma^2_{geo}+\sigma^2_{time})](https://habrastorage.org/getpro/habr/upload_files/c34/e46/57d/c34e4657dc570f5b227bd9d1e34abe53.svg)

Такая регрессия учитывает информацию о unit'е и позволяет ответить на вопрос, значим ли коэффициент перед переменной ![is\_test](https://habrastorage.org/getpro/habr/upload_files/ee9/355/e03/ee9355e03861e829a787c4ae5cfe837b.svg), и если да, то такой эффект можно ожидать для каждого unit'а.

## Проверка экспериментов

### Генерирование данных

Для проверки гипотез мы взяли данные на уровне клиентских сессий за несколько недель в одном из наших городов, где в это время не проводилось каких-то существенных изменений, влияющих на нашу метрику. На этих данных будем генерировать множество синтетических тестов, где каждое наблюдение относится к одной из групп ![A_1](https://habrastorage.org/getpro/habr/upload_files/574/cdb/85a/574cdb85aa52dedadb528cc9949c506b.svg), ![A_2](https://habrastorage.org/getpro/habr/upload_files/f0a/c04/30c/f0ac0430c23980762a67d798005b1047.svg) или ![B](https://habrastorage.org/getpro/habr/upload_files/551/450/afa/551450afa246025685dbcdcbb72cd7a2.svg)(да-да, у нас будет две группы ![A](https://habrastorage.org/getpro/habr/upload_files/695/903/0bc/6959030bcca1d0d8b3a6e9f825ec19af.svg), об этом упоминалось в [первом эпизоде](https://habr.com/ru/company/citymobil/blog/560426/)). Разные тесты будем получать с помощью рандомизации unit'ов, как описано в нашей первой статье.

Как и договаривались выше, успех статистических тестов будем оценивать по FRP и Sensitivity. Для проверки FPR будем использовать исходные данные, как они есть. Для того же, чтобы проверить Sensitivity, будем симулировать константный эффект в группе ![B](https://habrastorage.org/getpro/habr/upload_files/92a/c7c/437/92ac7c437c205ad61fc07e6fc11ac99f.svg)следующим образом:

- Вычисляем ![O2DA_0](https://habrastorage.org/getpro/habr/upload_files/61d/7f8/7a6/61d7f87a69c09d29d0bef7fdad9d8fd7.svg)— назначаемость в исходных данных.
    
- Для каждого заказа будем генерировать флаг Driver Assigned из распределения Бернулли, при этом для группы ![A](https://habrastorage.org/getpro/habr/upload_files/1ba/7f5/e0a/1ba7f5e0aa364176a4d362d43cfd1016.svg)параметр распределения ![p=O2DA_0](https://habrastorage.org/getpro/habr/upload_files/6cd/435/330/6cd43533037bcb1d50dd19472ee84973.svg), а для группы ![B](https://habrastorage.org/getpro/habr/upload_files/67f/2d8/143/67f2d81436a9f43e3d053b1eae6b1880.svg): ![p=O2DA_0*(1+lift)](https://habrastorage.org/getpro/habr/upload_files/1d0/6c3/6c1/1d06c36c18edcbb5c8e5fd09abbe1a6b.svg).
    

### Классический подход

Сначала убеждаемся, что **наши статистические тесты применимы** (нет).

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e27/441/1d9/e274411d93f96e858ca6784676157546.png)

Видно, что z-test для пропорций не подходит для ride-level агрегации, как мы и говорили выше, в разделе о слабых местах. Отлично, убедились в этом дальше всё равно покажем его на графиках, но применять в эксплуатации, конечно же, не будем.

С **MLM** чуть получше, но всё равно не прекрасно, а вот **unit-level + t-test** вполне себе неплох и наши графики выглядят как идеальные.

Посмотрим, что на А/В-тесте. Тут мы фиксировали некоторый uplift, который хотели бы находить нашими тестами.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/70f/d55/3a1/70fd553a14636517314f2c670a1f7762.png)

Ситуация, конечно, патовая. Получаем, что у t-test'а, который мы можем применять, очень низкая мощность, а z-test и MLM применять мы не можем по описанным выше доводам. Срочно нужно повышать мощность t-test'a.

### Улучшенная версия: линеаризация + дельта-метод

Идея рассматриваемых далее методов будет основываться на предпосылке:

> Если бы у нас был способ снизить дисперсию метрик, которые мы наблюдаем, то это позволило бы нашему тесту стать мощнее — повысить **Sensitivity**.

Мы возьмём самые быстро работающие и хорошо зарекомендовавшие себя методы — **дельта-метод** и **линеаризацию**.

#### Линеаризация

Лучше всего в этот метод, конечно, погрузиться через [статью](https://research.yandex.com/publications/148), в которой он был впервые описан. Для нашей метрики пошагово это работает так:

- Считаем assigned drivers и orders для каждого unit'а в разрезе пилот/контроль.
    
- Строим на контрольной выборке регрессию, из которой получаем коэффициент ![k](https://habrastorage.org/getpro/habr/upload_files/dcf/ba0/ca3/dcfba0ca3c9b35f9cd41902087ed68e9.svg) :
    
    ![\text{assigned drivers} = k \cdot \text{orders}](https://habrastorage.org/getpro/habr/upload_files/043/44b/111/04344b11194852f261018b5d48a6405c.svg)
    
    Кстати говоря, вместо регрессии можно просто взять ![global\ ratio](https://habrastorage.org/getpro/habr/upload_files/236/300/5c6/2363005c6c7b626e9659c2c7939e6636.svg)по контролю.
    
- Получаем новую метрику для каждого unit'а:
    
    ![\text{assigned drivers}_{\text{linearized}} = \text{assigned drivers} - k\cdot \text{orders}](https://habrastorage.org/getpro/habr/upload_files/6f4/313/72d/6f431372d611f9d6d64a8d77392ed915.svg)
- Считаем для полученной метрики t-test.
    
- Профит, вы и ваш тест прекрасны!
    

#### Дельта-метод

Сам по себе дельта-метод — это классический статистический подход, а теорема про дельта-метод известна многим (а если вдруг неизвестна, то можно посмотреть вот это [видео](https://www.coursera.org/lecture/mathematical-statistics-and-ab-testing/diel-ta-mietod-kRKeh)). Но как применять его в А/В-тестировании, не очевидно. Статью Microsoft на эту тему можно почитать [тут](https://arxiv.org/pdf/1803.06336.pdf). А мы на пальцах объясним суть.

У нас есть замечательная **центральная предельная теорема ЦПТ**, благодаря которой мы можем получить доверительный интервал (confident interval (CI)) для среднего, если у нас есть некоторый набор независимых, одинаково распределённых случайных величин ![X_1, X_2, \dots, X_n](https://habrastorage.org/getpro/habr/upload_files/487/7d5/837/4877d58372a4ff49e2cd26965cfcbc2d.svg):

![\frac{\sqrt{n}(\overline{X}-\mu)}{\sigma} \to N(0,1) \\ CI (\mu) = \overline{X} \pm z_{\alpha/2}\frac{\sigma}{\sqrt{n}}, \\ \text{где } z_{\alpha/2} \text{ }\alpha/2\text{-квантиль для }N(0,1)](https://habrastorage.org/getpro/habr/upload_files/3e2/c83/141/3e2c83141d28f1b72848100c5cda4172.svg)

Это очень классно, если наша метрика, например, представляет собой среднее время подачи машины или какую-либо другую несоставную метрику. Но что делать с композитными метриками, такими как наша **назначаемость**? Ведь даже простая выборочная оценка среднего имеет некоторое [смещение](https://en.wikipedia.org/wiki/Ratio_estimator) относительно истинного среднего (хоть и стремящееся к 0 на бесконечности). Истинная же дисперсия вообще может не существовать. Тогда возникает вопрос о применимости ЦПТ.

И здесь на помощь приходит дельта-метод, который расширяет заявленную в ЦПТ асимптотическую нормальность на любое дифференцируемое преобразование ![g(\dots)](https://habrastorage.org/getpro/habr/upload_files/8b0/238/f58/8b0238f584571669499b00f1bc862cef.svg) от некоторой случайной величины ![T_n](https://habrastorage.org/getpro/habr/upload_files/93c/ef9/d42/93cef9d42aa6835358354a22a7833fea.svg) и утверждает, что:

![\text{Если для } T_n \text{ и некоторой константы } \theta \text{ выполняется} \\ \sqrt{n}(T_n-\theta) \to N(0,1) \text{ при } n\to \infty, \\  \text{то для дифференцируемой функции } g(\dots) \text{ верно: } \\  \sqrt{n}(g(T_n) - g(\theta)) \to N(0, g'(\theta)^2)](https://habrastorage.org/getpro/habr/upload_files/159/bb5/828/159bb58286479a5c873031f7741660e3.svg)

Так чем же это хорошо? А тем, что вместо ![T_n](https://habrastorage.org/getpro/habr/upload_files/a85/38e/bdc/a8538ebdc627b864b388853dd894e12c.svg) мы можем рассматривать пару ![(Y_n, X_n)](https://habrastorage.org/getpro/habr/upload_files/c13/6de/638/c136de638b9cb1cb1c3b17693125f6bc.svg), где ![Y_n](https://habrastorage.org/getpro/habr/upload_files/da0/b70/c1a/da0b70c1a7bb3caa435af7bcbd10a8f7.svg)— это, например, наши назначенные автомобили, а ![X_n](https://habrastorage.org/getpro/habr/upload_files/2e7/56c/5c1/2e756c5c10376436994456e14f189b5e.svg) — заказы. В качестве ![\theta](https://habrastorage.org/getpro/habr/upload_files/872/17a/155/87217a1557daf30b4284a22ac1b22986.svg) можно взять ![(\overline{X}, \overline{Y})](https://habrastorage.org/getpro/habr/upload_files/6dc/69e/fc4/6dc69efc4df5f3f0d9cf3bac86e53a2d.svg), в качестве ![g(\dots)](https://habrastorage.org/getpro/habr/upload_files/59e/9fa/3ab/59e9fa3ab6315a158311167ca5a771a4.svg) взять ![g(x,y) = \frac{y}{x}](https://habrastorage.org/getpro/habr/upload_files/5ab/761/d4e/5ab761d4e5d2b3835a244bbacc4c164e.svg). Вот и всё, мы уже в шаге от доверительного интервала для нашей конверсии, правда, он чуть менее простой (полный вывод смотрите в [статье](https://arxiv.org/pdf/1803.06336.pdf) Microsoft), чем в изначальном варианте, но его всё ещё легко закодить:

![\frac{\overline{X}}{\overline{Y}} - 1 \pm \frac{z_{\alpha/2}}{\sqrt{n}\overline{X}}\sqrt{s_y^2 - 2\frac{\overline{Y}}{\overline{X}}s_{xy} + \frac{\overline{Y}^2}{\overline{X}^2}s^2_x}](https://habrastorage.org/getpro/habr/upload_files/6dd/68a/c43/6dd68ac437ddc72258812f4b35cd7011.svg)

Ну всё, поехали сравнивать улучшенные варианты тестов.

#### Результаты

Первым делом убеждаемся, что с применимостью всё в порядке. Для наглядности посмотрим все наши тесты вместе.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6a0/815/3f7/6a08153f7e9eaf47ceef00bd5b196d87.png)

Ничего нового, с **линеаризацией** и **дельта-методом** всё хорошо.

Ну и наконец (*_барабанная дробь*_), результаты наших финалистов! С маленьким, но преимуществом в третьем знаке после запятой по выдаваемой мощности побеждает **t-test + линеаризация**!

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f7b/d9f/035/f7bd9f03507047d5b4a78a5aa770d584.png)

Результаты отчасти ожидаемые, но всё равно приятные​

## Куда дальше?

Наши маленькие соревнования завершены, и мы полностью довольны нашим победителем. Надеемся, что для своих метрик вы по приведённому выше шаблону сможете подобрать лучший тест.

Мы не затронули ещё большой слой классных методов, которые позволяют предварительно обработать данные, полученные в эксперименте, и повысить мощность тестов или ускорить их расчёт. Из самых известных примеров это, конечно, **бакетизация** и **CUPED**, но них мы поговорим уже в следующих сериях, а пока всем прорывных идей и валидных экспериментов. Мы пошли ресерчить дальше​

В подготовке статьи участвовали Артём Солоухин, Ксения Мензорова, Николай Ишмаметьев. Также выражаем благодарность за помощь в подготовке статьи ребятам из [expf.ru](http://expf.ru/), Искандеру Мирмахмадову и Виталию Черемисинову.